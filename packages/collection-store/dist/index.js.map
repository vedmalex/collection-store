{
  "version": 3,
  "sources": ["../src/AdapterFile.ts", "../src/timeparse.ts", "../src/collection.ts", "../src/utils/autoIncIdGen.ts", "../src/utils/autoTimestamp.ts", "../src/types/Item.ts", "../src/query/types.ts", "../src/query/logical.ts", "../src/query/element.ts", "../src/query/comparison.ts", "../src/query/array.ts", "../src/query/evaluation.ts", "../src/query/bitwise.ts", "../src/query/text.ts", "../src/query/QueryType.ts", "../src/query/build_query.ts", "../src/query/js_types.ts", "../src/query/compare_utils.ts", "../src/query/compile_query.ts", "../src/query/query.ts", "../src/query/index.ts", "../src/iterators/last.ts", "../src/iterators/first.ts", "../src/iterators/all.ts", "../src/collection/prepare_index_insert.ts", "../src/collection/update_index.ts", "../src/collection/ensure_ttl.ts", "../src/collection/remove_index.ts", "../src/collection/create_index.ts", "../src/collection/ensure_indexed_value.ts", "../src/collection/get_value.ts", "../src/collection/validate_indexed_value_for_insert.ts", "../src/collection/validate_indexed_value_for_update.ts", "../src/collection/ensure_indexes.ts", "../src/utils/CompositeKeyUtils.ts", "../src/collection/build_indexes.ts", "../src/collection/is_valid_ttl.ts", "../src/collection/return_list_if_valid.ts", "../src/collection/get_indexed_value.ts", "../src/collection/return_one_if_valid.ts", "../src/collection/restore_index.ts", "../src/collection/restore_index_def.ts", "../src/utils/btree-serialization.ts", "../src/collection/deserialize_indexes.ts", "../src/collection/serialize_indexes.ts", "../src/collection/store_index.ts", "../src/collection/store_index_def.ts", "../src/collection/copy_collection.ts", "../src/collection/do_rotate_log.ts", "../src/collection/get_first_indexed_value.ts", "../src/collection/get_last_indexed_value.ts", "../src/collection/rebuild_indexes.ts", "../src/storage/List.ts", "../src/utils/entity_create.ts", "../src/utils/version_create.ts", "../src/utils/entity_update.ts", "../src/utils/entity_delete.ts", "../src/utils/is_stored_record.ts", "../src/AdapterMemory.ts", "../src/collection/serialize_collection_config.ts", "../src/storage/FileStorage.ts", "../src/CSDatabase.ts", "../src/collection/deserialize_collection_config.ts"],
  "sourcesContent": [
    "import pathLib from 'path'\nimport fs from 'fs-extra'\nimport { Item } from './types/Item'\nimport { IStorageAdapter } from './IStorageAdapter'\nimport Collection from './collection'\n\nexport default class AdapterFile<T extends Item> implements IStorageAdapter<T> {\n  get name() {\n    return 'AdapterFile' as const\n  }\n  get file(): string {\n    if (this.collection.list.singlefile) {\n      return pathLib.join(this.collection.root, `${this.collection.name}.json`)\n    }\n    return pathLib.join(this.collection.root, this.collection.name, 'metadata.json')\n  }\n  collection!: Collection<T>\n  clone() {\n    return new AdapterFile<T>()\n  }\n\n  init(collection: Collection<T>) {\n    this.collection = collection\n    return this\n  }\n\n  async restore(name?: string) {\n    let path = this.file\n    if (name) {\n      const p = { ...pathLib.parse(this.file) } as Partial<pathLib.ParsedPath>\n      p.name = name\n      delete p.base\n      path = pathLib.format(p)\n    }\n    if (fs.pathExistsSync(path)) {\n      return fs.readJSON(path)\n    }\n    return false\n  }\n\n  async store(name: string) {\n    let path = this.file\n    if (name) {\n      const p = { ...pathLib.parse(this.file) } as Partial<pathLib.ParsedPath>\n      p.name = name\n      delete p.base\n      path = pathLib.format(p)\n    }\n    await fs.ensureFile(path)\n\n    await fs.writeJSON(path, this.collection.store(), {\n      spaces: 2,\n    })\n  }\n}\n",
    "const units = {\n  Î¼s: 1,\n  ms: 1000,\n  s: 1000 * 1000,\n  m: 1000 * 1000 * 60,\n  h: 1000 * 1000 * 60 * 60,\n  d: 1000 * 1000 * 60 * 60 * 24,\n  w: 1000 * 1000 * 60 * 60 * 24 * 7,\n} as const\n\nexport default function parse(str: string, returnUnit: keyof typeof units = 'ms') {\n  let totalMicroseconds = 0\n\n  const groups = str.toLowerCase().match(/[-+]?[0-9\\.]+[a-z]+/g)\n\n  if (groups !== null) {\n    for (const g of groups) {\n      const value = parseFloat(g.match(/[0-9\\.]+/g)![0])\n      const unit = g.match(/[a-z]+/g)![0] as keyof typeof units\n\n      totalMicroseconds += getMicroseconds(value, unit)\n    }\n  }\n\n  return totalMicroseconds / units[returnUnit]\n}\n\nfunction getMicroseconds(value: number, unit: keyof typeof units) {\n  const result = units[unit]\n\n  if (result) {\n    return value * result\n  }\n\n  throw new Error(`The unit \"${unit}\" could not be recognized`)\n}\n",
    "// import fs from 'fs-extra';\nimport tp from './timeparse'\nimport * as _ from 'lodash-es'\nimport { autoIncIdGen } from './utils/autoIncIdGen'\nimport { autoTimestamp } from './utils/autoTimestamp'\nimport { IStorageAdapter } from './IStorageAdapter'\nimport { IList } from './IList'\nimport { IndexDef, SerializedIndexDef } from './types/IndexDef'\nimport { IndexStored } from './types/IndexStored'\nimport { Paths } from './types/Paths'\nimport { Item, ItemSchema } from './types/Item'\nimport { IdGeneratorFunction } from './types/IdGeneratorFunction'\nimport { IdType } from './types/IdType'\nimport {\n  ICollectionConfig,\n  ISerializedCollectionConfig,\n} from './ICollectionConfig'\nimport { CronJob } from 'cron'\nimport { Dictionary } from './types/Dictionary'\nimport { BPlusTree, ValueType } from 'b-pl-tree'\nimport { last } from './iterators/last'\nimport { first } from './iterators/first'\nimport { all } from './iterators/all'\nimport { TraverseCondition } from './types/TraverseCondition'\nimport { prepare_index_insert } from './collection/prepare_index_insert'\nimport { update_index } from './collection/update_index'\nimport { ensure_ttl } from './collection/ensure_ttl'\nimport { remove_index } from './collection/remove_index'\nimport { build_indexes } from './collection/build_indexes'\nimport { ensure_indexes } from './collection/ensure_indexes'\nimport { get_indexed_value } from './collection/get_indexed_value'\nimport { return_list_if_valid } from './collection/return_list_if_valid'\nimport { return_one_if_valid } from './collection/return_one_if_valid'\nimport { restore_index } from './collection/restore_index'\nimport { deserialize_indexes } from './collection/deserialize_indexes'\nimport { serialize_indexes } from './collection/serialize_indexes'\nimport { store_index } from './collection/store_index'\nimport { do_rotate_log } from './collection/do_rotate_log'\nimport { StoredIList } from './types/StoredIList'\nimport { get_first_indexed_value } from './collection/get_first_indexed_value'\nimport { get_last_indexed_value } from './collection/get_last_indexed_value'\nimport { rebuild_indexes } from './collection/rebuild_indexes'\nimport { List } from './storage/List'\nimport AdapterMemory from './AdapterMemory'\nimport { IDataCollection } from './IDataCollection'\nimport { ProcessInsert } from './ProcessInsert'\nimport { ProcessUpdates } from './ProcessUpdates'\nimport { ProcessRemoves } from './ProcessRemoves'\nimport { ProcessEnsure } from './ProcessEnsure'\nimport { ProcessRebuild } from './ProcessRebuild'\nimport { create_index } from './collection/create_index'\nimport { ZodError, ZodSchema, ZodType } from 'zod'\nimport { serialize_collection_config } from './collection/serialize_collection_config'\nimport { CompositeKeyUtils } from './utils/CompositeKeyUtils'\n\nexport const ttl_key = '__ttltime'\n\nexport default class Collection<T extends Item> implements IDataCollection<T> {\n  get config(): ISerializedCollectionConfig {\n    return serialize_collection_config(this)\n  }\n\n  /** unique generators */\n  static genCache: Dictionary<IdGeneratorFunction<any>> = {\n    autoIncIdGen: autoIncIdGen as IdGeneratorFunction<any>,\n    autoTimestamp: autoTimestamp as IdGeneratorFunction<any>,\n  }\n\n  root!: string\n  cronJob?: CronJob\n  async createIndex(name: string, config: IndexDef<T>): Promise<void> {\n    create_index(this, name, config)\n    await ensure_indexes(this)\n    //ensure\n    //rebuild\n  }\n\n  listIndexes(name: string) {\n    if (!name) {\n      return Object.keys(this.indexes).map((name) => ({\n        name,\n        key: { name: this.indexes[name] },\n      }))\n    } else {\n      if (this.indexes[name]) {\n        return [{ name, keys: { name: this.indexes[name] } }]\n      } else {\n        return [] as any\n      }\n    }\n  }\n\n  dropIndex(name: string) {\n    delete this.indexes[name]\n  }\n\n  storage!: IStorageAdapter<T>\n  /** ttl for collection in ms */\n  ttl?: number\n  /** cron tab time */\n  rotate?: string\n  /** model name */\n  name!: string\n  /** field that is used for identity */\n  id!: string\n  /** is autioincrement */\n  auto?: boolean\n  /** audit */\n  audit!: boolean\n  /** zod validator */\n  validation: ZodType<T> = ItemSchema as ZodSchema<T>\n  validator(item: T):\n    | { success: true; data: T }\n    | {\n      success: false\n      errors: ZodError<T>\n    } {\n    if (this.validation) {\n      return this.validation.safeParse(item) as any\n    } else {\n      return { success: true, data: item as T }\n    }\n  }\n  /**indexes */\n  indexes!: { [index: string]: BPlusTree<any, any> }\n  /** main storage */\n  list!: IList<T>\n  /** actions in insert */\n  inserts!: Array<ProcessInsert<T>>\n  /** actions in update */\n  updates!: Array<ProcessUpdates<T>>\n  /** actions in remove */\n  removes!: Array<ProcessRemoves<T>>\n  /** actions in ensure */\n  ensures!: Array<ProcessEnsure>\n  rebuilds!: Array<ProcessRebuild>\n  /** index definition */\n  indexDefs!: Dictionary<IndexDef<T>>\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  private constructor() { }\n\n  static create<T extends Item>(config?: ICollectionConfig<T>) {\n    const collection: Collection<T> = new Collection<T>()\n    const {\n      ttl,\n      rotate,\n      name,\n      id = {\n        name: 'id',\n        auto: true,\n        gen: 'autoIncIdGen',\n      },\n      auto = true,\n      indexList,\n      list = new List<T>() as IList<T>,\n      adapter = new AdapterMemory<T>(),\n      validation,\n      audit,\n      root,\n    } = config ?? {}\n\n    collection.audit = !!audit\n    if (validation) {\n      collection.validation = validation\n    }\n    collection.root = root ?? './data/'\n\n    let { idGen = 'autoIncIdGen' } = config ?? {}\n\n    if (typeof idGen == 'function') {\n      idGen = idGen.toString()\n    }\n\n    if (rotate) {\n      collection.cronJob = new CronJob(rotate, () => {\n        do_rotate_log(collection)\n      })\n      collection.cronJob.start()\n    }\n\n    let Id: Partial<IdType<T>> = typeof id == 'string' ? { name: id } : id\n\n    if ('string' == typeof id) {\n      Id = {\n        name: id,\n        auto: auto != null ? auto : true,\n        gen: idGen,\n      }\n    }\n\n    if (!Id.name) {\n      Id.name = 'id'\n    }\n\n    if (Id.gen == null) {\n      Id.gen = idGen\n    }\n\n    if (!name) {\n      throw new Error('must Have Model Name as \"name\" prop in config')\n    }\n\n    collection.ttl = (typeof ttl == 'string' ? tp(ttl) : ttl) || undefined\n\n    collection.rotate = rotate\n    collection.name = name\n    collection.storage = adapter.init(collection)\n    collection.id = Id.name\n    collection.auto = Id.auto\n    collection.indexes = {}\n    collection.list = list\n    collection.indexDefs = {}\n    collection.inserts = []\n    collection.removes = []\n    collection.updates = []\n    collection.ensures = []\n    collection.rebuilds = []\n\n    const defIndex: Array<IndexDef<T>> = [\n      {\n        key: collection.id,\n        // type: 'number',\n        auto: collection.auto,\n        gen:\n          typeof Id.gen == 'function'\n            ? Id.gen\n            : Id.gen && Collection.genCache[Id.gen]\n              ? Collection.genCache[Id.gen]\n              : Id.gen ? eval(Id.gen) : undefined,\n        unique: true,\n        sparse: false,\n        required: true,\n      },\n    ]\n\n    if (collection.ttl) {\n      defIndex.push({\n        key: ttl_key,\n        auto: true,\n        gen: Collection.genCache['autoTimestamp'],\n        unique: false,\n        sparse: false,\n        required: true,\n      })\n    }\n\n    if (collection.rotate) {\n      defIndex.push({\n        key: ttl_key,\n        auto: true,\n        gen: Collection.genCache['autoTimestamp'],\n        unique: false,\n        sparse: false,\n        required: true,\n      })\n    }\n\n    build_indexes(\n      collection,\n      defIndex.concat(indexList || []).reduce((prev, curr) => {\n        if (curr.key == '*') {\n          prev[curr.key as string] = {\n            key: '*',\n            auto: false,\n            unique: false,\n            gen: undefined,\n            sparse: false,\n            required: false,\n            ignoreCase: true,\n          }\n        } else {\n          // Use unified approach for index processing\n          try {\n            const normalizedFields = CompositeKeyUtils.normalizeIndexFields(curr)\n            const isCompositeIndex = normalizedFields.length > 1\n            const indexKey = CompositeKeyUtils.generateIndexName(normalizedFields)\n\n                        // Determine separator for composite indexes\n            let separator: string | undefined\n            if (isCompositeIndex) {\n              separator = curr.separator || CompositeKeyUtils.DEFAULT_SEPARATOR\n            }\n\n            prev[indexKey] = {\n              key: isCompositeIndex ? undefined : normalizedFields[0].key,\n              keys: isCompositeIndex ? normalizedFields : undefined,\n              order: !isCompositeIndex ? normalizedFields[0].order : undefined,\n              separator: separator,\n              auto: curr.auto || false,\n              unique: curr.unique || false,\n              gen:\n                curr.gen ||\n                (curr.auto ? Collection.genCache['autoIncIdGen'] : undefined),\n              sparse: curr.sparse || false,\n              required: curr.required || false,\n              ignoreCase: curr.ignoreCase,\n              process: curr.process,\n            }\n          } catch (error) {\n            throw new Error(`Invalid index definition: ${error.message}`)\n          }\n        }\n        return prev\n      }, {} as Dictionary<IndexDef<T>>),\n    )\n    collection.list.init(collection)\n    // Ð¿ÑÐ¸Ð´ÑÐ¼Ð°ÑÑ Ð·Ð°Ð³ÑÑÐ·ÐºÑ\n    ensure_indexes(collection) ///??\n\n    return collection\n  }\n\n  static async fromList<T extends Item>(\n    array: Array<T>,\n    id: string,\n    root: string,\n  ) {\n    const list = Collection.create({\n      root,\n      name: 'default',\n      indexList: [{ key: '*' }, { key: id, unique: true, required: true }],\n      id: { name: '$order', auto: true },\n      list: new List<T>(),\n      adapter: new AdapterMemory<T>(),\n    })\n    await Promise.all(array.map((item) => list.create(item)))\n    return list\n  }\n\n  async reset(): Promise<void> {\n    await this.list.reset()\n    this.indexes = {}\n    ensure_indexes(this)\n  }\n\n  async load(name?: string): Promise<void> {\n    try {\n      const stored = await this.storage.restore(name)\n      if (stored) {\n        const { indexes, list, indexDefs, id, ttl } = stored\n        this.list.load(list)\n        this.indexDefs = restore_index(this, indexDefs)\n        this.id = id\n        this.ttl = ttl\n\n        this.inserts = []\n        this.removes = []\n        this.updates = []\n        this.ensures = []\n\n        this.indexes = {}\n        build_indexes(this, this.indexDefs)\n\n        this.indexes = deserialize_indexes(indexes)\n        await rebuild_indexes(this)\n      }\n    } catch (e) {\n      // throw e\n    }\n    await ensure_ttl(this)\n  }\n\n  store(): {\n    list: StoredIList\n    indexes: { [key: string]: unknown }\n    indexDefs: Dictionary<IndexStored<T>>\n    id: string\n    ttl?: number\n    rotate?: number\n  } {\n    return {\n      list: this.list.persist(),\n      indexes: serialize_indexes(this.indexes),\n      indexDefs: store_index(this, this.indexDefs),\n      id: this.id,\n      ttl: this.ttl,\n      rotate: this.rotate ? parseInt(this.rotate) : undefined,\n    }\n  }\n\n  async persist(name?: string): Promise<void> {\n    await this.storage.store(name)\n  }\n\n  //\n  async push(item: T): Promise<T | undefined> {\n    // apply default once it is created\n    const insert_indexed_values = prepare_index_insert(this, item)\n    const id = item[this.id]\n    const res = await this.list.set(id, item)\n    insert_indexed_values(id)\n    return return_one_if_valid(this, res)\n  }\n\n  async create(item: T): Promise<T | undefined> {\n    const res = { ...item } as T\n    const value = await this.push(res)\n    return value\n  }\n\n  async save(res: T): Promise<T | undefined> {\n    const id = res[this.id]\n    const item = await this.findById(id)\n    await update_index(this, item as T, res as T, id)\n    await this.list.update(id, res)\n    return return_one_if_valid(this, res)\n  }\n\n  async first(): Promise<T> {\n    return (await first(this, () => true).next()).value\n  }\n\n  async last(): Promise<T> {\n    return (await last(this, () => true).next()).value\n  }\n\n  lowest(key: Paths<T>): Promise<T | undefined> {\n    return this.findFirstBy(key, this.indexes[key].min)\n  }\n\n  greatest(key: Paths<T>): Promise<T | undefined> {\n    return this.findLastBy(key, this.indexes[key].max)\n  }\n\n  oldest(): Promise<T | undefined> {\n    if (this.ttl) {\n      return this.lowest(ttl_key as any)\n    } else return this.first()\n  }\n\n  latest(): Promise<T | undefined> {\n    if (this.ttl) {\n      return this.greatest(ttl_key as any)\n    } else return this.last()\n  }\n\n  async findById(id: ValueType): Promise<T | undefined> {\n    const indexDef = this.indexDefs[this.id]\n    if (indexDef?.process) {\n      id = indexDef.process(id)\n    }\n    const index = this.indexes[this.id]\n    if (!index) {\n      throw new Error(`Index for ${this.id} not found`)\n    }\n    const result = await this.list.get(index.findFirst(id))\n    return return_one_if_valid(this, result)\n  }\n\n  async findBy(key: Paths<T>, id: ValueType): Promise<Array<T>> {\n    if (this.indexDefs.hasOwnProperty(key)) {\n      const indexDef = this.indexDefs[key as string]\n\n      // For composite indexes, don't apply process function when searching\n      // because we expect the caller to pass an already serialized composite key\n      const isCompositeIndex = !!(indexDef.keys && indexDef.keys.length > 1)\n              if (indexDef?.process && !isCompositeIndex) {\n        id = indexDef.process(id)\n      }\n\n      const result = []\n      if (this.indexDefs.hasOwnProperty(key)) {\n        result.push(...(await get_indexed_value(this, key, id)))\n      }\n      return return_list_if_valid(this, result)\n    } else {\n      throw new Error(`Index for ${key} not found`)\n    }\n  }\n\n  async findFirstBy(key: Paths<T>, id: ValueType): Promise<T | undefined> {\n    if (this.indexDefs.hasOwnProperty(key)) {\n      const indexDef = this.indexDefs[key as string]\n\n      // For composite indexes, don't apply process function when searching\n      const isCompositeIndex = !!(indexDef.keys && indexDef.keys.length > 1)\n      if (indexDef?.process && !isCompositeIndex) {\n        id = indexDef.process(id)\n      }\n\n      if (this.indexDefs.hasOwnProperty(key)) {\n        const result = await get_first_indexed_value(this, key, id)\n        return return_one_if_valid(this, result)\n      }\n    }\n    throw new Error(`Index for ${key} not found`)\n  }\n\n  async findLastBy(key: Paths<T>, id: ValueType): Promise<T | undefined> {\n    if (this.indexDefs.hasOwnProperty(key)) {\n      const indexDef = this.indexDefs[key as string]\n\n      // For composite indexes, don't apply process function when searching\n      const isCompositeIndex = !!(indexDef.keys && indexDef.keys.length > 1)\n      if (indexDef?.process && !isCompositeIndex) {\n        id = indexDef.process(id)\n      }\n\n      if (this.indexDefs.hasOwnProperty(key)) {\n        const result = await get_last_indexed_value(this, key, id)\n        return return_one_if_valid(this, result)\n      }\n    }\n    throw new Error(`Index for ${key} not found`)\n  }\n\n  async find(condition: TraverseCondition<T>): Promise<Array<T>> {\n    const result: Array<T> = []\n    for await (const item of all(this, condition)) {\n      result.push(item)\n    }\n    return return_list_if_valid(this, result)\n  }\n\n  async findFirst(condition: TraverseCondition<T>): Promise<T | undefined> {\n    const result: T = await (await first(this, condition).next()).value\n    return return_one_if_valid(this, result)\n  }\n\n  async findLast(condition: TraverseCondition<T>): Promise<T | undefined> {\n    const result: T = await (await last(this, condition).next()).value\n    return return_one_if_valid(this, result)\n  }\n\n  async update(\n    condition: TraverseCondition<T>,\n    update: Partial<T>,\n    merge: boolean = true,\n  ): Promise<Array<T>> {\n    const result: Array<T> = []\n    for await (const item of all(this, condition)) {\n      const res = merge ? _.merge({}, item, update) : _.assign({}, item, update)\n      await update_index(this, item, res as T, item[this.id])\n      await this.list.update(item[this.id], res)\n      result.push(res)\n    }\n    return return_list_if_valid<T>(this, result)\n  }\n\n  async updateFirst(\n    condition: TraverseCondition<T>,\n    update: Partial<T>,\n    merge: boolean = true,\n  ): Promise<T | undefined> {\n    const item: T = await (await first(this, condition).next()).value\n    const res = merge ? _.merge({}, item, update) : _.assign({}, item, update)\n    await update_index(this, item, res as T, item[this.id])\n    await this.list.update(item[this.id], res)\n    return return_one_if_valid(this, res as T)\n  }\n\n  async updateLast(\n    condition: TraverseCondition<T>,\n    update: Partial<T>,\n    merge: boolean = true,\n  ): Promise<T | undefined> {\n    const item: T = await (await last(this, condition).next()).value\n    const res = merge ? _.merge({}, item, update) : _.assign({}, item, update)\n    await update_index(this, item, res as T, item[this.id])\n    await this.list.update(item[this.id], res)\n\n    return return_one_if_valid(this, res as T)\n  }\n\n  async updateWithId(\n    id: ValueType,\n    update: Partial<T>,\n    merge: boolean = true,\n  ): Promise<T | undefined> {\n    const item = await this.findById(id)\n    const res = merge ? _.merge({}, item, update) : _.assign({}, item, update)\n    await update_index(this, item as T, res as T, id)\n    await this.list.update(id, res)\n    return return_one_if_valid(this, res as T)\n  }\n\n  async removeWithId(id: ValueType): Promise<T | undefined> {\n    const indexDef = this.indexDefs[this.id]\n    if (indexDef?.process) {\n      id = indexDef.process(id)\n    }\n    const index = this.indexes[this.id]\n    if (!index) {\n      throw new Error(`Index for ${this.id} not found`)\n    }\n    const i = index.findFirst(id)\n    const cur = await this.list.get(i)\n    if (i !== undefined && cur) {\n      remove_index(this, cur)\n      const result = await this.list.delete(id) // Use the actual ID, not the index position\n      return return_one_if_valid(this, result)\n    }\n  }\n\n  async remove(condition: TraverseCondition<T>): Promise<Array<T | undefined>> {\n    const result: Array<T> = []\n    for await (const cur of all(this, condition)) {\n      remove_index(this, cur)\n      const res = await this.list.delete(cur[this.id])\n      result.push(res)\n    }\n    return return_list_if_valid<T>(this, result)\n  }\n\n  async removeFirst(condition: TraverseCondition<T>): Promise<T | undefined> {\n    const item: T = await (await first(this, condition).next()).value\n    remove_index(this, item)\n    await this.list.delete(item[this.id])\n    return return_one_if_valid(this, item)\n  }\n  async removeLast(condition: TraverseCondition<T>): Promise<T | undefined> {\n    const item: T = await (await last(this, condition).next()).value\n    remove_index(this, item)\n    await this.list.delete(item[this.id])\n    return return_one_if_valid(this, item)\n  }\n}\n\nexport function serializeIndex<T extends Item>(\n  res: IndexDef<T>,\n): SerializedIndexDef {\n  return {\n    key: res.key as string,\n    keys: res.keys as any,\n    order: res.order,\n    separator: res.separator,\n    auto: res.auto ? true : undefined,\n    unique: res.unique ? true : undefined,\n    sparse: res.sparse ? true : undefined,\n    ignoreCase: res.ignoreCase ? true : undefined,\n    required: res.required ? true : undefined,\n    gen: res.gen?.name ?? undefined,\n    process: res.process?.toString() ?? undefined,\n  }\n}\n\nexport function deserializeIndex<T extends Item>(\n  res: SerializedIndexDef,\n): IndexDef<T> {\n  return {\n    key: res.key,\n    keys: res.keys as any,\n    order: res.order,\n    separator: res.separator,\n    auto: res.auto ? true : undefined,\n    unique: res.unique ? true : undefined,\n    sparse: res.sparse ? true : undefined,\n    ignoreCase: res.ignoreCase ? true : undefined,\n    required: res.required ? true : undefined,\n    gen: res.gen ? Collection.genCache[res.gen] : undefined,\n    process: res.process ? eval(res.process) : undefined,\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport { IList } from '../IList'\n\nexport function autoIncIdGen<T extends Item>(\n  item: T,\n  model: string,\n  list: IList<T>,\n) {\n  return list.counter\n}\n",
    "import { Item } from '../types/Item'\nimport { IList } from '../IList'\n\nexport function autoTimestamp<T extends Item>(\n  item: T,\n  model: string,\n  list: IList<T>,\n) {\n  return Date.now()\n}\n",
    "import { z } from 'zod'\n\nexport interface Item {\n  __ttltime?: number\n  id?: number | string\n  [key: string]: any\n}\n\nexport const ItemSchema = z\n  .object({\n    __ttltime: z.number().optional(),\n    id: z.union([z.number(), z.string()]).optional(),\n  })\n  .passthrough()\n",
    "// Basic types for all operators\n\n// ÐÐ¿ÑÐµÐ´ÐµÐ»ÑÐµÐ¼ Ð±Ð°Ð·Ð¾Ð²ÑÐµ ÑÐ¸Ð¿Ñ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ð¹\nexport type PrimitiveValue =\n  | string\n  | number\n  | bigint\n  | boolean\n  | null\n  | undefined\nexport type ComplexValue = Date | RegExp\nexport type ArrayValue = Array<QueryValue>\nexport type ObjectValue = { [key: string]: QueryValue }\nexport type FunctionValue = (this: any, ...args: any[]) => any\n\n// ÐÐ°Ð·Ð¾Ð²ÑÐ¹ Ð¸Ð½ÑÐµÑÑÐµÐ¹Ñ Ð´Ð»Ñ Ð²ÑÐµÑ Ð¾Ð¿ÐµÑÐ°ÑÐ¾ÑÐ¾Ð²\nexport interface QueryOperator {\n  type: string\n  evaluate(value: any, context?: any): boolean\n  [key: string]: any // ÐÐ¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð¸Ð½Ð´ÐµÐºÑÐ½ÑÑ ÑÐ¸Ð³Ð½Ð°ÑÑÑÑ\n}\n\n// Ð ÐµÐºÑÑÑÐ¸Ð²Ð½ÑÐ¹ ÑÐ¸Ð¿ Ð´Ð»Ñ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ð¹ Ð·Ð°Ð¿ÑÐ¾ÑÐ°\nexport type QueryValue =\n  | PrimitiveValue\n  | ComplexValue\n  | ArrayValue\n  | ObjectValue\n  | FunctionValue\n  | QueryOperator\n\n// Type guard to check if something is a QueryOperator\nexport function isQueryOperator(value: any): value is QueryOperator {\n  return (\n    value && typeof value === 'object' && typeof value.evaluate === 'function'\n  )\n}\n\n// Common error class for query operators\nexport class QueryOperatorError extends Error {\n  override name: string\n  operator: string\n  value?: any\n\n  constructor(message: string, operator: string, value?: any) {\n    // Handle potential BigInt serialization issue in JSON.stringify\n    let valueString = ''\n    if (value !== undefined) {\n      try {\n        valueString = JSON.stringify(\n          value,\n          (_key, val) => (typeof val === 'bigint' ? val.toString() : val), // Convert BigInt to string\n        )\n      } catch (e) {\n        valueString = String(value) // Fallback to simple string conversion\n      }\n    }\n    super(\n      `${operator}: ${message}${valueString ? ` (value: ${valueString})` : ''}`,\n    )\n    this.name = 'QueryOperatorError'\n    this.operator = operator\n    this.value = value\n  }\n}\n\n// Types for specific operator categories\nexport interface LogicalOperator extends QueryOperator {\n  type: 'logical'\n}\n\nexport interface ElementOperator extends QueryOperator {\n  type: 'element'\n}\n\nexport interface ArrayOperator extends QueryOperator {\n  type: 'array'\n}\n\nexport interface EvaluationOperator extends QueryOperator {\n  type: 'evaluation'\n}\n\nexport interface BitwiseOperator extends QueryOperator {\n  type: 'bitwise'\n}\n\nexport interface TextSearchOperatorType extends QueryOperator {\n  type: 'text'\n}\n\nexport interface ComparisonOperator extends QueryOperator {\n  type: 'comparison'\n}\n\n// Helper type for operator constructors\nexport type OperatorConstructor<T extends QueryOperator> = new (\n  value: QueryValue,\n) => T\n",
    "import {\n  LogicalOperator,\n  QueryOperator,\n  QueryValue,\n  QueryOperatorError,\n  isQueryOperator,\n} from './types'\n\n// $and operator\nexport class AndOperator implements LogicalOperator {\n  type = 'logical' as const\n  private conditions: QueryOperator[]\n\n  constructor(conditions: QueryValue[]) {\n    if (!Array.isArray(conditions)) {\n      throw new QueryOperatorError(\n        '$and requires an array of conditions',\n        '$and',\n        conditions,\n      )\n    }\n    this.conditions = conditions.map((condition) => {\n      if (!condition || typeof condition !== 'object') {\n        throw new QueryOperatorError(\n          'Each condition in $and must be an object',\n          '$and',\n          condition,\n        )\n      }\n      return condition as unknown as QueryOperator\n    })\n  }\n\n  evaluate(value: any, context?: any): boolean {\n    return this.conditions.every((condition) =>\n      condition.evaluate(value, context),\n    )\n  }\n}\n\n// $or operator\nexport class OrOperator implements LogicalOperator {\n  type = 'logical' as const\n  private conditions: QueryOperator[]\n\n  constructor(conditions: QueryValue[]) {\n    if (!Array.isArray(conditions)) {\n      throw new QueryOperatorError(\n        '$or requires an array of conditions',\n        '$or',\n        conditions,\n      )\n    }\n    this.conditions = conditions.map((condition) => {\n      if (!condition || typeof condition !== 'object') {\n        throw new QueryOperatorError(\n          'Each condition in $or must be an object',\n          '$or',\n          condition,\n        )\n      }\n      return condition as unknown as QueryOperator\n    })\n  }\n\n  evaluate(value: any, context?: any): boolean {\n    return this.conditions.some((condition) =>\n      condition.evaluate(value, context),\n    )\n  }\n}\n\n// $not operator\nexport class NotOperator implements LogicalOperator {\n  type = 'logical' as const\n  private condition: QueryOperator\n\n  constructor(condition: QueryValue) {\n    if (!isQueryOperator(condition)) {\n      throw new QueryOperatorError(\n        '$not requires a valid QueryOperator object condition',\n        '$not',\n        condition,\n      )\n    }\n    this.condition = condition as unknown as QueryOperator\n  }\n\n  evaluate(value: any, context?: any): boolean {\n    return !this.condition.evaluate(value, context)\n  }\n}\n\n// $nor operator\nexport class NorOperator implements LogicalOperator {\n  type = 'logical' as const\n  private conditions: QueryOperator[]\n\n  constructor(conditions: QueryValue[]) {\n    if (!Array.isArray(conditions)) {\n      throw new QueryOperatorError(\n        '$nor requires an array of conditions',\n        '$nor',\n        conditions,\n      )\n    }\n    this.conditions = conditions.map((condition) => {\n      if (!condition || typeof condition !== 'object') {\n        throw new QueryOperatorError(\n          'Each condition in $nor must be an object',\n          '$nor',\n          condition,\n        )\n      }\n      return condition as unknown as QueryOperator\n    })\n  }\n\n  evaluate(value: any, context?: any): boolean {\n    return !this.conditions.some((condition) =>\n      condition.evaluate(value, context),\n    )\n  }\n}\n\n// Export a map of logical operators\nexport const logicalOperators = {\n  $and: AndOperator,\n  $or: OrOperator,\n  $not: NotOperator,\n  $nor: NorOperator,\n} as const\n\n// Type guard for logical operators\nexport function isLogicalOperator(value: any): value is LogicalOperator {\n  return value && typeof value === 'object' && value.type === 'logical'\n}\n",
    "import { ElementOperator, QueryValue, QueryOperatorError } from './types'\n\n// $exists operator\nexport class ExistsOperator implements ElementOperator {\n  type = 'element' as const\n  private shouldExist: boolean\n\n  constructor(value: QueryValue) {\n    if (typeof value !== 'boolean') {\n      throw new QueryOperatorError(\n        '$exists requires a boolean value',\n        '$exists',\n        value,\n      )\n    }\n    this.shouldExist = value\n  }\n\n  evaluate(value: any): boolean {\n    return this.shouldExist ? value !== undefined : value === undefined\n  }\n}\n\n// $type operator - Updated implementation based on query/$type.ts for BSON compatibility\nexport class TypeOperator implements ElementOperator {\n  type = 'element' as const\n  private checkers: ((v: unknown) => boolean)[]\n\n  // Match BSON type names/aliases/numbers to JS checks\n  // See: https://www.mongodb.com/docs/manual/reference/operator/query/type/#bson-types\n  private static typeCheckers: Record<\n    string | number,\n    (v: unknown) => boolean\n  > = {\n    double: (v) => typeof v === 'number' && !Number.isInteger(v),\n    1: (v) => typeof v === 'number' && !Number.isInteger(v),\n    string: (v) => typeof v === 'string',\n    2: (v) => typeof v === 'string',\n    object: (v) =>\n      typeof v === 'object' &&\n      v !== null &&\n      !Array.isArray(v) &&\n      !(v instanceof Date) &&\n      !(v instanceof RegExp) &&\n      !(v instanceof Uint8Array) &&\n      !(typeof Buffer !== 'undefined' && v instanceof Buffer) &&\n      (v as any)._bsontype !== 'ObjectId',\n    3: (v) =>\n      typeof v === 'object' &&\n      v !== null &&\n      !Array.isArray(v) &&\n      !(v instanceof Date) &&\n      !(v instanceof RegExp) &&\n      !(v instanceof Uint8Array) &&\n      !(typeof Buffer !== 'undefined' && v instanceof Buffer) &&\n      (v as any)._bsontype !== 'ObjectId',\n    array: (v) => Array.isArray(v),\n    4: (v) => Array.isArray(v),\n    binData: (v) =>\n      v instanceof Uint8Array ||\n      (typeof Buffer !== 'undefined' && v instanceof Buffer),\n    5: (v) =>\n      v instanceof Uint8Array ||\n      (typeof Buffer !== 'undefined' && v instanceof Buffer),\n    undefined: (v) => v === undefined,\n    6: (v) => v === undefined,\n    objectId: (v) =>\n      typeof v === 'object' &&\n      v !== null &&\n      (v as any)._bsontype === 'ObjectId',\n    7: (v) =>\n      typeof v === 'object' &&\n      v !== null &&\n      (v as any)._bsontype === 'ObjectId',\n    bool: (v) => typeof v === 'boolean',\n    boolean: (v) => typeof v === 'boolean', // Add support for 'boolean' alias\n    8: (v) => typeof v === 'boolean',\n    date: (v) => v instanceof Date,\n    9: (v) => v instanceof Date,\n    null: (v) => v === null,\n    10: (v) => v === null,\n    regex: (v) => v instanceof RegExp,\n    11: (v) => v instanceof RegExp,\n    int: (v) => typeof v === 'number' && Number.isInteger(v),\n    16: (v) => typeof v === 'number' && Number.isInteger(v),\n    long: (v) =>\n      typeof v === 'bigint' || (typeof v === 'number' && Number.isInteger(v)),\n    18: (v) =>\n      typeof v === 'bigint' || (typeof v === 'number' && Number.isInteger(v)),\n    number: (v) => typeof v === 'number' || typeof v === 'bigint',\n  }\n\n  constructor(value: QueryValue) {\n    const typesToMatch = Array.isArray(value) ? value : [value]\n\n    if (\n      !typesToMatch.every((t) => typeof t === 'string' || typeof t === 'number')\n    ) {\n      throw new QueryOperatorError(\n        '$type requires a BSON type string/number or an array of them',\n        '$type',\n        value,\n      )\n    }\n\n    this.checkers = typesToMatch.map((t) => {\n      const checker = TypeOperator.typeCheckers[t]\n      if (!checker) {\n        throw new QueryOperatorError(\n          `Unsupported BSON type specified: ${t}`,\n          '$type',\n          t,\n        )\n      }\n      return checker\n    })\n\n    if (this.checkers.length === 0) {\n      throw new QueryOperatorError(\n        'No valid BSON types provided',\n        '$type',\n        value,\n      )\n    }\n  }\n\n  evaluate(value: any, _context?: any): boolean {\n    return this.checkers.some((checker) => checker(value))\n  }\n}\n\n// Export a map of element operators\nexport const elementOperators = {\n  $exists: ExistsOperator,\n  $type: TypeOperator,\n} as const\n\n// Type guard for element operators\nexport function isElementOperator(value: any): value is ElementOperator {\n  return value && typeof value === 'object' && value.type === 'element'\n}\n",
    "import { QueryValue, QueryOperatorError, ComparisonOperator } from './types'\n\n// --- BSON Comparison Utility --- BSON type comparison order\n\n// Define an order for BSON types (simplified subset)\n// Based on: https://docs.mongodb.com/manual/reference/bson-type-comparison-order/\n// 1. Null\n// 2. Numbers (int, long, double, decimal)\n// 3. String\n// 4. Object\n// 5. Array\n// 6. BinData (skipped)\n// 7. ObjectId (skipped)\n// 8. Boolean\n// 9. Date\n// 10. Timestamp (skipped)\n// 11. Regex (skipped)\nconst BSON_TYPE_ORDER = {\n  null: 1,\n  number: 2, // Includes bigint approximation\n  string: 3,\n  object: 4, // Plain objects\n  array: 5,\n  boolean: 8,\n  date: 9,\n  // Add other types here if needed\n}\n\nfunction getBSONTypeOrder(value: unknown): number {\n  if (value === null) return BSON_TYPE_ORDER.null\n  const jsType = typeof value\n  if (jsType === 'number' || jsType === 'bigint') return BSON_TYPE_ORDER.number\n  if (jsType === 'string') return BSON_TYPE_ORDER.string\n  if (jsType === 'boolean') return BSON_TYPE_ORDER.boolean\n  if (value instanceof Date) return BSON_TYPE_ORDER.date\n  if (Array.isArray(value)) return BSON_TYPE_ORDER.array\n  if (jsType === 'object') return BSON_TYPE_ORDER.object\n  // For unsupported types, assign a high order or handle specifically\n  return Infinity // Or throw error?\n}\n\n/**\n * Compares two JavaScript values based on a simplified BSON comparison order.\n * @returns -1 if v1 < v2, 0 if v1 == v2, 1 if v1 > v2\n * Returns null if values are incomparable (e.g., involving undefined).\n */\nexport function compareBSONValues(v1: unknown, v2: unknown): number | null {\n  // 1. Handle undefined: Undefined is incomparable\n  if (v1 === undefined || v2 === undefined) {\n    // Exception: undefined === undefined (handled by deepCompare)\n    if (v1 === undefined && v2 === undefined) return 0 // Or rely on deepCompare?\n    // If one is undefined, they are incomparable for gt/lt/gte/lte purposes\n    return null\n  }\n\n  // 2. Handle deep equality first (covers same values, types, Dates, and now Arrays)\n  if (deepCompare(v1, v2)) {\n    return 0\n  }\n\n  const typeOrder1 = getBSONTypeOrder(v1)\n  const typeOrder2 = getBSONTypeOrder(v2)\n\n  // 3. If types differ, compare based on type order\n  if (typeOrder1 !== typeOrder2) {\n    return typeOrder1 < typeOrder2 ? -1 : 1\n  }\n\n  // 4. If types are the same, perform type-specific comparison\n  // Comparable types: number, string, date, boolean, array (element-wise)\n  if (typeOrder1 === BSON_TYPE_ORDER.number) {\n    try {\n      const n1 = typeof v1 === 'bigint' ? v1 : BigInt(v1 as number)\n      const n2 = typeof v2 === 'bigint' ? v2 : BigInt(v2 as number)\n      return n1 < n2 ? -1 : n1 > n2 ? 1 : 0\n    } catch {\n      const n1 = v1 as number\n      const n2 = v2 as number\n      if (n1 < n2) return -1\n      if (n1 > n2) return 1\n      // Handle NaN comparison specifically? MongoDB treats NaN as equal to NaN.\n      if (isNaN(n1) && isNaN(n2)) return 0\n      if (isNaN(n1) || isNaN(n2)) return isNaN(n1) ? -1 : 1 // Or decide based on BSON spec\n      return 0\n    }\n  }\n  if (typeOrder1 === BSON_TYPE_ORDER.string) {\n    return (v1 as string) < (v2 as string) ? -1 : 1 // Assumes > is covered by !< and !=0\n  }\n  if (typeOrder1 === BSON_TYPE_ORDER.date) {\n    // deepCompare already handles dates, but we check again for explicit comparison\n    const time1 = (v1 as Date).getTime()\n    const time2 = (v2 as Date).getTime()\n    return time1 < time2 ? -1 : time1 > time2 ? 1 : 0\n  }\n  if (typeOrder1 === BSON_TYPE_ORDER.boolean) {\n    // false < true\n    return (v1 as boolean) < (v2 as boolean)\n      ? -1\n      : (v1 as boolean) > (v2 as boolean)\n        ? 1\n        : 0\n  }\n  if (typeOrder1 === BSON_TYPE_ORDER.array) {\n    // MongoDB array comparison: element by element until difference or end\n    const arr1 = v1 as unknown[]\n    const arr2 = v2 as unknown[]\n    const len = Math.min(arr1.length, arr2.length)\n    for (let i = 0; i < len; i++) {\n      const comp = compareBSONValues(arr1[i], arr2[i])\n      if (comp !== 0 && comp !== null) {\n        // Ignore null results? Check Mongo spec\n        return comp\n      }\n      // If comp is null (incomparable elements), what does Mongo do? Assume continues?\n    }\n    // If elements are equal so far, compare by length\n    return arr1.length < arr2.length ? -1 : arr1.length > arr2.length ? 1 : 0\n  }\n\n  // For non-comparable types of the same order (object), consider them equal in terms of *ordering*\n  // but deepCompare handles actual equality.\n  return 0\n}\n\n// --- End BSON Comparison Utility ---\n\n// Helper to check if two values are deeply equal (handles Dates)\n// TODO: Consider moving this to a shared utility module if used elsewhere\n// Should this also be exported if needed elsewhere? Or keep it local?\n// Keeping it local for now as only compareBSONValues uses it directly here.\n// Now exporting because compileQuery uses it directly.\nexport function deepCompare(val1: unknown, val2: unknown): boolean {\n  if (val1 === val2) {\n    return true\n  }\n\n  // Handle Date objects\n  if (val1 instanceof Date && val2 instanceof Date) {\n    return val1.getTime() === val2.getTime()\n  }\n\n  // Handle Arrays\n  if (Array.isArray(val1) && Array.isArray(val2)) {\n    if (val1.length !== val2.length) {\n      return false\n    }\n    for (let i = 0; i < val1.length; i++) {\n      // Recursively compare elements\n      if (!deepCompare(val1[i], val2[i])) {\n        return false\n      }\n    }\n    return true // Arrays are identical\n  }\n\n  // Handle simple Objects (optional, add if needed for query semantics)\n  // if (typeof val1 === 'object' && val1 !== null && typeof val2 === 'object' && val2 !== null && !Array.isArray(val1) && !Array.isArray(val2) && !(val1 instanceof Date) && !(val2 instanceof Date)) {\n  //     const keys1 = Object.keys(val1);\n  //     const keys2 = Object.keys(val2);\n  //     if (keys1.length !== keys2.length) {\n  //         return false;\n  //     }\n  //     for (const key of keys1) {\n  //         if (!Object.prototype.hasOwnProperty.call(val2, key) || !deepCompare((val1 as any)[key], (val2 as any)[key])) {\n  //             return false;\n  //         }\n  //     }\n  //     return true;\n  // }\n\n  // Add checks for other object types if needed (e.g., RegExp, ObjectId)\n  // ...\n\n  // For other types (including objects if not handled above), strict equality check (===) is usually sufficient\n  return false // Default for non-equal, non-Date, non-Array types\n}\n\n// $eq operator\nexport class EqOperator implements ComparisonOperator {\n  type = 'comparison' as const\n  private queryValue: QueryValue\n\n  constructor(value: QueryValue) {\n    // No specific validation needed for $eq value itself, it can be any type.\n    this.queryValue = value\n  }\n\n  evaluate(value: any, _context?: any): boolean {\n    // MongoDB's $eq behavior with undefined:\n    // - { field: { $eq: undefined } } matches documents where field is undefined or missing.\n    // - { field: { $eq: value } } (where value is not undefined) does NOT match documents where field is missing.\n    if (this.queryValue === undefined) {\n      // Matches if the field value is also undefined (or missing, which typeof checks as undefined)\n      return value === undefined\n    }\n    // If field value is undefined, but query value is not, no match.\n    if (value === undefined && this.queryValue !== undefined) {\n      return false\n    }\n    // Perform deep comparison for Dates, strict for others.\n    return deepCompare(value, this.queryValue)\n  }\n}\n\n// $ne operator\nexport class NeOperator implements ComparisonOperator {\n  type = 'comparison' as const\n  private queryValue: QueryValue\n\n  constructor(value: QueryValue) {\n    // No specific validation needed for $ne value itself.\n    this.queryValue = value\n  }\n\n  evaluate(value: any, _context?: any): boolean {\n    // $ne is essentially the negation of $eq, including handling of undefined/missing fields.\n    // If query value is undefined, $ne matches fields that exist and are not undefined.\n    if (this.queryValue === undefined) {\n      return value !== undefined\n    }\n    // If field value is undefined (missing), $ne always matches (as it's not equal to a defined query value).\n    if (value === undefined && this.queryValue !== undefined) {\n      return true\n    }\n    // Otherwise, return the negation of the deep comparison.\n    return !deepCompare(value, this.queryValue)\n  }\n}\n\n// $gt operator\nexport class GtOperator implements ComparisonOperator {\n  type = 'comparison' as const\n  private queryValue: QueryValue\n\n  constructor(value: QueryValue) {\n    // Basic validation: $gt usually requires a comparable value (string, number, Date).\n    // Null/undefined query values usually result in no matches.\n    // We don't throw an error here, but evaluate handles it.\n    this.queryValue = value\n  }\n\n  evaluate(value: any, _context?: any): boolean {\n    // Use BSON comparison: return true if value > queryValue\n    return compareBSONValues(value, this.queryValue) === 1\n  }\n}\n\n// $gte operator\nexport class GteOperator implements ComparisonOperator {\n  type = 'comparison' as const\n  private queryValue: QueryValue\n\n  constructor(value: QueryValue) {\n    this.queryValue = value\n  }\n\n  evaluate(value: any, _context?: any): boolean {\n    // Use BSON comparison: return true if value >= queryValue\n    const comparison = compareBSONValues(value, this.queryValue)\n    return comparison === 1 || comparison === 0\n  }\n}\n\n// $lt operator\nexport class LtOperator implements ComparisonOperator {\n  type = 'comparison' as const\n  private queryValue: QueryValue\n\n  constructor(value: QueryValue) {\n    this.queryValue = value\n  }\n\n  evaluate(value: any, _context?: any): boolean {\n    // Use BSON comparison: return true if value < queryValue\n    return compareBSONValues(value, this.queryValue) === -1\n  }\n}\n\n// $lte operator\nexport class LteOperator implements ComparisonOperator {\n  type = 'comparison' as const\n  private queryValue: QueryValue\n\n  constructor(value: QueryValue) {\n    this.queryValue = value\n  }\n\n  evaluate(value: any, _context?: any): boolean {\n    // Use BSON comparison: return true if value <= queryValue\n    const comparison = compareBSONValues(value, this.queryValue)\n    return comparison === -1 || comparison === 0\n  }\n}\n\n// $in operator\nexport class InOperator implements ComparisonOperator {\n  type = 'comparison' as const\n  // Store original values which might include RegExp\n  private queryValues: QueryValue[]\n\n  constructor(value: QueryValue) {\n    if (!Array.isArray(value)) {\n      throw new QueryOperatorError('$in requires an array', '$in', value)\n    }\n    // No deep validation of elements needed here, handled in evaluate\n    this.queryValues = value\n  }\n\n  evaluate(value: any, _context?: any): boolean {\n    // MongoDB $in matches if the field value equals any value in the query array.\n    // If the field value is an array, check both:\n    // 1. The array itself against query values\n    // 2. Each element in the array against query values\n    // Comparison uses BSON comparison order.\n    // Also supports regular expressions in the query array.\n\n    // Check if the value itself (including arrays) matches any query value\n    const directMatch = this.queryValues.some((item) => {\n      if (item instanceof RegExp) {\n        // If query item is RegExp, test the field value (must be string)\n        return typeof value === 'string' && item.test(value)\n      }\n      // Otherwise, use BSON comparison for equality check\n      return compareBSONValues(value, item) === 0\n    })\n\n    if (directMatch) {\n      return true\n    }\n\n    // If field value is an array, also check each element\n    if (Array.isArray(value)) {\n      return value.some((fieldItem) =>\n        this.queryValues.some((queryItem) => {\n          if (queryItem instanceof RegExp) {\n            return typeof fieldItem === 'string' && queryItem.test(fieldItem)\n          }\n          return compareBSONValues(fieldItem, queryItem) === 0\n        })\n      )\n    }\n\n    return false\n  }\n}\n\n// $nin operator\nexport class NinOperator implements ComparisonOperator {\n  type = 'comparison' as const\n  private queryValues: QueryValue[]\n\n  constructor(value: QueryValue) {\n    if (!Array.isArray(value)) {\n      throw new QueryOperatorError('$nin requires an array', '$nin', value)\n    }\n    this.queryValues = value\n  }\n\n  evaluate(value: any, _context?: any): boolean {\n    // $nin is the negation of $in.\n    // It matches if the field value is not BSON-equal to any value in the query array\n    // AND does not match any RegExp in the query array.\n\n    // Check if the value itself (including arrays) matches any query value\n    const directMatch = this.queryValues.some((item) => {\n      if (item instanceof RegExp) {\n        // If query item is RegExp, test the field value (must be string)\n        return typeof value === 'string' && item.test(value)\n      }\n      // Otherwise, use BSON comparison for equality check\n      return compareBSONValues(value, item) === 0\n    })\n\n    if (directMatch) {\n      return false\n    }\n\n    // If field value is an array, also check each element\n    if (Array.isArray(value)) {\n      const foundMatch = value.some((fieldItem) =>\n        this.queryValues.some((queryItem) => {\n          if (queryItem instanceof RegExp) {\n            return typeof fieldItem === 'string' && queryItem.test(fieldItem)\n          }\n          return compareBSONValues(fieldItem, queryItem) === 0\n        })\n      )\n      return !foundMatch\n    }\n\n    return true\n  }\n}\n\n// Export a map of comparison operators\nexport const comparisonOperators = {\n  $eq: EqOperator,\n  $ne: NeOperator,\n  $gt: GtOperator,\n  $gte: GteOperator,\n  $lt: LtOperator,\n  $lte: LteOperator,\n  $in: InOperator,\n  $nin: NinOperator,\n  // ... other operators\n} as const\n\n// Type guard for comparison operators (optional, but can be useful)\nexport function isComparisonOperator(value: any): value is ComparisonOperator {\n  return value && typeof value === 'object' && value.type === 'comparison'\n}\n",
    "import { ArrayOperator, QueryValue, QueryOperatorError } from './types'\nimport { compareBSONValues } from './comparison'\nimport type { UnaryCondition } from '../query/UnaryCondition'\n\n// $all operator\nexport class AllOperator implements ArrayOperator {\n  type = 'array' as const\n  private values: QueryValue[]\n\n  constructor(value: QueryValue) {\n    if (!Array.isArray(value)) {\n      throw new QueryOperatorError('$all requires an array', '$all', value)\n    }\n    this.values = value\n  }\n\n  evaluate(value: any): boolean {\n    if (!Array.isArray(value)) {\n      return (\n        this.values.length === 1 &&\n        compareBSONValues(value, this.values[0]) === 0\n      )\n    }\n\n    return this.values.every((queryItem) =>\n      value.some((fieldItem) => compareBSONValues(fieldItem, queryItem) === 0),\n    )\n  }\n}\n\n// $elemMatch operator\nexport class ElemMatchOperator implements ArrayOperator {\n  type = 'array' as const\n  private condition: UnaryCondition\n\n  constructor(condition: UnaryCondition) {\n    if (typeof condition !== 'function') {\n      throw new QueryOperatorError(\n        '$elemMatch requires a condition function',\n        '$elemMatch',\n        condition,\n      )\n    }\n    this.condition = condition\n  }\n\n  evaluate(value: any): boolean {\n    if (!Array.isArray(value)) {\n      return false\n    }\n    return value.some((item) => this.condition(item))\n  }\n}\n\n// $size operator\nexport class SizeOperator implements ArrayOperator {\n  type = 'array' as const\n  private expectedSize: number\n\n  constructor(value: QueryValue) {\n    if (typeof value !== 'number' || value < 0 || !Number.isInteger(value)) {\n      throw new QueryOperatorError(\n        '$size requires a non-negative integer',\n        '$size',\n        value,\n      )\n    }\n    this.expectedSize = value\n  }\n\n  evaluate(value: any): boolean {\n    if (!Array.isArray(value)) {\n      return false\n    }\n    return value.length === this.expectedSize\n  }\n}\n\n// Export a map of array operators\nexport const arrayOperators = {\n  $all: AllOperator,\n  $elemMatch: ElemMatchOperator,\n  $size: SizeOperator,\n} as const\n\n// Type guard for array operators\nexport function isArrayOperator(value: any): value is ArrayOperator {\n  return value && typeof value === 'object' && value.type === 'array'\n}\n",
    "import { EvaluationOperator, QueryValue, QueryOperatorError } from './types'\n\n// $mod operator - Updated for bigint support\nexport class ModOperator implements EvaluationOperator {\n  type = 'evaluation' as const\n  private divisor: number | bigint\n  private remainder: number | bigint\n\n  constructor(value: QueryValue) {\n    if (\n      !Array.isArray(value) ||\n      value.length !== 2 ||\n      (typeof value[0] !== 'number' && typeof value[0] !== 'bigint') ||\n      (typeof value[1] !== 'number' && typeof value[1] !== 'bigint')\n    ) {\n      throw new QueryOperatorError(\n        '$mod requires an array of two numbers or bigints [divisor, remainder]',\n        '$mod',\n        value,\n      )\n    }\n\n    const [divisor, remainder] = value\n\n    // Check if divisor is zero, handling both types\n    if (\n      (typeof divisor === 'number' && divisor === 0) ||\n      (typeof divisor === 'bigint' && divisor === BigInt(0))\n    ) {\n      throw new QueryOperatorError('$mod divisor cannot be zero', '$mod', value)\n    }\n\n    // Note: MongoDB might have specific truncation rules for non-integer remainders/values.\n    // This implementation uses standard JS modulo.\n    this.divisor = divisor\n    this.remainder = remainder\n  }\n\n  evaluate(value: any): boolean {\n    // Ensure the field value is a number or bigint\n    if (typeof value !== 'number' && typeof value !== 'bigint') {\n      return false\n    }\n\n    // Perform the modulo check, handling bigint\n    try {\n      if (\n        typeof value === 'bigint' ||\n        typeof this.divisor === 'bigint' ||\n        typeof this.remainder === 'bigint'\n      ) {\n        // Promote all to BigInt for the operation\n        const bigIntValue = BigInt(value)\n        const bigIntDivisor = BigInt(this.divisor)\n        const bigIntRemainder = BigInt(this.remainder)\n        // Divisor zero check already done in constructor\n        return bigIntValue % bigIntDivisor === bigIntRemainder\n      }\n      // Standard number modulo\n      return value % (this.divisor as number) === (this.remainder as number)\n    } catch (e) {\n      // Handle potential errors during BigInt conversion or modulo (though unlikely with checks)\n      return false\n    }\n  }\n}\n\n// $regex operator - Updated constructor and evaluate\nexport class RegexOperator implements EvaluationOperator {\n  type = 'evaluation' as const\n  private pattern: RegExp\n\n  constructor(value: QueryValue) {\n    let regexValue: string\n    let options: string | undefined = undefined\n\n    if (value instanceof RegExp) {\n      this.pattern = value\n      return\n    } else if (typeof value === 'string') {\n      regexValue = value\n    } else if (\n      typeof value === 'object' &&\n      value !== null &&\n      '$regex' in value\n    ) {\n      // Handle { $regex: string|RegExp, $options?: string }\n      const regexPart = (value as any).$regex\n\n      if (regexPart instanceof RegExp) {\n        // If $regex is a RegExp object, use it directly\n        this.pattern = regexPart\n        return\n      } else if (typeof regexPart === 'string') {\n        // If $regex is a string, create RegExp with options\n        regexValue = regexPart\n        options = (value as any).$options\n        if (options !== undefined && typeof options !== 'string') {\n          throw new QueryOperatorError(\n            '$regex operator $options must be a string',\n            '$regex',\n            value,\n          )\n        }\n      } else {\n        throw new QueryOperatorError(\n          '$regex value must be a string or RegExp',\n          '$regex',\n          value,\n        )\n      }\n    } else {\n      throw new QueryOperatorError(\n        '$regex requires a string, RegExp, or { $regex, $options } object',\n        '$regex',\n        value,\n      )\n    }\n\n    try {\n      this.pattern = new RegExp(regexValue, options)\n    } catch (e) {\n      const message = e instanceof Error ? e.message : String(e)\n      throw new QueryOperatorError(\n        `Invalid regular expression or options: ${message}`,\n        '$regex',\n        value,\n      )\n    }\n  }\n\n  evaluate(value: any): boolean {\n    // MongoDB $regex only applies to string values.\n    if (typeof value !== 'string') {\n      return false\n    }\n    // Test the string value against the pattern.\n    return this.pattern.test(value)\n  }\n}\n\n// $where operator - Updated evaluate to use context\nexport class WhereOperator implements EvaluationOperator {\n  type = 'evaluation' as const\n  private fn: (this: any, obj: any) => boolean\n\n  constructor(value: QueryValue) {\n    if (typeof value === 'function') {\n      this.fn = value as (this: any, obj: any) => boolean\n    } else if (typeof value === 'string') {\n      console.warn(\n        'Using string-based $where is a potential security risk and may impact performance. Ensure the code is trusted.',\n      )\n      try {\n        // Create function expecting the document ('obj') as argument and this context\n        this.fn = new Function('obj', `return (${value})`) as (\n          this: any,\n          obj: any,\n        ) => boolean\n      } catch (e) {\n        const message = e instanceof Error ? e.message : String(e)\n        throw new QueryOperatorError(\n          `Invalid $where JavaScript expression: ${message}`,\n          '$where',\n          value,\n        )\n      }\n    } else {\n      throw new QueryOperatorError(\n        '$where requires a string expression or a function',\n        '$where',\n        value,\n      )\n    }\n  }\n\n  evaluate(_value: any, context?: any): boolean {\n    // $where operates on the document (context), not the field value (_value)\n    if (typeof context !== 'object' || context === null) {\n      return false // Needs document context\n    }\n    try {\n      // Call with document as 'this' and as the first argument ('obj')\n      return Boolean(this.fn.call(context, context))\n    } catch (e) {\n      console.error(\n        `Error executing $where function: ${e instanceof Error ? e.message : String(e)}`,\n        context,\n      )\n      return false // Errors result in non-match\n    }\n  }\n}\n\n// Export a map of evaluation operators\nexport const evaluationOperators = {\n  $mod: ModOperator,\n  $regex: RegexOperator,\n  $where: WhereOperator,\n} as const\n\n// Type guard for evaluation operators\nexport function isEvaluationOperator(value: any): value is EvaluationOperator {\n  return value && typeof value === 'object' && value.type === 'evaluation'\n}\n",
    "import { BitwiseOperator, QueryValue, QueryOperatorError } from './types'\n\n// ÐÑÐ¿Ð¾Ð¼Ð¾Ð³Ð°ÑÐµÐ»ÑÐ½Ð°Ñ ÑÑÐ½ÐºÑÐ¸Ñ Ð´Ð»Ñ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸ Ð±Ð¸ÑÐ¾Ð²Ð¾Ð¹ Ð¼Ð°ÑÐºÐ¸\nfunction validateBitMask(value: QueryValue): number {\n  if (typeof value === 'number') {\n    // Check if it's a number first\n    const numValue = value as number // Assert type after check\n    if (!Number.isInteger(numValue)) {\n      throw new QueryOperatorError(\n        'Bitmask must be an integer',\n        'bitwise',\n        value,\n      )\n    }\n    // Now we know value is an integer number\n    if (numValue < 0) {\n      throw new QueryOperatorError(\n        'Bitmask must be a non-negative integer',\n        'bitwise',\n        value,\n      )\n    }\n    return numValue\n  }\n  if (Array.isArray(value)) {\n    // Check for array second\n    if (\n      value.every(\n        (bit) => typeof bit === 'number' && Number.isInteger(bit) && bit >= 0,\n      )\n    ) {\n      // Assert type after validation\n      const numericArray = value as number[]\n      return numericArray.reduce(\n        (mask: number, bit: number) => mask | (1 << bit),\n        0,\n      )\n    } else {\n      // Throw error if array contains invalid elements\n      throw new QueryOperatorError(\n        'Bit position array must contain only non-negative integers',\n        'bitwise',\n        value,\n      )\n    }\n  }\n  // If not a valid number or valid array, throw error\n  throw new QueryOperatorError(\n    'Invalid bit mask or positions: Must be a non-negative integer or array of non-negative integers',\n    'bitwise',\n    value,\n  )\n}\n\n// $bitsAllSet operator\nexport class BitsAllSetOperator implements BitwiseOperator {\n  type = 'bitwise' as const\n  private bitmask: number\n\n  constructor(value: QueryValue) {\n    this.bitmask = validateBitMask(value)\n  }\n\n  evaluate(value: any): boolean {\n    if (typeof value !== 'number' || !Number.isInteger(value)) {\n      return false\n    }\n    return (value & this.bitmask) === this.bitmask\n  }\n}\n\n// $bitsAnySet operator\nexport class BitsAnySetOperator implements BitwiseOperator {\n  type = 'bitwise' as const\n  private bitmask: number\n\n  constructor(value: QueryValue) {\n    this.bitmask = validateBitMask(value)\n  }\n\n  evaluate(value: any): boolean {\n    if (typeof value !== 'number' || !Number.isInteger(value)) {\n      return false\n    }\n    return (value & this.bitmask) !== 0\n  }\n}\n\n// $bitsAllClear operator\nexport class BitsAllClearOperator implements BitwiseOperator {\n  type = 'bitwise' as const\n  private bitmask: number\n\n  constructor(value: QueryValue) {\n    this.bitmask = validateBitMask(value)\n  }\n\n  evaluate(value: any): boolean {\n    if (typeof value !== 'number' || !Number.isInteger(value)) {\n      return false\n    }\n    return (value & this.bitmask) === 0\n  }\n}\n\n// $bitsAnyClear operator\nexport class BitsAnyClearOperator implements BitwiseOperator {\n  type = 'bitwise' as const\n  private bitmask: number\n\n  constructor(value: QueryValue) {\n    this.bitmask = validateBitMask(value)\n  }\n\n  evaluate(value: any): boolean {\n    if (typeof value !== 'number' || !Number.isInteger(value)) {\n      return false\n    }\n    return (value & this.bitmask) !== this.bitmask\n  }\n}\n\n// Export a map of bitwise operators\nexport const bitwiseOperators = {\n  $bitsAllSet: BitsAllSetOperator,\n  $bitsAnySet: BitsAnySetOperator,\n  $bitsAllClear: BitsAllClearOperator,\n  $bitsAnyClear: BitsAnyClearOperator,\n} as const\n\n// Type guard for bitwise operators\nexport function isBitwiseOperator(value: any): value is BitwiseOperator {\n  return value && typeof value === 'object' && value.type === 'bitwise'\n}\n",
    "import {\n  TextSearchOperatorType as TextSearchOperator,\n  QueryValue,\n  QueryOperatorError,\n} from './types'\n\ninterface TextSearchOptions {\n  $search: string\n  $language?: string\n  $caseSensitive?: boolean\n  $diacriticSensitive?: boolean\n  $score?: boolean\n}\n\n// $text operator\nexport class TextSearchOperatorImpl implements TextSearchOperator {\n  type = 'text' as const\n  private searchTerms: string[]\n  private caseSensitive: boolean\n  private diacriticSensitive: boolean\n\n  constructor(value: QueryValue) {\n    // ÐÑÐ¾Ð²ÐµÑÑÐµÐ¼ Ð¸ Ð¸Ð·Ð²Ð»ÐµÐºÐ°ÐµÐ¼ Ð¾Ð¿ÑÐ¸Ð¸\n    if (!value || typeof value !== 'object') {\n      throw new QueryOperatorError(\n        '$text requires an object with $search',\n        '$text',\n        value,\n      )\n    }\n\n    const options = value as unknown as TextSearchOptions\n    if (typeof options.$search !== 'string') {\n      throw new QueryOperatorError(\n        '$text.$search must be a string',\n        '$text',\n        value,\n      )\n    }\n\n    // Ð Ð°Ð·Ð±Ð¸Ð²Ð°ÐµÐ¼ ÑÑÑÐ¾ÐºÑ Ð¿Ð¾Ð¸ÑÐºÐ° Ð½Ð° ÑÐµÑÐ¼Ð¸Ð½Ñ, Ð¸Ð³Ð½Ð¾ÑÐ¸ÑÑÑ Ð¿ÑÑÑÑÐµ ÑÑÑÐ¾ÐºÐ¸\n    this.searchTerms = options.$search\n      .split(/\\s+/)\n      .filter((term) => term.length > 0)\n      .map((term) => term.trim())\n\n    if (this.searchTerms.length === 0) {\n      throw new QueryOperatorError(\n        '$text.$search cannot be empty',\n        '$text',\n        value,\n      )\n    }\n\n    // Ð£ÑÑÐ°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ð¾Ð¿ÑÐ¸Ð¸ Ñ Ð·Ð½Ð°ÑÐµÐ½Ð¸ÑÐ¼Ð¸ Ð¿Ð¾ ÑÐ¼Ð¾Ð»ÑÐ°Ð½Ð¸Ñ\n    this.caseSensitive = options.$caseSensitive === true\n    this.diacriticSensitive = options.$diacriticSensitive === true\n  }\n\n  evaluate(value: any): boolean {\n    // ÐÑÐ»Ð¸ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ Ð½Ðµ ÑÑÑÐ¾ÐºÐ° Ð¸Ð»Ð¸ undefined/null, Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼ false\n    if (typeof value !== 'string') {\n      return false\n    }\n\n    // ÐÐ¾Ð´Ð³Ð¾ÑÐ°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ ÑÐµÐºÑÑ Ð´Ð»Ñ Ð¿Ð¾Ð¸ÑÐºÐ°\n    let searchText = value\n    let terms = this.searchTerms\n\n    if (!this.caseSensitive) {\n      searchText = searchText.toLowerCase()\n      terms = terms.map((term) => term.toLowerCase())\n    }\n\n    if (!this.diacriticSensitive) {\n      searchText = this.removeDiacritics(searchText)\n      terms = terms.map((term) => this.removeDiacritics(term))\n    }\n\n    // ÐÑÐ¾Ð²ÐµÑÑÐµÐ¼ Ð½Ð°Ð»Ð¸ÑÐ¸Ðµ Ð²ÑÐµÑ ÑÐµÑÐ¼Ð¸Ð½Ð¾Ð² Ð² ÑÐµÐºÑÑÐµ\n    return terms.every((term) => searchText.includes(term))\n  }\n\n  // ÐÑÐ¿Ð¾Ð¼Ð¾Ð³Ð°ÑÐµÐ»ÑÐ½ÑÐ¹ Ð¼ÐµÑÐ¾Ð´ Ð´Ð»Ñ ÑÐ´Ð°Ð»ÐµÐ½Ð¸Ñ Ð´Ð¸Ð°ÐºÑÐ¸ÑÐ¸ÑÐµÑÐºÐ¸Ñ Ð·Ð½Ð°ÐºÐ¾Ð²\n  private removeDiacritics(text: string): string {\n    return text.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '')\n  }\n}\n\n// Export a map of text search operators\nexport const textSearchOperators = {\n  $text: TextSearchOperatorImpl,\n} as const\n\n// Type guard for text search operators\nexport function isTextSearchOperator(value: any): value is TextSearchOperator {\n  return value && typeof value === 'object' && value.type === 'text'\n}\n",
    "import { type ValueType } from './ValueType'\n\n// Basic comparison operators\nexport type $eq = { $eq: ValueType }\nexport type $gt = { $gt: ValueType }\nexport type $gte = { $gte: ValueType }\nexport type $lt = { $lt: ValueType }\nexport type $lte = { $lte: ValueType }\nexport type $ne = { $ne: ValueType }\nexport type $in = { $in: Array<ValueType> }\nexport type $nin = { $nin: Array<ValueType> }\n\n// Logical operators\nexport type $and = { $and: Array<QueryType> }\nexport type $or = { $or: Array<QueryType> }\nexport type $not = { $not: QueryType }\nexport type $nor = { $nor: Array<QueryType> }\n\n// Array operators\nexport type $all = { $all: Array<ValueType> }\nexport type $elemMatch = { $elemMatch: QueryType }\nexport type $size = { $size: number }\n\n// Element operators\nexport type $exists = { $exists: boolean }\nexport type $type = { $type: string | number | Array<string | number> }\n\n// Evaluation operators\nexport type $mod = { $mod: [number, number] }\nexport type $regex = {\n  $regex: RegExp | string | { $regex: string; $options?: string }\n}\nexport type $where = {\n  $where: string | ((this: any, obj: any) => boolean)\n}\n\n// Text search\nexport type $text = {\n  $text: {\n    $search: string\n    $language?: string\n    $caseSensitive?: boolean\n    $diacriticSensitive?: boolean\n  }\n}\n\n// Bitwise operators\nexport type BitwiseArgument = number | Array<number>\nexport type $bitsAllSet = { $bitsAllSet: BitwiseArgument }\nexport type $bitsAnySet = { $bitsAnySet: BitwiseArgument }\nexport type $bitsAllClear = { $bitsAllClear: BitwiseArgument }\nexport type $bitsAnyClear = { $bitsAnyClear: BitwiseArgument }\n\n// Union types for operators\nexport type ComparisonOperators = $eq | $gt | $gte | $lt | $lte | $ne | $in | $nin\nexport type LogicalOperators = $and | $or | $not | $nor\nexport type ArrayOperators = $all | $elemMatch | $size\nexport type ElementOperators = $exists | $type\nexport type EvaluationOperators = $mod | $regex | $where | $text\nexport type BitwiseOperators = $bitsAllSet | $bitsAnySet | $bitsAllClear | $bitsAnyClear\n\nexport type Operators =\n  | ComparisonOperators\n  | LogicalOperators\n  | ArrayOperators\n  | ElementOperators\n  | EvaluationOperators\n  | BitwiseOperators\n\n// Main QueryType - Ð±Ð¾Ð»ÐµÐµ Ð³Ð¸Ð±ÐºÐ¸Ð¹ ÑÐ¸Ð¿ Ð´Ð»Ñ ÑÐ¾Ð²Ð¼ÐµÑÑÐ¸Ð¼Ð¾ÑÑÐ¸\nexport type QueryType = {\n  [key: string]: any\n} | Operators\n\n// Helper functions\nexport function isSingleField(inp: unknown): inp is Record<string, unknown> {\n  return (\n    typeof inp === 'object' &&\n    inp !== null &&\n    !Array.isArray(inp) &&\n    Object.keys(inp).length === 1\n  )\n}\n\nexport function isNotSingleField(inp: unknown): inp is Record<string, unknown> {\n  return (\n    typeof inp === 'object' &&\n    inp !== null &&\n    !Array.isArray(inp) &&\n    Object.keys(inp).length > 1\n  )\n}\n\nexport function prepareQueryToRun(inp: unknown): unknown {\n  return inp\n}\n\nexport function isQueryType(input: unknown): input is QueryType {\n  return typeof input === 'object' && input !== null\n}",
    "import {\n  QueryValue,\n  createOperator,\n  OperatorType,\n  isOperator,\n  QueryOperatorError,\n  ElemMatchOperator,\n} from '.' // Import necessary items from index.ts\nimport {\n  type QueryType,\n  isNotSingleField,\n  isSingleField,\n} from './QueryType'\nimport type { UnaryCondition } from './UnaryCondition'\nimport type { ValueType } from './ValueType' // Keep ValueType for build_query_new signature\nimport { compareBSONValues } from './comparison' // Import comparison utility for base case\n\n// Renamed from buildIt\nexport function buildIt_new(\n  obj: unknown,\n  options?: { [op: string]: (...args: Array<any>) => UnaryCondition },\n): UnaryCondition {\n  // Handle RegExp objects (implicit $regex match)\n  if (obj instanceof RegExp) {\n    try {\n      const op = createOperator('$regex', obj as QueryValue)\n      return (fieldValue: any) => {\n        // MongoDB behavior: if field value is an array, apply regex to each element\n        if (Array.isArray(fieldValue)) {\n          return fieldValue.some(item => op.evaluate(item))\n        }\n        return op.evaluate(fieldValue)\n      }\n    } catch (e) {\n      if (e instanceof QueryOperatorError) throw e\n      throw new Error(\n        `Error creating RegExp operator: ${e instanceof Error ? e.message : String(e)}`,\n      )\n    }\n  }\n\n  // Handle non-objects (primitive values, arrays) - simulate $eq\n  if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {\n    // Use BSON comparison for equality check\n    return (input: any) => compareBSONValues(input, obj) === 0\n  }\n\n  // --- FIXED CHECK FOR $regex OBJECT --- START\n  if (typeof obj === 'object' && obj !== null && '$regex' in obj) {\n    // Check if it is an object and has $regex key\n    const keys = Object.keys(obj)\n    const hasOnlyRegexAndOptions = keys.every(\n      (k) => k === '$regex' || k === '$options',\n    )\n\n    if (hasOnlyRegexAndOptions && keys.length >= 1 && keys.length <= 2) {\n      // It looks like a valid { $regex: string, $options?: string } object.\n      // Create the regex operator directly with the whole object\n      try {\n        const op = createOperator('$regex', obj as QueryValue)\n        return (fieldValue: any) => {\n          // MongoDB behavior: if field value is an array, apply regex to each element\n          if (Array.isArray(fieldValue)) {\n            return fieldValue.some(item => op.evaluate(item))\n          }\n          return op.evaluate(fieldValue)\n        }\n      } catch (e) {\n        if (e instanceof QueryOperatorError) throw e\n        throw new Error(\n          `Error creating $regex operator: ${e instanceof Error ? e.message : String(e)}`,\n        )\n      }\n    } else {\n      // It has $regex but also other unexpected keys.\n      throw new Error(\n        `Invalid object structure containing $regex mixed with other keys: ${JSON.stringify(obj)}`,\n      )\n    }\n  }\n  // --- FIXED CHECK FOR $regex OBJECT --- END\n\n  // Handle objects with multiple fields - simulate $and\n  if (isNotSingleField(obj)) {\n    const keys = Object.keys(obj)\n    const conditions = keys.map((prop) => {\n      // Cast obj to Record after type check\n      return make_call_new(obj as Record<string, unknown>, prop, options)\n    })\n    // Return a function that checks if all conditions are met\n    return (input: any) => conditions.every((cond) => cond(input))\n  }\n  // Handle objects with a single field (operator or field name)\n  else if (isSingleField(obj)) {\n    const prop = Object.keys(obj)[0]\n    // Cast obj to Record after type check\n    const call = make_call_new(obj as Record<string, unknown>, prop, options)\n    return (input: any) => call(input)\n  }\n  // This case should theoretically not be reached due to the initial check\n  // but provides a fallback similar to the original $eq(obj)\n  else {\n    // Use BSON comparison for equality check\n    return (input: any) => compareBSONValues(input, obj) === 0\n  }\n}\n\n// Renamed from make_call\nfunction make_call_new(\n  obj: Record<string, unknown>, // Expect Record now\n  prop: string,\n  options?: { [op: string]: (...args: Array<any>) => UnaryCondition },\n): UnaryCondition {\n  // Return type is UnaryCondition\n  // Handle custom options first\n  if (options?.[prop]) {\n    // Assume option returns a UnaryCondition\n    return options[prop](obj[prop])\n  }\n\n  // Explicitly handle logical operators as they combine recursive calls\n  switch (prop) {\n    case '$and': {\n      if (!Array.isArray(obj.$and)) {\n        throw new QueryOperatorError('$and requires an array', '$and', obj.$and)\n      }\n      const conditions = (obj.$and as Array<unknown>).map((q) =>\n        buildIt_new(q, options),\n      )\n      return (input: any) => conditions.every((cond) => cond(input))\n    }\n    case '$or': {\n      if (!Array.isArray(obj.$or)) {\n        throw new QueryOperatorError('$or requires an array', '$or', obj.$or)\n      }\n      const conditions = (obj.$or as Array<unknown>).map((q) =>\n        buildIt_new(q, options),\n      )\n      return (input: any) => conditions.some((cond) => cond(input))\n    }\n    case '$not': {\n      // $not takes a query object, not just a value\n      const condition = buildIt_new(obj.$not, options)\n      return (input: any) => !condition(input)\n    }\n    case '$nor': {\n      if (!Array.isArray(obj.$nor)) {\n        throw new QueryOperatorError('$nor requires an array', '$nor', obj.$nor)\n      }\n      const conditions = (obj.$nor as Array<unknown>).map((q) =>\n        buildIt_new(q, options),\n      )\n      // NOR is true if *none* of the conditions are true (!some)\n      return (input: any) => !conditions.some((cond) => cond(input))\n    }\n    // Handle $where separately as it uses context\n    case '$where': {\n      try {\n        // Assert the type for obj.$where\n        const op = createOperator('$where', obj.$where as QueryValue)\n        // Return a function that expects the document and passes it as context\n        return (doc: any) => op.evaluate(undefined, doc)\n      } catch (e) {\n        // Propagate QueryOperatorError or re-throw others\n        if (e instanceof QueryOperatorError) throw e\n        throw new Error(\n          `Error creating $where operator: ${e instanceof Error ? e.message : String(e)}`,\n        )\n      }\n    }\n    // Special handling for $elemMatch\n    case '$elemMatch': {\n      if (\n        typeof obj.$elemMatch !== 'object' ||\n        obj.$elemMatch === null ||\n        Array.isArray(obj.$elemMatch)\n      ) {\n        throw new QueryOperatorError(\n          '$elemMatch requires a query object value',\n          '$elemMatch',\n          obj.$elemMatch,\n        )\n      }\n      // Recursively build the condition for the elements *first*\n      const elementCondition = buildIt_new(obj.$elemMatch, options)\n      // Now create the ElemMatchOperator with the compiled element condition\n      const op = new ElemMatchOperator(elementCondition)\n      return (fieldValue: any) => op.evaluate(fieldValue)\n    }\n  }\n\n  // Handle other known operators ($eq, $gt, $regex, etc.)\n  if (isOperator(prop)) {\n    try {\n      // Assert the type for obj[prop]\n      const op = createOperator(prop as OperatorType, obj[prop] as QueryValue)\n      // Most operators evaluate based on the value passed to them.\n      // This assumes the UnaryCondition receives the field value.\n      return (fieldValue: any) => {\n        // MongoDB behavior: if field value is an array, apply operator to each element\n        // Exception: operators that are specifically designed for arrays or need to check the array itself\n        if (Array.isArray(fieldValue) && !['$all', '$size', '$elemMatch', '$type', '$exists', '$nin', '$in'].includes(prop)) {\n          return fieldValue.some(item => op.evaluate(item))\n        }\n        return op.evaluate(fieldValue)\n      }\n    } catch (e) {\n      // Propagate QueryOperatorError or re-throw others\n      if (e instanceof QueryOperatorError) throw e\n      throw new Error(\n        `Error creating ${prop} operator: ${e instanceof Error ? e.message : String(e)}`,\n      )\n    }\n  }\n\n  // Default case: Treat 'prop' as a field name\n  // Compile the condition associated with the field name\n  const compiledCondition = buildIt_new(obj[prop], options)\n  // Return a function that applies the compiled condition to the field's value in the input document\n  return (doc: any) => {\n    // Check if doc is an object and has the property before accessing\n    // Nested field access using dot notation\n    const parts = prop.split('.')\n    let fieldValue: any = doc\n    for (const part of parts) {\n      if (\n        typeof fieldValue !== 'object' ||\n        fieldValue === null ||\n        !(part in fieldValue)\n      ) {\n        fieldValue = undefined\n        break\n      }\n      fieldValue = fieldValue[part]\n    }\n    return compiledCondition(fieldValue)\n  }\n}\n\n// Renamed from build_query\nexport function build_query_new(\n  input: QueryType | ValueType | unknown,\n  options?: { [op: string]: (...args: Array<any>) => UnaryCondition },\n): UnaryCondition {\n  try {\n    const result = buildIt_new(input, options)\n    return result\n  } catch (e) {\n    // Catch errors during building (e.g., invalid operator structure)\n    const message = e instanceof Error ? e.message : String(e)\n    // Provide more context in the error message\n    let inputString = ''\n    try {\n      inputString = JSON.stringify(input, null, 2) // Pretty print input\n    } catch {\n      inputString = String(input) // Fallback if stringify fails\n    }\n    throw new Error(\n      `Invalid query object or definition: ${message}. Input: ${inputString}`,\n    )\n  }\n}\n",
    "/**\n * Determines the JavaScript type of a value for query purposes.\n * @param value - The value to check.\n * @returns A string representing the type (e.g., 'null', 'undefined', 'boolean', 'number', 'string', 'date', 'regexp', 'array', 'buffer', 'object') or null if unknown.\n */\nexport function getJsType(value: unknown): string | null {\n  if (value === null) return 'null'\n  if (value === undefined) return 'undefined'\n\n  const jsType = typeof value\n\n  if (jsType === 'string') return 'string'\n  if (jsType === 'boolean') return 'boolean'\n  if (jsType === 'number') return 'number'\n\n  // Specific object types\n  if (value instanceof Date) return 'date'\n  if (value instanceof RegExp) return 'regexp'\n\n  // Buffer check (important for Node.js environments)\n  if (typeof Buffer !== 'undefined' && value instanceof Buffer) return 'buffer'\n\n  if (Array.isArray(value)) return 'array'\n\n  // Default for other objects\n  if (jsType === 'object') return 'object'\n\n  // BigInt and Symbol could be added if needed\n  // if (jsType === 'bigint') return 'bigint';\n  // if (jsType === 'symbol') return 'symbol';\n\n  return null // Unknown type\n}\n\n// BSON_TYPE_ALIASES is removed.\n",
    "import { getJsType } from './js_types' // Will be created/renamed soon\n\n// Simple JS type ordering (example)\nconst JS_TYPE_ORDER = {\n  null: 0,\n  undefined: 1, // Often considered distinct from null\n  boolean: 2,\n  number: 3,\n  string: 4,\n  date: 5, // Treat Date separately\n  regexp: 6, // Treat RegExp separately\n  array: 7,\n  object: 8, // Includes generic objects, Buffer, etc.\n  // Note: No specific BSON types like ObjectId, Long, etc.\n}\n\n/**\n * Determines the order rank of a JavaScript value based on its type.\n * Uses the JS_TYPE_ORDER map.\n * @param value - The value to determine the type order for.\n * @returns The numeric rank based on type, or a high number for unknown types.\n */\nfunction getJsTypeOrder(value: unknown): number {\n  const type = getJsType(value) // Uses the refactored type checker\n  return type\n    ? (JS_TYPE_ORDER[type as keyof typeof JS_TYPE_ORDER] ?? Infinity)\n    : Infinity\n}\n\n/**\n * Compares two JavaScript values based primarily on type order, then value.\n * Returns:\n * - -1 if v1 < v2\n * - 0 if v1 === v2 (using deepCompare for objects/arrays)\n * - 1 if v1 > v2\n * - null if comparison is ambiguous or types are incompatible for value comparison.\n * @param v1 - First value.\n * @param v2 - Second value.\n */\nexport function compareValues(v1: unknown, v2: unknown): number | null {\n  // --- ADDED: Explicit check for undefined ---\n  // If either argument is undefined, they are incomparable for <, <=, >, >=\n  if (v1 === undefined || v2 === undefined) {\n    // Exception: if both are undefined, they are equal (0) handled by deepCompare later\n    // Return null to indicate incomparability for ordering\n    return null\n  }\n  // --- END ADDITION ---\n\n  if (deepCompare(v1, v2)) {\n    return 0 // Handles deep equality for objects, arrays, primitives\n  }\n\n  const typeOrder1 = getJsTypeOrder(v1)\n  const typeOrder2 = getJsTypeOrder(v2)\n\n  // If types are different, use type order\n  if (typeOrder1 !== typeOrder2) {\n    return typeOrder1 < typeOrder2 ? -1 : 1\n  }\n\n  // --- Same Type Comparison ---\n  // Types are the same according to getJsTypeOrder, but deepCompare returned false.\n  // Perform type-specific value comparison if applicable.\n\n  // Use direct type checks for primitives where typeof works reliably\n  if (typeof v1 === 'number' && typeof v2 === 'number') {\n    return v1 < v2 ? -1 : 1\n  }\n\n  if (typeof v1 === 'string' && typeof v2 === 'string') {\n    return v1 < v2 ? -1 : 1\n  }\n\n  if (typeof v1 === 'boolean' && typeof v2 === 'boolean') {\n    // Standard boolean comparison: false < true\n    return v1 === false && v2 === true ? -1 : 1\n  }\n\n  if (v1 instanceof Date && v2 instanceof Date) {\n    const time1 = v1.getTime()\n    const time2 = v2.getTime()\n    return time1 < time2 ? -1 : 1\n  }\n\n  // For types like array, object, null, undefined, regex where value comparison\n  // beyond equality doesn't make sense or is ambiguous in this context,\n  // return null if deepCompare was false but type order is the same.\n  // Exception: Arrays of same length containing comparable primitives?\n  // For simplicity, if types match but deepCompare is false, consider them incomparable for >, <.\n  if (typeOrder1 === JS_TYPE_ORDER.array) {\n    // Optional: Add element-wise comparison for primitive arrays if needed.\n    // Currently returns null as they are not deepEqual.\n    return null\n  }\n\n  // Objects, null, undefined, regex are considered equal only if deepCompare is true.\n  // If deepCompare is false, they are incomparable for sorting/ordering.\n  return null\n}\n\n// --- Deep Comparison Utility --- (Keep existing deepCompare)\n\n/**\n * Performs a deep comparison between two values.\n * Handles primitives, Dates, Arrays, and plain Objects.\n * Does not handle circular references.\n * @param v1 - First value.\n * @param v2 - Second value.\n * @returns True if the values are deeply equal, false otherwise.\n */\nexport function deepCompare(v1: unknown, v2: unknown): boolean {\n  if (v1 === v2) {\n    return true // Handles primitives (string, number, boolean, null, undefined, symbol, bigint)\n  }\n\n  // Handle Date objects\n  if (v1 instanceof Date && v2 instanceof Date) {\n    return v1.getTime() === v2.getTime()\n  }\n\n  // Handle Arrays\n  if (Array.isArray(v1) && Array.isArray(v2)) {\n    if (v1.length !== v2.length) {\n      return false\n    }\n    for (let i = 0; i < v1.length; i++) {\n      if (!deepCompare(v1[i], v2[i])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  // Handle Objects (plain objects)\n  if (\n    typeof v1 === 'object' &&\n    v1 !== null &&\n    typeof v2 === 'object' &&\n    v2 !== null &&\n    !(v1 instanceof Date) && // Ensure they are not Dates (already handled)\n    !(v2 instanceof Date) &&\n    !Array.isArray(v1) && // Ensure they are not Arrays (already handled)\n    !Array.isArray(v2) &&\n    !(v1 instanceof RegExp) && // Don't deep compare RegExps by properties\n    !(v2 instanceof RegExp) &&\n    !(typeof Buffer !== 'undefined' && v1 instanceof Buffer) && // Treat Buffers as opaque objects for comparison by reference unless identical\n    !(typeof Buffer !== 'undefined' && v2 instanceof Buffer)\n  ) {\n    const keys1 = Object.keys(v1 as object)\n    const keys2 = Object.keys(v2 as object)\n\n    if (keys1.length !== keys2.length) {\n      return false\n    }\n\n    for (const key of keys1) {\n      // Use Object.prototype.hasOwnProperty.call for safer key checking\n      if (\n        !Object.prototype.hasOwnProperty.call(v2, key) ||\n        !deepCompare((v1 as any)[key], (v2 as any)[key])\n      ) {\n        return false\n      }\n    }\n    return true\n  }\n\n  // Handle RegExp comparison (compare source and flags)\n  if (v1 instanceof RegExp && v2 instanceof RegExp) {\n    return v1.source === v2.source && v1.flags === v2.flags\n  }\n\n  // If none of the above, they are not deeply equal\n  return false\n}\n",
    "import { getJsType } from './js_types' // UPDATED Import\nimport { compareValues, deepCompare } from './compare_utils' // ÐÐ°Ð¼ Ð¿Ð¾Ð½Ð°Ð´Ð¾Ð±Ð¸ÑÑÑ ÑÑÐ°Ð²Ð½ÐµÐ½Ð¸Ðµ // UPDATED Import\nimport { OperatorType, isOperator, QueryOperatorError, WhereOperator } from '.' // ÐÐ¿ÐµÑÐ°ÑÐ¾ÑÑ // IMPORT WhereOperator\n\n// Helper function to check for logical operators that are top-level keys\nfunction isLogicalOperator(\n  key: string,\n): key is '$and' | '$or' | '$not' | '$nor' {\n  return key === '$and' || key === '$or' || key === '$not' || key === '$nor'\n}\n\n// Interface for the compilation context\ninterface CompilationContext {\n  values: unknown[] // To store literal values from the query\n  options?: { [op: string]: (...args: Array<any>) => string }\n  regexCache: { [cacheKey: string]: string } // Map cacheKey to varName\n  regexToCreate: Array<{\n    varName: string\n    patternIndex: string\n    flagsIndex: string\n  }>\n  whereOperators: WhereOperator[] // ADDED: Store WhereOperator instances\n  getNextValueIndex: () => number\n  getRegexVar: (pattern: string, flags: string) => string\n}\n\n// ÐÐ½ÑÐµÑÑÐµÐ¹Ñ Ð´Ð»Ñ ÑÐµÐ·ÑÐ»ÑÑÐ°ÑÐ° ÐºÐ¾Ð¼Ð¿Ð¸Ð»ÑÑÐ¸Ð¸\ninterface CompiledQuery {\n  /**\n   * The generated JavaScript code string.\n   * Expects 'doc' as the input document variable.\n   */\n  code: string\n  /**\n   * The compiled function.\n   */\n  func: (doc: any) => boolean\n  /**\n   * Any errors encountered during compilation.\n   */\n  error?: string\n  errorDetails?: unknown // Keep original error details if needed\n}\n\n/**\n * Compiles a query object into a JavaScript function string and a callable function.\n *\n * @param query - The MongoDB-like query object.\n * @param options - Optional custom operators (not implemented yet).\n * @returns A CompiledQuery object.\n */\nexport function compileQuery(\n  query: unknown,\n  options?: { [op: string]: (...args: Array<any>) => string }, // Options might return code snippets\n): CompiledQuery {\n  const context: CompilationContext = {\n    values: [],\n    options,\n    regexCache: {},\n    regexToCreate: [], // Store info needed to create regex instances\n    whereOperators: [], // ADDED: Initialize whereOperators array\n    getNextValueIndex: () => context.values.length,\n    getRegexVar: (pattern: string, flags: string) => {\n      const cacheKey = `${pattern}\\0${flags}` // Use null char as separator\n      if (context.regexCache[cacheKey]) {\n        return context.regexCache[cacheKey]\n      }\n      const varName = `_regex${context.regexToCreate.length}`\n      const patternIndex = addValueAndGetCode(pattern, context, true) // Store pattern string\n      const flagsIndex = addValueAndGetCode(flags, context, true) // Store flags string\n      context.regexToCreate.push({ varName, patternIndex, flagsIndex })\n      context.regexCache[cacheKey] = varName\n      return varName\n    },\n  }\n\n  try {\n    // 1. Build the main logic string, it will reference variables like _regex0, _values[1], deepCompare etc.\n    const mainCodeString = buildCodeRecursive(query, 'doc', context)\n\n    // 2. Prepare necessary values/helpers for the runtime function's scope\n    const queryValues = [...context.values] // Clone to be safe? Or just use context.values\n    const whereOperators = context.whereOperators\n    const externalHelpers = {\n      compareValues, // UPDATED helper name\n      deepCompare,\n      _getJsTypeHelper: getJsType, // UPDATED helper name\n    }\n    const helperNames = Object.keys(externalHelpers)\n    // const regexVarNames = context.regexToCreate.map(r => r.varName);\n\n    // 3. Create RegExp instances *before* defining the runtime function\n    const regexInstances: (RegExp | null)[] = []\n    // Initialize as empty strings, not arrays\n    let regexDeclarationForCodeString: string = ''\n    let regexAssignmentForFuncBody: string = ''\n\n    context.regexToCreate.forEach(\n      ({ varName, patternIndex, flagsIndex }, index) => {\n        const pattern = context.values[\n          parseInt(patternIndex.substring(8, patternIndex.length - 1))\n        ] as string\n        const flags = context.values[\n          parseInt(flagsIndex.substring(8, flagsIndex.length - 1))\n        ] as string\n\n        // Append declaration/assignment strings\n        regexDeclarationForCodeString += `    let ${varName}; // Declaration\\n`\n        regexAssignmentForFuncBody += `  ${varName} = _regexInstances[${index}]; // Assignment from bound array\\n`\n\n        // Try creating the RegExp instance\n        try {\n          regexInstances.push(new RegExp(pattern, flags))\n        } catch (regexError) {\n          // Handle invalid regex pattern gracefully\n          regexInstances.push(null) // Store null for invalid regex\n          console.error(\n            `Error creating RegExp (${varName}):`,\n            regexError instanceof Error ? regexError.message : regexError,\n          )\n        }\n      },\n    )\n\n    // 4. Construct the representative code string for the 'code' property\n    const codeString = `\n(doc) => {\n    // --- Outer Scope Variables (captured/bound dependencies) ---\n    // Helpers (available via closure/binding):\n    ${helperNames.map((name) => `// const ${name} = /* bound helper function */;`).join('\\n    ')}\n    // Query Values (available via closure/binding):\n    const _values = ${JSON.stringify(queryValues)}; // Show values used\n    // Where Operators (available via closure/binding):\n    const _whereOps = [ /* bound WhereOperator instances */ ];\n    // RegExp Instances (created once, available via closure/binding):\n${regexDeclarationForCodeString.trim()}\n\n    // --- Runtime Logic ---\n    try {\n        // Note: Inside this block, references like _regex0, _values[N], compareBSONValues are resolved\n        // using the variables made available from the outer scope/binding.\n        const result = !!(${mainCodeString});\n\n        // $where operator check (runs within the runtime function)\n        if (result && _whereOps.length > 0) {\n            if (!_whereOps.every(op => {\n                let whereResult = false;\n                try {\n                    whereResult = op.evaluate(null, doc);\n                    return whereResult;\n                } catch (whereError) {\n                    console.error(\"Error during compiled $where execution:\", whereError);\n                    return false; // Treat $where error as false match\n                }\n            })) {\n                return false;\n            }\n        }\n        return result;\n      } catch (e) {\n        console.error(\"Error during compiled query execution:\", e instanceof Error ? e.message : String(e));\n        return false;\n      }\n}`\n\n    // 5. Construct the actual function body for the Function constructor\n    // This body will receive helpers, values, operators, and regex instances via arguments/binding\n    const runtimeFuncBody = `\n            // Make helpers and values available from bound arguments\n            ${helperNames.map((name) => `const ${name} = _helpers.${name};`).join('\\n')}\n            const _values = _queryValues;\n            const _whereOps = _whereOperators;\n            // Assign pre-compiled regex instances from bound arguments\n            ${regexAssignmentForFuncBody.trim()}\n\n            // --- Runtime Logic ---\n            try {\n                const result = !!(${mainCodeString});\n\n                // $where check logic\n                 if (result && _whereOps.length > 0) {\n                     if (!_whereOps.every(op => {\n                         let whereResult = false;\n                         try {\n                             whereResult = op.evaluate(null, doc);\n                             return whereResult;\n                         } catch (whereError) {\n                             console.error(\"Error during compiled $where execution:\", whereError);\n                             return false;\n                         }\n                     })) {\n                         return false;\n                     }\n                 }\n                return result;\n            } catch (e) {\n                console.error(\"Error during compiled query execution:\", e instanceof Error ? e.message : String(e));\n                return false;\n            }\n        `\n\n    // 6. Create the actual runtime function using Function constructor\n    const CompiledRuntimeFunction = new Function(\n      '_helpers', // Object containing helper functions (e.g., compareBSONValues)\n      '_queryValues', // Array of literal values from the query\n      '_whereOperators', // Array of WhereOperator instances\n      '_regexInstances', // Array of pre-compiled RegExp instances\n      'doc', // The document argument\n      runtimeFuncBody,\n    )\n\n    // 7. Bind the pre-calculated/created dependencies\n    const compiledFunc = CompiledRuntimeFunction.bind(\n      null, // thisArg\n      externalHelpers, // _helpers\n      queryValues, // _queryValues\n      whereOperators, // _whereOperators\n      regexInstances, // _regexInstances (pass the actual RegExp objects)\n    )\n\n    return {\n      code: codeString.trim(), // Use the constructed representative string\n      func: compiledFunc as (doc: any) => boolean,\n    }\n  } catch (e) {\n    // Preserve original error type if it's QueryOperatorError\n    const message = e instanceof Error ? e.message : String(e)\n    console.error('Error during query compilation:', message, e) // Log original error too\n    return {\n      code: `// Compilation Error: ${message}`,\n      func: () => {\n        throw new Error(`Query compilation failed: ${message}`)\n      },\n      error: message,\n      errorDetails: e, // Store original error\n    }\n  }\n}\n\n/**\n * Adds a value to the context and returns the code snippet to access it.\n */\nfunction addValueAndGetCode(\n  value: unknown,\n  context: CompilationContext,\n  store: boolean = false,\n): string {\n  // Remove special handling for BSONRegExp\n  /*\n  if (value instanceof BSONRegExp) {\n    const pattern = value.pattern\n    const flags = value.options\n    // Validate flags during compilation\n    if (/[^gimsuy]/.test(flags)) {\n      throw new QueryOperatorError(\n        `Invalid regex flags specified in BSONRegExp: ${flags}`,\n        '$regex',\n        value,\n      )\n    }\n    const regexVar = context.getRegexVar(pattern, flags)\n    return regexVar\n  }\n  */\n  // Add other values normally\n  const index = context.getNextValueIndex()\n  context.values.push(value)\n  return store ? `_values[${index}]` : `_values[${index}]`\n}\n\n/**\n * Recursively builds the JavaScript code string for a given query part.\n *\n * @param queryPart - The part of the query object to compile.\n * @param docVar - The string representing the variable name of the document/subdocument/value being accessed/tested.\n * @param context - The compilation context containing values and options.\n * @returns A string containing the JavaScript code for the condition.\n */\nfunction buildCodeRecursive(\n  queryPart: unknown,\n  docVar: string,\n  context: CompilationContext,\n): string {\n  // Remove BSONRegExp check\n  /*\n  if (queryPart instanceof BSONRegExp) {\n    const pattern = queryPart.pattern\n    const flags = queryPart.options\n    // Validate flags at compile time\n    if (/[^gimsuy]/.test(flags)) {\n      throw new QueryOperatorError(\n        `Invalid regex flags specified in BSONRegExp: ${flags}`,\n        '$regex',\n        queryPart,\n      )\n    }\n    const regexVar = context.getRegexVar(pattern, flags)\n    return `(${regexVar} !== null && typeof ${docVar} === 'string' && ${regexVar}.test(${docVar}))`\n  }\n  */\n\n  // Handle standard RegExp directly (implicit $regex match)\n  if (queryPart instanceof RegExp) {\n    const pattern = queryPart.source\n    const flags = queryPart.flags\n    // Validate flags at compile time\n    if (/[^gimsuy]/.test(flags)) {\n      throw new QueryOperatorError(\n        `Invalid regex flags specified in RegExp: ${flags}`,\n        '$regex',\n        queryPart,\n      )\n    }\n    const regexVar = context.getRegexVar(pattern, flags)\n    return `(${regexVar} !== null && typeof ${docVar} === 'string' && ${regexVar}.test(${docVar}))`\n  }\n\n  // Handle non-objects (primitive values, arrays but not RegExp) -> Implicit $eq\n  if (\n    typeof queryPart !== 'object' ||\n    queryPart === null ||\n    Array.isArray(queryPart)\n  ) {\n    const valueCode = addValueAndGetCode(queryPart, context)\n    return `deepCompare(${docVar}, ${valueCode})`\n  }\n\n  // --- At this point, queryPart is a non-null, non-array object ---\n  const keys = Object.keys(queryPart)\n  const queryRecord = queryPart as Record<string, unknown>\n\n  // 3. Handle single-key objects: Could be a logical operator or a field operator expression\n  if (keys.length === 1) {\n    const key = keys[0]\n    const value = queryRecord[key]\n\n    // 3a. Top-level/Field-level Logical Operators ($and, $or, $not, $nor) or $where\n    if (isLogicalOperator(key) || key === '$where') {\n      // Handle $where by adding to context via compileOperator\n      if (key === '$where') {\n        compileOperator(key, value, docVar, context) // Adds op to context\n        return 'true' // $where condition is checked at the end\n      }\n      // Handle logical operators\n      switch (key) {\n        case '$and':\n          if (!Array.isArray(value))\n            throw new QueryOperatorError('$and requires an array', key, value)\n          return (\n            value\n              .map(\n                (subQuery) =>\n                  `(${buildCodeRecursive(subQuery, docVar, context)})`,\n              )\n              .join(' && ') || 'true'\n          )\n        case '$or':\n          if (!Array.isArray(value))\n            throw new QueryOperatorError('$or requires an array', key, value)\n          return (\n            value\n              .map(\n                (subQuery) =>\n                  `(${buildCodeRecursive(subQuery, docVar, context)})`,\n              )\n              .join(' || ') || 'false'\n          )\n        case '$not':\n          // Note: This handles top-level $not. Field-level $not is handled in compileOperator.\n          return `!(${buildCodeRecursive(value, docVar, context)})`\n        case '$nor':\n          if (!Array.isArray(value))\n            throw new QueryOperatorError('$nor requires an array', key, value)\n          return (\n            value\n              .map(\n                (subQuery) =>\n                  `!(${buildCodeRecursive(subQuery, docVar, context)})`,\n              )\n              .join(' && ') || 'true'\n          )\n      }\n    }\n\n    // 3b. Field Operator Expression (e.g., { $gt: 10 } or { age: { $gt: 10 } })\n    // This handles the case where queryPart IS the operator expression, e.g. { $gt: 10 }\n    if (key.startsWith('$')) {\n      return compileOperator(key, value, docVar, context)\n    }\n    // 3c. Single Field Check (e.g., { name: \"John\" }) falls through to section 5\n  }\n\n  // 4. Handle objects representing specific BSON types or operator expressions like { $regex: ..., $options: ... }\n  // This check handles cases where such an object is a *value* within the query.\n  if ('$regex' in queryRecord && keys.includes('$regex')) {\n    // Check it's actually a regex obj\n    // If the object itself is { $regex: ..., $options?: ... }, compile it.\n    // This handles cases like `buildCodeRecursive({ $regex: 'pattern', $options: 'i' }, docVar, context)`\n    // which can happen if a regex object is passed directly as queryPart.\n    return compileOperator('$regex', queryPart, docVar, context)\n  }\n\n  // 4b. Handle objects that contain only operators (e.g., { $gte: 25, $lte: 45 })\n  // This is a field condition with multiple operators applied to the same field\n  if (keys.length > 1 && keys.every(key => key.startsWith('$'))) {\n    // All keys are operators, combine them with AND\n    const operatorConditions = keys.map(key => {\n      const value = queryRecord[key]\n      return compileOperator(key, value, docVar, context)\n    })\n    return operatorConditions.join(' && ')\n  }\n  // TODO: Potentially add checks for other BSON types if they are passed as queryPart directly.\n\n  // 5. Handle multiple fields (implicit $and) or a single field that is not an operator\n  const fieldConditions = keys.map((key) => {\n    // If a key is $where at this level (e.g., { field: 'val', $where: '...' }), handle it.\n    if (key === '$where') {\n      compileOperator(key, queryRecord[key], docVar, context) // Adds op to context\n      return 'true' // Condition checked at the end\n    }\n\n    // Handle logical operators at this level (e.g., { field: 'val', $or: [...] })\n    if (isLogicalOperator(key)) {\n      const value = queryRecord[key]\n      switch (key) {\n        case '$and':\n          if (!Array.isArray(value))\n            throw new QueryOperatorError('$and requires an array', key, value)\n          return (\n            '(' + (value\n              .map(\n                (subQuery) =>\n                  `(${buildCodeRecursive(subQuery, docVar, context)})`,\n              )\n              .join(' && ') || 'true') + ')'\n          )\n        case '$or':\n          if (!Array.isArray(value))\n            throw new QueryOperatorError('$or requires an array', key, value)\n          return (\n            '(' + (value\n              .map(\n                (subQuery) =>\n                  `(${buildCodeRecursive(subQuery, docVar, context)})`,\n              )\n              .join(' || ') || 'false') + ')'\n          )\n        case '$not':\n          return `!(${buildCodeRecursive(value, docVar, context)})`\n        case '$nor':\n          if (!Array.isArray(value))\n            throw new QueryOperatorError('$nor requires an array', key, value)\n          return (\n            '(' + (value\n              .map(\n                (subQuery) =>\n                  `!(${buildCodeRecursive(subQuery, docVar, context)})`,\n              )\n              .join(' && ') || 'true') + ')'\n          )\n      }\n    }\n\n    const value = queryRecord[key]\n    const safeAccessVar = key.split('.').reduce((acc, part) => {\n      if (!/^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(part)) {\n        const escapedPart = part.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"')\n        return `${acc}?.[\"${escapedPart}\"]`\n      }\n      return `${acc}?.${part}`\n    }, docVar)\n    // Recursively build code for the field's value/condition\n    return buildCodeRecursive(value, safeAccessVar, context)\n  })\n\n  // Combine field conditions with &&\n  const actualConditions = fieldConditions.filter((c) => c !== 'true')\n  if (actualConditions.length === 0) return 'true'\n  return actualConditions.join(' && ')\n}\n\n/**\n * Compiles a specific operator into JavaScript code.\n *\n * @param operator - The operator string (e.g., \"$eq\", \"$gt\", \"$regex\").\n * @param value - The operand value for the operator.\n * @param docVar - The variable name representing the field value being tested.\n * @param context - Compilation context.\n * @returns JavaScript code string for the operator.\n */\nfunction compileOperator(\n  operator: string,\n  value: unknown,\n  docVar: string,\n  context: CompilationContext,\n): string {\n  const safeCompare = (op: '>' | '>=' | '<' | '<=') => {\n    const valueCode = addValueAndGetCode(value, context)\n    const comparison = `compareValues(${docVar}, ${valueCode})`\n    switch (op) {\n      case '>':\n        return `(${comparison} === 1)`\n      case '<':\n        return `(${comparison} === -1)`\n      case '>=':\n        return `(res => res === 1 || res === 0)(${comparison})`\n      case '<=':\n        return `(res => res === -1 || res === 0)(${comparison})`\n    }\n  }\n\n  switch (operator) {\n    // --- Comparison Operators ---\n    case '$eq': {\n      const valueCode = addValueAndGetCode(value, context)\n      return `deepCompare(${docVar}, ${valueCode})`\n    }\n    case '$gt':\n      return safeCompare('>')\n    case '$gte':\n      return safeCompare('>=')\n    case '$lt':\n      return safeCompare('<')\n    case '$lte':\n      return safeCompare('<=')\n    case '$ne': {\n      const valueCode = addValueAndGetCode(value, context)\n      return `!deepCompare(${docVar}, ${valueCode})`\n    }\n    case '$in': {\n      if (!Array.isArray(value))\n        throw new QueryOperatorError('$in requires an array', '$in', value)\n      const valueCode = addValueAndGetCode(value, context)\n      // MongoDB $in behavior: check if field value matches any value in the query array\n      // If field value is an array, check if any element in field array matches any query value\n      return `(\n        Array.isArray(${docVar})\n          ? ${docVar}.some(fieldItem => ${valueCode}.some(queryItem => deepCompare(fieldItem, queryItem)))\n          : ${valueCode}.some(queryItem => deepCompare(${docVar}, queryItem))\n      )`\n    }\n    case '$nin': {\n      if (!Array.isArray(value))\n        throw new QueryOperatorError('$nin requires an array', '$nin', value)\n      const valueCode = addValueAndGetCode(value, context)\n      // MongoDB $nin behavior: negation of $in\n      return `!(\n        Array.isArray(${docVar})\n          ? ${docVar}.some(fieldItem => ${valueCode}.some(queryItem => deepCompare(fieldItem, queryItem)))\n          : ${valueCode}.some(queryItem => deepCompare(${docVar}, queryItem))\n      )`\n    }\n\n    // --- Logical Operator (applied to field) ---\n    case '$not':\n      if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n        // Allow basic negation like { field: { $not: /regex/ } }\n        if (!(value instanceof RegExp)) {\n          throw new QueryOperatorError(\n            '$not requires an operator expression or a regular expression',\n            '$not',\n            value,\n          )\n        }\n        // If it's a regex, compileOperator('$not') will wrap !compileOperator('$regex') essentially\n      }\n      // Let buildCodeRecursive handle the inner expression compilation\n      // This works for { field: { $not: { $gt: 10 } } }\n      // And { field: { $not: /pattern/ } }\n      return `!(${buildCodeRecursive(value, docVar, context)})`\n\n    // --- Element Operators ---\n    case '$exists': {\n      if (typeof value !== 'boolean') {\n        throw new QueryOperatorError(\n          '$exists requires a boolean value',\n          '$exists',\n          value,\n        )\n      }\n      return `${docVar} ${value ? '!==' : '==='} undefined`\n    }\n\n    case '$type': {\n      // let expectedTypes: Array<string | number> // Keep number for potential future use? No, only strings now.\n      let expectedTypeStrings: string[]\n\n      if (Array.isArray(value)) {\n        expectedTypeStrings = value.map((v) => String(v).toLowerCase())\n      } else if (typeof value === 'string') {\n        expectedTypeStrings = [value.toLowerCase()]\n      } else {\n        throw new QueryOperatorError(\n          '$type requires a type name string or an array of type name strings',\n          '$type',\n          value,\n        )\n      }\n\n      // Validate type strings during compilation (optional but good practice)\n      const validTypes = [\n        'string',\n        'number',\n        'boolean',\n        'object',\n        'array',\n        'null',\n        'undefined',\n        'date',\n        'regexp',\n        'buffer',\n      ]\n      for (const typeStr of expectedTypeStrings) {\n        if (!validTypes.includes(typeStr)) {\n          // Allow unrecognized types for flexibility? Or throw error?\n          // Let's throw for now to be stricter.\n          throw new QueryOperatorError(\n            `Invalid type name specified for $type: ${typeStr}`,\n            '$type',\n            value,\n          )\n        }\n      }\n\n      // Add the array of validated target type *names* to the values\n      const targetTypesCode = addValueAndGetCode(expectedTypeStrings, context)\n\n      // Generate code to get the actual type and check if it's in the target list\n      // Use the renamed helper directly\n      return `(actualType => actualType !== null && ${targetTypesCode}.includes(actualType))(_helpers._getJsTypeHelper(${docVar}))`\n    }\n\n    // --- Evaluation Operators ---\n    case '$regex': {\n      let pattern: string\n      let flags: string = ''\n\n      if (typeof value === 'string') {\n        pattern = value\n      } else if (value instanceof RegExp) {\n        pattern = value.source\n        flags = value.flags\n      } else if (\n        typeof value === 'object' &&\n        value !== null &&\n        '$regex' in value\n      ) {\n        const regexObj = value as { $regex: unknown; $options?: unknown }\n        if (typeof regexObj.$regex !== 'string') {\n          throw new QueryOperatorError(\n            `$regex: $regex requires a string, RegExp, or { $regex, $options } object`,\n            operator,\n            value,\n          )\n        }\n        pattern = regexObj.$regex\n        if (regexObj.$options !== undefined) {\n          if (typeof regexObj.$options !== 'string') {\n            throw new QueryOperatorError(\n              `$regex: $options requires a string`,\n              operator,\n              value,\n            )\n          }\n          flags = regexObj.$options\n        }\n      } else {\n        throw new QueryOperatorError(\n          `$regex: $regex requires a string, RegExp, or { $regex, $options } object`,\n          operator,\n          value,\n        )\n      }\n\n      // Validate flags at compile time\n      if (/[^gimsuy]/.test(flags)) {\n        throw new QueryOperatorError(\n          `$regex: Invalid regex flags specified: ${flags}`,\n          operator,\n          value,\n        )\n      }\n\n      const regexVar = context.getRegexVar(pattern, flags)\n      // MongoDB behavior: if field value is an array, apply regex to each element\n      // Check if docVar is an array, and if so, iterate and test each element.\n      return `(\n        Array.isArray(${docVar})\n          ? ${docVar}.some(item => typeof item === 'string' && ${regexVar} !== null && ${regexVar}.test(item))\n          : (typeof ${docVar} === 'string' && ${regexVar} !== null && ${regexVar}.test(${docVar}))\n      )`\n    }\n    case '$mod': {\n      if (!Array.isArray(value) || value.length !== 2) {\n        throw new QueryOperatorError(\n          '$mod requires an array with [ divisor, remainder ]',\n          '$mod',\n          value,\n        )\n      }\n      const [divisor, remainder] = value\n      if (\n        typeof divisor !== 'number' ||\n        typeof remainder !== 'number' ||\n        !Number.isInteger(divisor) ||\n        !Number.isInteger(remainder)\n      ) {\n        // TODO: Add BigInt support check later if needed\n        throw new QueryOperatorError(\n          '$mod requires divisor and remainder to be integers',\n          '$mod',\n          value,\n        )\n      }\n      if (divisor === 0) {\n        throw new QueryOperatorError('$mod divisor cannot be 0', '$mod', value)\n      }\n\n      const divisorCode = addValueAndGetCode(divisor, context)\n      const remainderCode = addValueAndGetCode(remainder, context)\n      // Check if docVar is a number and perform modulo\n      return `(typeof ${docVar} === 'number' && Number.isInteger(${docVar}) && ${docVar} % ${divisorCode} === ${remainderCode})`\n    }\n\n    case '$where': {\n      // Handle $where by creating operator and adding to context\n      if (typeof value !== 'string' && typeof value !== 'function') {\n        throw new QueryOperatorError(\n          '$where requires a string or function argument',\n          '$where',\n          value,\n        )\n      }\n      try {\n        const whereOp = new WhereOperator(value as any)\n        context.whereOperators.push(whereOp)\n        return 'true' // Let the final check handle the evaluation\n      } catch (e) {\n        if (e instanceof QueryOperatorError) {\n          throw e\n        } else {\n          throw new QueryOperatorError(\n            `Invalid $where argument: ${e instanceof Error ? e.message : String(e)}`,\n            '$where',\n            value,\n          )\n        }\n      }\n    }\n\n    // ADDED: $text operator (simplified)\n    case '$text': {\n      if (\n        typeof value !== 'object' ||\n        value === null ||\n        !('$search' in value)\n      ) {\n        throw new QueryOperatorError(\n          '$text requires an object with a $search property',\n          '$text',\n          value,\n        )\n      }\n      const textQuery = value as { $search: unknown; $caseSensitive?: unknown }\n\n      if (typeof textQuery.$search !== 'string') {\n        throw new QueryOperatorError(\n          '$text operator requires $search to be a string',\n          '$text',\n          value,\n        )\n      }\n      const searchString = textQuery.$search.trim()\n      if (searchString === '') {\n        throw new QueryOperatorError(\n          '$text operator $search string cannot be empty',\n          '$text',\n          value,\n        )\n      }\n\n      let caseSensitive = false\n      if ('$caseSensitive' in textQuery) {\n        if (typeof textQuery.$caseSensitive !== 'boolean') {\n          throw new QueryOperatorError(\n            '$text operator $caseSensitive must be a boolean',\n            '$text',\n            value,\n          )\n        }\n        caseSensitive = textQuery.$caseSensitive\n      }\n\n      // Split search string into words (simple space split)\n      const searchWords = searchString.split(/\\s+/) // Split by whitespace\n      const wordsCode = addValueAndGetCode(searchWords, context)\n      const caseSensitiveCode = addValueAndGetCode(caseSensitive, context)\n\n      // Generate code to check if docVar is a string and contains all words\n      return `(\n                (fieldVal =>\n                    typeof fieldVal === 'string' && ${wordsCode}.length > 0 && (\n                        ${wordsCode}.every(word => {\n                            const compareWord = ${caseSensitiveCode} ? word : word.toLowerCase();\n                            const compareField = ${caseSensitiveCode} ? fieldVal : fieldVal.toLowerCase();\n                            // Basic check: does the field include the word?\n                            // This doesn't handle stemming, language specifics, etc.\n                            return compareField.includes(compareWord);\n                        })\n                    )\n                )(${docVar})\n            )`\n    }\n\n    // --- Bitwise Operators ---\n    case '$bitsAllSet':\n    case '$bitsAnySet':\n    case '$bitsAllClear':\n    case '$bitsAnyClear': {\n      let bitmask: number\n      if (typeof value === 'number' && Number.isInteger(value) && value >= 0) {\n        bitmask = value\n      } else if (Array.isArray(value)) {\n        bitmask = 0\n        for (const pos of value) {\n          if (typeof pos !== 'number' || !Number.isInteger(pos) || pos < 0) {\n            throw new QueryOperatorError(\n              `Bit positions must be non-negative integers in ${operator}`,\n              operator,\n              value,\n            )\n          }\n          bitmask |= 1 << pos\n        }\n      } else {\n        throw new QueryOperatorError(\n          `${operator} requires a non-negative integer bitmask or an array of non-negative bit positions`,\n          operator,\n          value,\n        )\n      }\n\n      const maskCode = addValueAndGetCode(bitmask, context)\n      const numCheck = `(typeof ${docVar} === 'number' && Number.isInteger(${docVar}))`\n\n      switch (operator) {\n        case '$bitsAllSet':\n          return `${numCheck} && (${docVar} & ${maskCode}) === ${maskCode}`\n        case '$bitsAnySet':\n          return `${numCheck} && (${docVar} & ${maskCode}) !== 0`\n        case '$bitsAllClear':\n          return `${numCheck} && (${docVar} & ${maskCode}) === 0`\n        case '$bitsAnyClear':\n          // Check if *any* of the masked bits are 0 in docVar\n          // This means the result of (docVar & mask) must *not* have all the mask bits set\n          // Equivalent to: (docVar & mask) !== mask\n          return `${numCheck} && (${docVar} & ${maskCode}) !== ${maskCode}`\n      }\n      break // Should not be reached due to inner switch return\n    }\n\n    // --- Array Operators ---\n    case '$all': {\n      if (!Array.isArray(value)) {\n        throw new QueryOperatorError(\n          '$all requires an array value',\n          '$all',\n          value,\n        )\n      }\n      const queryArrayCode = addValueAndGetCode(value, context)\n      // Check if docVar is an array and if every element in queryArrayCode\n      // can be found in docVar using deepCompare.\n      // Handle the edge case where queryArrayCode is empty (matches any array).\n      const check = `\n                Array.isArray(${docVar}) && (\n                    ${queryArrayCode}.length === 0 ||\n                    ${queryArrayCode}.every(queryVal =>\n                        (${docVar}).some(docItem => deepCompare(docItem, queryVal))\n                    )\n                )\n            `\n      // Also handle the specific non-array case: matches if docVar equals the single element in queryArray\n      const nonArrayCheck = `\n                !Array.isArray(${docVar}) && ${queryArrayCode}.length === 1 && deepCompare(${docVar}, ${queryArrayCode}[0])\n            `\n      return `((${check.trim()}) || (${nonArrayCheck.trim()}))`\n    }\n    case '$size': {\n      if (typeof value !== 'number' || !Number.isInteger(value) || value < 0) {\n        throw new QueryOperatorError(\n          '$size requires a non-negative integer',\n          '$size',\n          value,\n        )\n      }\n      const sizeCode = addValueAndGetCode(value, context)\n      // Check if docVar is an array and its length matches sizeCode\n      return `(Array.isArray(${docVar}) && ${docVar}.length === ${sizeCode})`\n    }\n    case '$elemMatch': {\n      // $elemMatch requires a query object as its value\n      if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n        throw new QueryOperatorError(\n          '$elemMatch requires a query object',\n          '$elemMatch',\n          value,\n        )\n      }\n\n      // Generate the code for the sub-query condition\n      // We pass 'elem' as the docVar for the sub-query\n      const subQueryCode = buildCodeRecursive(value, 'elem', context)\n\n      // Generate code that checks if docVar is an array and if at least one element ('elem')\n      // satisfies the subQueryCode.\n      return `(\n                Array.isArray(${docVar}) &&\n                ${docVar}.some(elem => {\n                    try {\n                        return (${subQueryCode});\n                    } catch (e) {\n                        // Errors during sub-query execution on an element should result in false\n                        // console.error(\"Error during $elemMatch sub-query execution:\", e instanceof Error ? e.message : String(e));\n                        return false;\n                    }\n                })\n            )`\n    }\n\n    // TODO: Add other operators ($type, $all, $elemMatch, $size, bitwise)\n    // TODO: $text operator is complex and might require a separate compilation strategy or not be suitable for full compilation.\n\n    default:\n      if (isOperator(operator as OperatorType)) {\n        console.warn(\n          `Operator '${operator}' is recognized but not implemented in compileQuery.`,\n        )\n      }\n      throw new QueryOperatorError(\n        `Unsupported operator: ${operator}`,\n        operator,\n        value,\n      )\n  }\n  // Explicitly return something here to satisfy TypeScript, although it shouldn't be reached\n  // due to the default case throwing an error.\n  return 'false'\n}\n",
    "import type { QueryType } from './QueryType'\nimport type { UnaryCondition } from './UnaryCondition'\nimport { build_query_new } from './build_query'\nimport { compileQuery } from './compile_query'\n\nexport interface QueryOptions {\n  /** Custom operators for query building */\n  operators?: { [op: string]: (...args: Array<any>) => UnaryCondition }\n  /** Use interpreted mode instead of compiled (for debugging) */\n  interpreted?: boolean\n  /** Enable debug logging */\n  debug?: boolean\n  /** Custom logical operators */\n  $and?: (...args: Array<any>) => UnaryCondition\n  $or?: (...args: Array<any>) => UnaryCondition\n}\n\n/**\n * Main query function for building query conditions\n *\n * By default uses compiled queries for maximum performance.\n * Set options.interpreted = true for debugging or development.\n *\n * @param obj - Query object (MongoDB-style query)\n * @param options - Query options including mode selection\n * @returns UnaryCondition function that can be used to test documents\n *\n * @example\n * ```typescript\n * // Compiled mode (default, fastest)\n * const condition = query({ age: { $gt: 18 }, status: 'active' })\n *\n * // Interpreted mode (for debugging)\n * const debugCondition = query({ age: { $gt: 18 } }, { interpreted: true })\n *\n * const isMatch = condition(document)\n * ```\n */\nexport function query(\n  obj: QueryType,\n  options: QueryOptions = {}\n): UnaryCondition {\n  const { operators, interpreted = false, debug = false } = options\n\n  if (debug) {\n    console.log(`ð Query mode: ${interpreted ? 'interpreted' : 'compiled'}`)\n    console.log('ð Query object:', JSON.stringify(obj, null, 2))\n  }\n\n  // Use interpreted mode for debugging\n  if (interpreted) {\n    if (debug) console.log('ð Using interpreted mode for debugging')\n    return build_query_new(obj, operators)\n  }\n\n    // Use compiled mode by default for performance\n  try {\n    // Note: compileQuery expects operators that return code strings, not UnaryConditions\n    // For now, we pass undefined for operators in compiled mode\n    const compiledResult = compileQuery(obj, undefined)\n\n    if (compiledResult.func) {\n      if (debug) {\n        console.log('â¡ Using compiled mode')\n        console.log('â¡ Compiled code:', compiledResult.code)\n      }\n      return compiledResult.func\n    } else {\n      if (debug) console.log('â ï¸  Compilation failed, falling back to interpreted mode')\n      console.warn('Query compilation failed, falling back to interpreted mode:', compiledResult.error)\n      return build_query_new(obj, operators)\n    }\n  } catch (error: any) {\n    if (debug) console.log('â ï¸  Compilation error, falling back to interpreted mode:', error.message)\n    console.warn('Query compilation error, falling back to interpreted mode:', error.message)\n    return build_query_new(obj, operators)\n  }\n}\n\n// Re-export for convenience and backward compatibility\nexport { build_query_new as buildQuery } from './build_query'\nexport { compileQuery } from './compile_query'\n\n// Legacy function for backward compatibility\nexport function queryInterpreted(\n  obj: QueryType,\n  options?: { [op: string]: (...args: Array<any>) => UnaryCondition }\n): UnaryCondition {\n  return build_query_new(obj, options)\n}\n\n// Compiled-only function for explicit compiled usage\nexport function queryCompiled(\n  obj: QueryType,\n  options?: { [op: string]: (...args: Array<any>) => string }\n): UnaryCondition {\n  const compiledResult = compileQuery(obj, options)\n\n  if (!compiledResult.func) {\n    throw new Error(`Query compilation failed: ${compiledResult.error || 'Unknown error'}`)\n  }\n\n  return compiledResult.func\n}",
    "// Ð­ÐºÑÐ¿Ð¾ÑÑÐ¸ÑÑÐµÐ¼ Ð²ÑÐµ ÑÐ¸Ð¿Ñ\nexport * from './types'\n\n// Ð­ÐºÑÐ¿Ð¾ÑÑÐ¸ÑÑÐµÐ¼ Ð²ÑÐµ Ð¾Ð¿ÐµÑÐ°ÑÐ¾ÑÑ\nexport * from './logical'\nexport * from './element'\nexport * from './array'\nexport * from './evaluation'\nexport * from './bitwise'\nexport * from './text'\nexport * from './comparison'\n\n// Ð­ÐºÑÐ¿Ð¾ÑÑÐ¸ÑÑÐµÐ¼ Ð¾ÑÐ½Ð¾Ð²Ð½ÑÐµ ÑÑÐ½ÐºÑÐ¸Ð¸ API\nexport * from './query'\nexport * from './build_query'\nexport * from './compile_query'\n\n// ÐÐ¼Ð¿Ð¾ÑÑÐ¸ÑÑÐµÐ¼ Ð²ÑÐµ Ð¾Ð¿ÐµÑÐ°ÑÐ¾ÑÑ Ð´Ð»Ñ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ Ð¾Ð±ÑÐµÐ³Ð¾ Ð¾Ð±ÑÐµÐºÑÐ°\nimport { logicalOperators } from './logical'\nimport { elementOperators } from './element'\nimport { arrayOperators } from './array'\nimport { evaluationOperators } from './evaluation'\nimport { bitwiseOperators } from './bitwise'\nimport { textSearchOperators } from './text'\nimport { comparisonOperators } from './comparison'\nimport { QueryOperator, QueryValue, QueryOperatorError } from './types'\n\n// ÐÐ±ÑÐµÐ´Ð¸Ð½ÑÐµÐ¼ Ð²ÑÐµ Ð¾Ð¿ÐµÑÐ°ÑÐ¾ÑÑ Ð² Ð¾Ð´Ð¸Ð½ Ð¾Ð±ÑÐµÐºÑ\nexport const allOperators = {\n  ...logicalOperators,\n  ...elementOperators,\n  ...arrayOperators,\n  ...evaluationOperators,\n  ...bitwiseOperators,\n  ...textSearchOperators,\n  ...comparisonOperators,\n} as const\n\n// Ð¢Ð¸Ð¿ Ð´Ð»Ñ Ð²ÑÐµÑ Ð´Ð¾ÑÑÑÐ¿Ð½ÑÑ Ð¾Ð¿ÐµÑÐ°ÑÐ¾ÑÐ¾Ð²\nexport type OperatorType = keyof typeof allOperators\n\n// Ð¢Ð¸Ð¿ Ð´Ð»Ñ ÐºÐ¾Ð½ÑÑÑÑÐºÑÐ¾ÑÐ° Ð¾Ð¿ÐµÑÐ°ÑÐ¾ÑÐ°\nexport type OperatorConstructor = new (value: QueryValue) => QueryOperator\n\n// Ð¤ÑÐ½ÐºÑÐ¸Ñ Ð´Ð»Ñ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸, ÑÐ²Ð»ÑÐµÑÑÑ Ð»Ð¸ ÑÑÑÐ¾ÐºÐ° Ð¾Ð¿ÐµÑÐ°ÑÐ¾ÑÐ¾Ð¼\nexport function isOperator(value: string): value is OperatorType {\n  return value in allOperators\n}\n\n// Ð¤ÑÐ½ÐºÑÐ¸Ñ Ð´Ð»Ñ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ Ð¾Ð¿ÐµÑÐ°ÑÐ¾ÑÐ° Ð¿Ð¾ Ð¸Ð¼ÐµÐ½Ð¸\nexport function createOperator(\n  operator: OperatorType,\n  value: QueryValue,\n): QueryOperator {\n  const OperatorClass = allOperators[operator] as OperatorConstructor\n  return new OperatorClass(value)\n}\n\n// Ð¤ÑÐ½ÐºÑÐ¸Ñ Ð´Ð»Ñ Ð²Ð°Ð»Ð¸Ð´Ð°ÑÐ¸Ð¸ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ Ð¾Ð¿ÐµÑÐ°ÑÐ¾ÑÐ°\nexport function validateOperatorValue(\n  operator: OperatorType,\n  value: unknown,\n): value is QueryValue {\n  try {\n    createOperator(operator, value as QueryValue)\n    return true\n  } catch (error) {\n    if (error instanceof QueryOperatorError) {\n      return false\n    }\n    throw error\n  }\n}\n\n// Ð¤ÑÐ½ÐºÑÐ¸Ñ Ð´Ð»Ñ Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ñ ÑÐ¸Ð¿Ð° Ð¾Ð¿ÐµÑÐ°ÑÐ¾ÑÐ°\nexport function getOperatorType(operator: QueryOperator): string {\n  return operator.type\n}\n\n// Ð¤ÑÐ½ÐºÑÐ¸Ñ Ð´Ð»Ñ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸, ÑÐ²Ð»ÑÐµÑÑÑ Ð»Ð¸ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ Ð¾Ð¿ÐµÑÐ°ÑÐ¾ÑÐ¾Ð¼ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð½Ð¾Ð³Ð¾ ÑÐ¸Ð¿Ð°\nexport function isOperatorOfType<T extends QueryOperator>(\n  value: unknown,\n  type: string,\n): value is T {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    'type' in value &&\n    (value as any).type === type\n  )\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { query } from '../query'\nimport { TraverseCondition } from '../types/TraverseCondition'\n\nexport async function* last<T extends Item>(\n  collection: Collection<T>,\n  condition: TraverseCondition<T>,\n): AsyncGenerator<T> {\n  const conditionFn = typeof condition === 'function' ? condition : query(condition)\n  for await (const current of collection.list.backward) {\n    if (conditionFn(current)) {\n      yield current\n      return\n    }\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { query } from '../query'\nimport { TraverseCondition } from '../types/TraverseCondition'\n\nexport async function* first<T extends Item>(\n  collection: Collection<T>,\n  condition: TraverseCondition<T>,\n): AsyncGenerator<T> {\n  const conditionFn = typeof condition === 'function' ? condition : query(condition)\n  for await (const current of collection.list.forward) {\n    if (conditionFn(current)) {\n      yield current\n      return\n    }\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { query } from '../query'\nimport { TraverseCondition } from '../types/TraverseCondition'\n\n// Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ð½Ðµ ÑÐ°Ð±Ð¾ÑÐ°ÐµÑ TTL Ð½Ðµ ÑÐ´Ð°Ð»ÑÑÑÑÑ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ Ð¸Ð½Ð´ÐµÐºÑÐ°.\n\nexport async function* all<T extends Item>(\n  collection: Collection<T>,\n  condition: TraverseCondition<T>,\n): AsyncGenerator<T> {\n  const conditionFn = typeof condition === 'function' ? condition : query(condition)\n  for await (const current of collection.list.forward) {\n    if (conditionFn(current)) {\n      yield current\n    }\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\n\n/**\n * ensures values for indexing and return final index insert routines\n * @param collection source collection\n * @param val inserting value\n */\nexport function prepare_index_insert<T extends Item>(\n  collection: Collection<T>,\n  val: T,\n) {\n  const result: Array<any> = []\n  // for is used to provide dynamic indexes add on create\n  for (let i = 0; i < collection.inserts?.length; i += 1) {\n    result.push(collection.inserts[i](val))\n  }\n\n  return (i: any) => {\n    result.forEach((f) => f?.(i))\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { ValueType } from 'b-pl-tree'\n\nexport async function update_index<T extends Item>(\n  collection: Collection<T>,\n  ov: T | Partial<T>,\n  nv: T | Partial<T>,\n  i: ValueType,\n) {\n  await Promise.all(collection.updates.map((item) => item(ov, nv, i)))\n}\n",
    "import { Item } from '../types/Item'\nimport { ValueType } from 'b-pl-tree'\nimport Collection, { ttl_key } from '../collection'\n\nexport async function ensure_ttl<T extends Item>(collection: Collection<T>) {\n  if (collection.ttl) {\n    // collection.indexes\n    // ensure that all object are actuated with time\n    const now = Date.now()\n    const cutoffTime = now - collection.ttl\n\n    // Get TTL index\n    const ttlIndex = collection.indexes[ttl_key]\n    if (!ttlIndex) return\n\n    // Find all items with TTL less than cutoff time using the lt() method\n    const expiredItems: ValueType[] = []\n\n    // Use the lt() method to get a generator for items with TTL < cutoffTime\n    const expiredGenerator = ttlIndex.lt(cutoffTime)(ttlIndex)\n\n    let cursor = expiredGenerator.next()\n    while (!cursor.done && cursor.value) {\n      if (cursor.value.value !== undefined) {\n        expiredItems.push(cursor.value.value)\n      }\n      cursor = expiredGenerator.next()\n    }\n\n    // Remove expired items using removeWithId now that the index/list issue is fixed\n    for (const itemId of expiredItems) {\n      await collection.removeWithId(itemId)\n    }\n\n    if (expiredItems.length > 0) {\n      await collection.persist()\n    }\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\n\nexport function remove_index<T extends Item>(\n  collection: Collection<T>,\n  val: any,\n) {\n  collection.removes.forEach((item) => item(val))\n}\n",
    "import { get } from 'lodash-es'\nimport { IndexDef } from '../types/IndexDef'\nimport { Item } from '../types/Item'\nimport { BPlusTree, ValueType } from 'b-pl-tree'\nimport Collection from '../collection'\nimport { ensure_indexed_value } from './ensure_indexed_value'\nimport { get_value } from './get_value'\nimport { validate_indexed_value_for_insert } from './validate_indexed_value_for_insert'\nimport { validate_indexed_value_for_update } from './validate_indexed_value_for_update'\nimport { ensure_indexes } from './ensure_indexes'\nimport { build_indexes } from './build_indexes'\nimport { CompositeKeyUtils } from '../utils/CompositeKeyUtils'\n\nexport function create_index<T extends Item>(\n  collection: Collection<T>,\n  key: string,\n  indexDef: IndexDef<T>,\n) {\n  const {\n    auto = false,\n    unique = false,\n    sparse = false,\n    required = false,\n    ignoreCase,\n    separator = CompositeKeyUtils.DEFAULT_SEPARATOR,\n  } = indexDef\n\n  let { gen, process } = indexDef\n\n  // Normalize the index definition to unified format\n  const normalizedFields = CompositeKeyUtils.normalizeIndexFields(indexDef)\n  const isCompositeIndex = normalizedFields.length > 1\n\n  // Generate index name if not provided\n  if (!key) {\n    key = CompositeKeyUtils.generateIndexName(normalizedFields)\n  }\n\n  if (auto && !gen) {\n    gen = Collection.genCache['autoIncIdGen']\n  }\n\n  if (ignoreCase) {\n    process = (value: any) =>\n      value?.toString ? value.toString().toLowerCase() : value\n  }\n\n  // Create process function if not provided\n  if (!process) {\n    process = CompositeKeyUtils.createProcessFunction(normalizedFields, separator)\n  }\n\n  // Store the normalized index definition\n  collection.indexDefs[key] = {\n    key: isCompositeIndex ? undefined : normalizedFields[0].key,\n    keys: isCompositeIndex ? normalizedFields : undefined,\n    order: !isCompositeIndex ? normalizedFields[0].order : undefined,\n    separator: isCompositeIndex ? separator : undefined,\n    auto,\n    unique,\n    gen,\n    sparse,\n    required,\n    ignoreCase,\n    process,\n  }\n\n  if (collection.indexes.hasOwnProperty(key)) {\n    throw new Error(`index with key ${key} already exists`)\n  }\n\n  const insert: any =\n    key !== '*'\n      ? (item: T) => {\n          const value = ensure_indexed_value(\n            item,\n            key,\n            collection,\n            gen,\n            auto,\n            process,\n          )\n          const [valid, message] = validate_indexed_value_for_insert(\n            collection,\n            value,\n            key,\n            sparse,\n            required,\n            unique,\n          )\n          if (!valid) throw new Error(message)\n          if (!(sparse && value == null)) {\n            return (record_link: ValueType) =>\n              collection.indexes[key].insert(\n                value !== undefined ? value : null,\n                record_link,\n              )\n          }\n        }\n      : (item: T) => {\n          let found = false\n          const newIndexDefs = Object.keys(item).reduce((res, pname) => {\n            if (!collection.indexDefs[pname]) {\n              found = true\n              res[pname] = {\n                ...collection.indexDefs['*'],\n                key: pname,\n              }\n            }\n            return res\n          }, {} as Record<string, IndexDef<T>>)\n\n          if (found) {\n            collection.indexDefs = {\n              ...collection.indexDefs,\n              ...newIndexDefs,\n            }\n            build_indexes(collection, newIndexDefs)\n            ensure_indexes(collection)\n          }\n          return (record_link: ValueType) => undefined\n        }\n\n  const update: any =\n    key !== '*'\n      ? async (ov: T | Partial<T>, nv: T | Partial<T>, index_payload: number) => {\n          const valueOld = ensure_indexed_value<T>(\n            ov,\n            key,\n            collection,\n            gen,\n            auto,\n            process,\n          )\n          const valueNew = get_value(nv, key, process)\n          if (valueNew != null) {\n            const [valid, message] = await validate_indexed_value_for_update(\n              collection,\n              valueNew,\n              key,\n              sparse,\n              required,\n              unique,\n              (ov as any)[collection.id],\n            )\n            if (!valid) throw new Error(message)\n            if (valueOld !== valueNew) {\n              if (unique) {\n                collection.indexes[key].remove(valueOld)\n              } else {\n                collection.indexes[key].removeSpecific(valueOld, (pointer) =>\n                  key != collection.id ? pointer == (ov as any)[collection.id] : true,\n                )\n              }\n              collection.indexes[key].insert(\n                valueNew !== undefined ? valueNew : null,\n                index_payload,\n              )\n            }\n          } else {\n            if (unique) {\n              collection.indexes[key].remove(valueOld)\n            } else {\n              collection.indexes[key].removeSpecific(valueOld, (pointer) =>\n                key != collection.id ? pointer == (ov as any)[collection.id] : true,\n              )\n            }\n          }\n        }\n      : undefined\n\n  const remove: any =\n    key !== '*'\n      ? (item: T) => {\n          const value = process ? process(item) : get(item, key) ?? null\n          collection.indexes[key].removeSpecific(\n            value,\n            (pointer) =>\n              key != collection.id ? pointer == item[collection.id] : true,\n          )\n        }\n      : undefined\n\n  const ensure =\n    key !== '*'\n      ? () => {\n          if (!collection.indexes.hasOwnProperty(key)) {\n            // Create comparator using unified approach\n            const comparator = CompositeKeyUtils.createComparator(normalizedFields, separator)\n            collection.indexes[key] = new BPlusTree<any, number>(undefined, unique, comparator)\n          }\n        }\n      : undefined\n\n  const rebuild =\n    key !== '*'\n      ? async () => {\n          if (!collection.indexes.hasOwnProperty(key)) {\n            // Create comparator using unified approach\n            const comparator = CompositeKeyUtils.createComparator(normalizedFields, separator)\n            collection.indexes[key] = new BPlusTree<any, number>(undefined, unique, comparator)\n            if (collection.list.length > 0) {\n              for await (const item of collection.list.forward) {\n                insert?.(item)?.(item[collection.id])\n              }\n            }\n          }\n        }\n      : null\n\n  if (ensure) collection.ensures.push(ensure)\n  if (rebuild) collection.rebuilds.push(rebuild)\n  if (insert) collection.inserts.push(insert)\n  if (update) collection.updates.push(update)\n  if (remove) collection.removes.push(remove)\n}\n",
    "import { get, set } from 'lodash-es'\nimport { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { IdGeneratorFunction } from '../types/IdGeneratorFunction'\nimport { ValueType } from 'b-pl-tree'\n\nexport function ensure_indexed_value<T extends Item>(\n  item: T | Partial<T>,\n  key: unknown,\n  collection: Collection<T>,\n  gen?: IdGeneratorFunction<T> | undefined,\n  auto?: boolean,\n  process?: (value: any) => any,\n): ValueType {\n  let value: ValueType\n\n  // Check if this is a composite index by looking at the indexDef\n  const indexDef = collection.indexDefs[key as string]\n  const isCompositeIndex = !!(indexDef?.keys && indexDef.keys.length > 1)\n\n  if (process) {\n    if (isCompositeIndex) {\n      // For composite indexes, pass the entire item to process function\n      value = process(item)\n    } else {\n      // For single key indexes, get the field value first\n      value = get<T>(item as T, key as any) as unknown as ValueType\n      if (value == null && auto) {\n        value = gen?.(item, collection.name, collection.list) ?? value\n        set(item, key as any, value)\n      }\n      // Then apply process to the extracted value\n      value = process(value)\n    }\n  } else {\n    // Fallback for cases without process function\n    value = get<T>(item as T, key as any) as unknown as ValueType\n    if (value == null && auto) {\n      value = gen?.(item, collection.name, collection.list) ?? value\n      set(item, key as any, value)\n    }\n  }\n\n  return value\n}\n",
    "import { get } from 'lodash-es'\nimport { ValueType } from 'b-pl-tree'\n\nexport function get_value(\n  item: any,\n  key: unknown,\n  process?: (value: any) => any,\n): ValueType {\n  if (process) {\n    // If process function exists, it handles both single and composite keys\n    return process(item)\n  }\n\n  // Fallback: extract single key value\n  return get(item, key as any) as unknown as ValueType\n}\n",
    "import { Item } from '../types/Item'\nimport { ValueType } from 'b-pl-tree'\nimport Collection from '../collection'\n\nexport function validate_indexed_value_for_insert<T extends Item>(\n  collection: Collection<T>,\n  value: ValueType,\n  key: string,\n  sparse: boolean,\n  required: boolean,\n  unique: boolean,\n): [boolean, string?] {\n  if (!(sparse && value == null)) {\n    if (required && value == null) {\n      return [false, `value for index ${key} is required, but ${value} is met`]\n    }\n      if (\n    unique &&\n    collection.indexes.hasOwnProperty(key) &&\n    collection.indexes[key].findFirst(value) !== undefined\n  ) {\n    return [false, `unique index ${key} already contains value ${value}`]\n  }\n  }\n  return [true]\n}\n",
    "import { Item } from '../types/Item'\nimport { ValueType } from 'b-pl-tree'\nimport Collection from '../collection'\n\nexport async function validate_indexed_value_for_update<T extends Item>(\n  collection: Collection<T>,\n  value: ValueType,\n  key: string,\n  sparse: boolean,\n  required: boolean,\n  unique: boolean,\n  id: ValueType,\n): Promise<[boolean, string?]> {\n  if (!(sparse && value == null)) {\n    if (required && value == null) {\n      return [false, `value for index ${key} is required, but ${value} is met`]\n    }\n    if (\n      unique &&\n      collection.indexes.hasOwnProperty(key)\n    ) {\n      const existingPosition = collection.indexes[key].findFirst(value)\n      if (existingPosition !== undefined) {\n        // Get the item at that position to check if it's the same item we're updating\n        const existingItem = await collection.list.get(existingPosition)\n        if (existingItem && existingItem[collection.id] !== id) {\n          return [false, `unique index ${key} already contains value ${value}`]\n        }\n      }\n    }\n  }\n  return [true]\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\n\nexport async function ensure_indexes<T extends Item>(\n  collection: Collection<T>,\n) {\n  for (const ensure of collection.ensures) {\n    ensure()\n  }\n}\n",
    "import { get } from 'lodash-es'\nimport { Item } from '../types/Item'\nimport { Paths } from '../types/Paths'\nimport { IndexField } from '../types/IndexDef'\n\n/**\n * Utilities for working with composite keys in indexes\n * Provides serialization, deserialization, and comparison functions\n * Updated to work with unified IndexDef structure\n */\nexport class CompositeKeyUtils {\n  /**\n   * Default separator for composite key serialization\n   * Using null character to avoid conflicts with user data\n   */\n  static readonly DEFAULT_SEPARATOR = '\\u0000'\n\n  /**\n   * Determines if an index definition represents a composite index\n   * @param indexDef Index definition to check\n   * @returns True if composite, false if single key\n   */\n  static isCompositeIndex<T extends Item>(indexDef: {\n    key?: string | Paths<T>\n    keys?: Array<string | Paths<T> | IndexField<T>>\n  }): boolean {\n    return !!(indexDef.keys && indexDef.keys.length > 1)\n  }\n\n  /**\n   * Normalizes index definition to unified IndexField array\n   * @param indexDef Index definition\n   * @returns Array of normalized IndexField objects\n   */\n  static normalizeIndexFields<T extends Item>(indexDef: {\n    key?: string | Paths<T>\n    keys?: Array<string | Paths<T> | IndexField<T>>\n    order?: 'asc' | 'desc'\n  }): Array<IndexField<T>> {\n    // Single key case\n    if (indexDef.key && !indexDef.keys) {\n      return [{\n        key: indexDef.key,\n        order: indexDef.order || 'asc'\n      }]\n    }\n\n    // Multiple keys case\n    if (indexDef.keys) {\n      return indexDef.keys.map(keyDef => {\n        if (typeof keyDef === 'string') {\n          return { key: keyDef, order: 'asc' }\n        } else if (typeof keyDef === 'object' && 'key' in keyDef) {\n          return { key: keyDef.key, order: keyDef.order || 'asc' }\n        } else {\n          return { key: keyDef as Paths<T>, order: 'asc' }\n        }\n      })\n    }\n\n    throw new Error('Invalid index definition: must specify either key or keys')\n  }\n\n  /**\n   * Generates index name from normalized fields or legacy string array\n   * @param input Array of IndexField objects or legacy string array\n   * @returns Generated index name\n   */\n  static generateIndexName(keyPaths: Array<string>): string\n  static generateIndexName<T extends Item>(fields: Array<IndexField<T>>): string\n  static generateIndexName<T extends Item>(\n    input: Array<string> | Array<IndexField<T>>\n  ): string {\n    // Handle legacy string array format\n    if (input.length > 0 && typeof input[0] === 'string') {\n      return (input as string[]).join(',')\n    }\n\n    // Handle new IndexField array format\n    const fields = input as Array<IndexField<T>>\n    if (fields.length === 1) {\n      // Single key: just the key name\n      return String(fields[0].key)\n    }\n\n    // Composite key: include sort order information\n    return fields.map(field => {\n      const keyStr = String(field.key)\n      return field.order === 'desc' ? `${keyStr}:desc` : keyStr\n    }).join(',')\n  }\n\n  /**\n   * Creates a process function for the index\n   * @param fields Normalized index fields\n   * @param separator Separator for composite keys\n   * @returns Process function\n   */\n  static createProcessFunction<T extends Item>(\n    fields: Array<IndexField<T>>,\n    separator: string = CompositeKeyUtils.DEFAULT_SEPARATOR\n  ): ((item: T) => any) | undefined {\n    if (fields.length === 0) {\n      return undefined\n    }\n\n    if (fields.length === 1) {\n      // Single key: extract and return the value\n      const field = fields[0]\n      return (item: T) => get(item, field.key as string)\n    }\n\n    // Composite key: extract values and serialize\n    return (item: T) => {\n      const values = fields.map(field => get(item, field.key as string))\n      return CompositeKeyUtils.serialize(values, separator)\n    }\n  }\n\n  /**\n   * Creates a comparator function for B+ Tree\n   * @param fields Normalized index fields\n   * @param separator Separator for composite keys\n   * @returns Comparator function or undefined for default comparison\n   */\n  static createComparator<T extends Item>(\n    fields: Array<IndexField<T>>,\n    separator: string = CompositeKeyUtils.DEFAULT_SEPARATOR\n  ): ((a: any, b: any) => number) | undefined {\n    if (fields.length === 1) {\n      const field = fields[0]\n      if (field.order === 'desc') {\n        return (a: any, b: any) => {\n          if (a < b) return 1\n          if (a > b) return -1\n          return 0\n        }\n      }\n      // For 'asc' or default, use natural comparison (return undefined)\n      return undefined\n    }\n\n    // Composite key with mixed sort orders\n    return (a: string, b: string): number => {\n      const valuesA = CompositeKeyUtils.deserialize(a, separator)\n      const valuesB = CompositeKeyUtils.deserialize(b, separator)\n\n      for (let i = 0; i < Math.min(valuesA.length, valuesB.length, fields.length); i++) {\n        const field = fields[i]\n        const valueA = valuesA[i]\n        const valueB = valuesB[i]\n\n        // Handle null/undefined values\n        if (valueA === null && valueB === null) continue\n        if (valueA === null) return field.order === 'asc' ? -1 : 1\n        if (valueB === null) return field.order === 'asc' ? 1 : -1\n\n        // Compare values\n        let comparison = 0\n        if (typeof valueA === 'string' && typeof valueB === 'string') {\n          comparison = valueA.localeCompare(valueB)\n        } else if (typeof valueA === 'number' && typeof valueB === 'number') {\n          comparison = valueA - valueB\n        } else if (valueA instanceof Date && valueB instanceof Date) {\n          comparison = valueA.getTime() - valueB.getTime()\n        } else {\n          // Fallback to string comparison\n          comparison = String(valueA).localeCompare(String(valueB))\n        }\n\n        if (comparison !== 0) {\n          return field.order === 'desc' ? -comparison : comparison\n        }\n      }\n\n      return 0\n    }\n  }\n\n    /**\n   * Serializes an array of values into a single string key\n   * @param values Array of values to serialize\n   * @param separator Separator character (default: null character)\n   * @returns Serialized composite key as string\n   */\n  static serialize(values: any[], separator: string = CompositeKeyUtils.DEFAULT_SEPARATOR): string {\n    return values.map(value => {\n      if (value === null || value === undefined) {\n        return ''\n      }\n      // Convert to string and escape separator if it exists in the value\n      const stringValue = String(value)\n      // First escape backslashes, then escape the separator\n      return stringValue\n        .replace(/\\\\/g, '\\\\\\\\')  // Escape backslashes first\n        .replace(new RegExp(separator.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'g'), `\\\\${separator}`)\n    }).join(separator)\n  }\n\n  /**\n   * Deserializes a composite key string back into array of values\n   * @param serialized Serialized composite key string\n   * @param separator Separator character used during serialization\n   * @returns Array of deserialized values\n   */\n  static deserialize(serialized: string, separator: string = CompositeKeyUtils.DEFAULT_SEPARATOR): any[] {\n    if (!serialized) {\n      return []\n    }\n\n    // More robust splitting that handles escaped separators\n    const parts: string[] = []\n    let current = ''\n    let i = 0\n\n    while (i < serialized.length) {\n      if (serialized[i] === '\\\\' && i + 1 < serialized.length) {\n        // Handle escaped character\n        current += serialized[i + 1]\n        i += 2\n      } else if (serialized[i] === separator) {\n        // Found unescaped separator\n        parts.push(current === '' ? null : current)\n        current = ''\n        i++\n      } else {\n        current += serialized[i]\n        i++\n      }\n    }\n\n    // Add the last part\n    parts.push(current === '' ? null : current)\n\n    return parts\n  }\n\n  /**\n   * Compares two composite key strings lexicographically\n   * @param a First composite key\n   * @param b Second composite key\n   * @returns Comparison result (-1, 0, 1)\n   */\n  static compare(a: string, b: string): number {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  }\n\n  /**\n   * Extracts values from an item using the specified key paths\n   * @param item Item to extract values from\n   * @param keyPaths Array of paths to extract\n   * @returns Array of extracted values\n   */\n  static extractValues<T extends Item>(\n    item: T,\n    keyPaths: Array<string | Paths<T>>\n  ): any[] {\n    return keyPaths.map(path => {\n      if (typeof path === 'string') {\n        return get(item, path)\n      }\n      return get(item, path as string)\n    })\n  }\n\n  /**\n   * Creates a composite key from an item using specified paths\n   * @param item Item to create key from\n   * @param keyPaths Array of paths to use for the key\n   * @param separator Separator character\n   * @returns Serialized composite key\n   */\n  static createKey<T extends Item>(\n    item: T,\n    keyPaths: Array<string | Paths<T>>,\n    separator: string = CompositeKeyUtils.DEFAULT_SEPARATOR\n  ): string {\n    const values = CompositeKeyUtils.extractValues(item, keyPaths)\n    return CompositeKeyUtils.serialize(values, separator)\n  }\n\n  /**\n   * Validates that key paths are valid for composite key creation\n   * @param keyPaths Array of paths to validate\n   * @returns True if valid, false otherwise\n   */\n  static validateKeyPaths(keyPaths: Array<string | any>): boolean {\n    if (!Array.isArray(keyPaths) || keyPaths.length === 0) {\n      return false\n    }\n\n    return keyPaths.every(path =>\n      typeof path === 'string' && path.length > 0\n    )\n  }\n\n  /**\n   * Generates a composite index name from key paths\n   * @param keyPaths Array of paths\n   * @returns Generated index name\n   */\n  static generateIndexNameLegacy(keyPaths: Array<string | any>): string {\n    return keyPaths.map(path => String(path)).join(',')\n  }\n\n  /**\n   * Checks if a value represents an empty composite key component\n   * @param value Value to check\n   * @returns True if empty, false otherwise\n   */\n  static isEmptyValue(value: any): boolean {\n    return value === null || value === undefined || value === ''\n  }\n\n  /**\n   * Creates a partial composite key for range queries\n   * @param values Array of values (can be partial)\n   * @param separator Separator character\n   * @returns Partial composite key\n   */\n  static createPartialKey(\n    values: any[],\n    separator: string = CompositeKeyUtils.DEFAULT_SEPARATOR\n  ): string {\n    // Filter out undefined values at the end for partial matching\n    const filteredValues = []\n    for (let i = 0; i < values.length; i++) {\n      if (values[i] !== undefined) {\n        filteredValues.push(values[i])\n      } else {\n        break // Stop at first undefined to maintain order\n      }\n    }\n\n    return CompositeKeyUtils.serialize(filteredValues, separator)\n  }\n\n}",
    "import { IndexDef } from '../types/IndexDef'\nimport { Item } from '../types/Item'\nimport { Dictionary } from '../types/Dictionary'\nimport Collection from '../collection'\nimport { create_index } from './create_index'\n\nexport function build_indexes<T extends Item>(\n  collection: Collection<T>,\n  indexList: Dictionary<IndexDef<T>>,\n): void {\n  for (const key in indexList) {\n    create_index<T>(collection, key, indexList[key])\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport Collection, { ttl_key } from '../collection'\n\nexport function is_valid_ttl<T extends Item>(\n  collection: Collection<T>,\n  item?: T,\n) {\n  if (item) {\n    if (item[ttl_key]) {\n      const now = Date.now()\n      return now - item[ttl_key] <= collection.ttl!\n    } else {\n      return true\n    }\n  } else {\n    return false\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport { ensure_ttl } from './ensure_ttl'\nimport Collection from '../collection'\nimport { is_valid_ttl } from './is_valid_ttl'\n\nexport async function return_list_if_valid<T extends Item>(\n  collection: Collection<T>,\n  items: Array<T>,\n): Promise<Array<T>> {\n  let invalidate: boolean = false\n\n  const result = items.filter((i) => {\n    if (is_valid_ttl(collection, i)) {\n      return true\n    } else {\n      invalidate = true\n      return false\n    }\n  })\n\n  if (invalidate) {\n    if (collection.ttl && collection.list.length > 0) {\n      await ensure_ttl(collection)\n    }\n  }\n  return result\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { return_list_if_valid } from './return_list_if_valid'\nimport { ValueType } from 'b-pl-tree'\n\nexport async function get_indexed_value<T extends Item>(\n  collection: Collection<T>,\n  key: string,\n  value: ValueType,\n): Promise<Array<T>> {\n  const result: Array<T> = []\n  if (collection.indexes[key]) {\n    const keys = collection.indexes[key].find(value)\n    for (const key of keys) {\n      const res = await collection.list.get(key)\n      result.push(res!)\n    }\n  }\n  return return_list_if_valid(collection, result)\n}",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { ensure_ttl } from './ensure_ttl'\nimport { is_valid_ttl } from './is_valid_ttl'\n\nexport async function return_one_if_valid<T extends Item>(\n  collection: Collection<T>,\n  result: T | undefined,\n): Promise<T | undefined> {\n  let invalidate = false\n\n  if (result && !is_valid_ttl(collection, result)) {\n    invalidate = true\n  }\n  if (invalidate) {\n    if (collection.ttl && collection.list.length > 0) {\n      await ensure_ttl(collection)\n    }\n  }\n  return invalidate ? undefined : result\n}\n",
    "import * as _ from 'lodash-es'\nimport { IndexDef } from '../types/IndexDef'\nimport { IndexStored } from '../types/IndexStored'\nimport { Item } from '../types/Item'\nimport { Dictionary } from '../types/Dictionary'\nimport { restore_index_def } from './restore_index_def'\nimport Collection from '../collection'\n\nexport function restore_index<T extends Item>(\n  collection: Collection<T>,\n  input: Dictionary<IndexStored<T>>,\n): Dictionary<IndexDef<T>> {\n  return _.map(input, (index) => {\n    return restore_index_def(collection, index)\n  }).reduce((res, cur) => {\n    res[cur.key] = cur\n    return res\n  }, {} as Dictionary<IndexDef<T>>)\n}\n",
    "import { Item } from '../types/Item'\nimport { IndexDef } from '../types/IndexDef'\nimport { IndexStored } from '../types/IndexStored'\nimport Collection from '../collection'\n\nexport function restore_index_def<T extends Item>(\n  collection: Collection<T>,\n  input: IndexStored<T>,\n): IndexDef<T> {\n  const { key, auto, unique, sparse, required, ignoreCase } = input\n  return {\n    key,\n    auto,\n    unique,\n    sparse,\n    required,\n    ignoreCase,\n    process: ignoreCase\n      ? undefined\n      : input.process\n      ? eval(input.process)\n      : undefined,\n    gen: input.gen\n      ? Collection.genCache[input.gen]\n        ? Collection.genCache[input.gen]\n        : eval(input.gen)\n      : undefined,\n  }\n}\n",
    "import {\n  BPlusTree,\n  ValueType,\n  PortableBPlusTree,\n  serializeTree,\n  deserializeTree,\n  createTreeFrom\n} from 'b-pl-tree'\n\nexport interface SerializedBPlusTree {\n  t: number\n  unique: boolean\n  root: any\n}\n\nexport function serializeBPlusTree<T, K extends ValueType>(\n  tree: BPlusTree<T, K>\n): PortableBPlusTree<T, K> {\n  return serializeTree(tree)\n}\n\nexport function deserializeBPlusTree<T, K extends ValueType>(\n  data: PortableBPlusTree<T, K>\n): BPlusTree<T, K> {\n  return createTreeFrom<T, K>(data)\n}\n\nexport function deserializeBPlusTreeInto<T, K extends ValueType>(\n  tree: BPlusTree<T, K>,\n  data: PortableBPlusTree<T, K>\n): void {\n  deserializeTree(tree, data)\n}\n\nexport function cloneBPlusTree<T, K extends ValueType>(\n  source: BPlusTree<T, K>\n): BPlusTree<T, K> {\n  const serialized = serializeTree(source)\n  return createTreeFrom<T, K>(serialized)\n}",
    "import { Dictionary } from '../types/Dictionary'\nimport { BPlusTree, PortableBPlusTree, ValueType } from 'b-pl-tree'\nimport { deserializeBPlusTree } from '../utils/btree-serialization'\n\nexport function deserialize_indexes(\n  indexes: Dictionary<PortableBPlusTree<any, ValueType>>,\n): Dictionary<BPlusTree<any, ValueType>> {\n  return Object.keys(indexes).reduce((res, cur) => {\n    res[cur] = deserializeBPlusTree(indexes[cur])\n    return res\n  }, {} as Dictionary<BPlusTree<any, ValueType>>)\n}\n",
    "import { Dictionary } from '../types/Dictionary'\nimport { BPlusTree, ValueType, PortableBPlusTree } from 'b-pl-tree'\nimport { serializeBPlusTree } from '../utils/btree-serialization'\n\nexport function serialize_indexes(\n  indexes: Dictionary<BPlusTree<any, ValueType>>,\n): Dictionary<PortableBPlusTree<any, ValueType>> {\n  return Object.keys(indexes).reduce((res, cur) => {\n    res[cur] = serializeBPlusTree(indexes[cur])\n    return res\n  }, {} as Dictionary<PortableBPlusTree<any, ValueType>>)\n}\n",
    "import * as _ from 'lodash-es'\nimport { IndexDef } from '../types/IndexDef'\nimport { IndexStored } from '../types/IndexStored'\nimport { Item } from '../types/Item'\nimport { Dictionary } from '../types/Dictionary'\nimport { store_index_def } from './store_index_def'\nimport Collection from '../collection'\n\nexport function store_index<T extends Item>(\n  collection: Collection<T>,\n  input: Dictionary<IndexDef<T>>,\n): Dictionary<IndexStored<T>> {\n  return _.map(input, (index) => {\n    return store_index_def(collection, index)\n  }).reduce((res, cur) => {\n    res[cur.key as string] = cur\n    return res\n  }, {} as Dictionary<IndexStored<T>>)\n}\n",
    "import { IndexDef } from '../types/IndexDef'\nimport { IndexStored } from '../types/IndexStored'\nimport { Item } from '../types/Item'\nimport Collection from '../collection'\n\nexport function store_index_def<T extends Item>(\n  collection: Collection<T>,\n  input: IndexDef<T>,\n): IndexStored<T> {\n  const { key, auto, unique, sparse, required, ignoreCase } = input\n  return {\n    key,\n    auto,\n    unique,\n    sparse,\n    required,\n    ignoreCase,\n    process: ignoreCase\n      ? undefined\n      : input.process\n      ? input.process.toString()\n      : undefined,\n    gen: input.gen\n      ? Collection.genCache[input.gen.name]\n        ? input.gen.name\n        : input.gen.toString()\n      : undefined,\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport { build_indexes } from './build_indexes'\nimport { ensure_indexes } from './ensure_indexes'\nimport Collection from '../collection'\n\nexport async function copy_collection<T extends Item>(\n  model: string,\n  source: Collection<T>,\n  dest?: Collection<T>,\n): Promise<Collection<T>> {\n  const collection =\n    dest ??\n    Collection.create<T>({\n      root: source.root,\n      name: model,\n      adapter: source.storage.clone(),\n      list: source.list.construct(),\n      // id: source.id,\n      // ttl: source.ttl,\n    })\n\n  collection.indexDefs = source.indexDefs\n  collection.id = source.id\n  collection.ttl = source.ttl\n\n  collection.inserts = []\n  collection.removes = []\n  collection.updates = []\n  collection.ensures = []\n\n  collection.indexes = {}\n  build_indexes(collection, collection.indexDefs)\n  await ensure_indexes(collection)\n  for await (const item of source.list.forward) {\n    await collection.push(item)\n  }\n  await collection.persist()\n  return collection\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { copy_collection } from './copy_collection'\n\nexport async function do_rotate_log<T extends Item>(\n  source: Collection<T>,\n): Promise<void> {\n  await copy_collection(`${source.name}.${new Date().toJSON()}`, source)\n\n  await source.reset()\n  await source.persist()\n}\n",
    "import { Paths } from '../types/Paths'\nimport { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { return_one_if_valid } from './return_one_if_valid'\nimport { ValueType } from 'b-pl-tree'\n\nexport async function get_first_indexed_value<T extends Item>(\n  collection: Collection<T>,\n  key: Paths<T>,\n  value: ValueType,\n): Promise<T | undefined> {\n  if (collection.indexes[key]) {\n    const id = collection.indexes[key].findFirst(value)\n    const result: T | undefined =\n      id != null ? await collection.list.get(id) : undefined\n    return return_one_if_valid(collection, result)\n  }\n}\n",
    "import { Paths } from '../types/Paths'\nimport { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { return_one_if_valid } from './return_one_if_valid'\nimport { ValueType } from 'b-pl-tree'\n\nexport async function get_last_indexed_value<T extends Item>(\n  collection: Collection<T>,\n  key: Paths<T>,\n  value: ValueType,\n): Promise<T | undefined> {\n  if (collection.indexes[key]) {\n    const id = collection.indexes[key].findLast(value)\n    const result = id != null ? await collection.list.get(id) : undefined\n    return return_one_if_valid(collection, result)\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\n\nexport async function rebuild_indexes<T extends Item>(\n  collection: Collection<T>,\n) {\n  for (const reduild of collection.rebuilds) {\n    await reduild()\n  }\n}\n",
    "import { ValueType } from 'b-pl-tree'\nimport { get, set, unset, cloneDeep } from 'lodash-es'\nimport { StoredIList } from '../types/StoredIList'\nimport { Item } from '../types/Item'\nimport { IList } from '../IList'\nimport Collection from '../collection'\nimport { entity_create } from '../utils/entity_create'\nimport { entity_update } from '../utils/entity_update'\nimport { entity_delete } from '../utils/entity_delete'\nimport { is_stored_record } from '../utils/is_stored_record'\nimport { IStoredRecord } from '../types/IStoredRecord'\n\nexport class List<T extends Item> implements IList<T> {\n  get name() {\n    return 'List' as const\n  }\n  singlefile: boolean = true\n  hash: { [key: string]: T } = {}\n  _counter: number = 0\n  _count: number = 0\n  collection!: Collection<T>\n  exists: Promise<boolean> = Promise.resolve(true)\n\n  init(collection: Collection<T>): IList<T> {\n    this.collection = collection\n    return this as IList<T>\n  }\n\n  async clone(): Promise<IList<T>> {\n    const list = new List<T>()\n    list.load(this.persist())\n    return list\n  }\n\n  async get(key: ValueType) {\n    const item = get(this.hash, String(key))\n    let result: T\n    if (is_stored_record<T>(item)) {\n      result = cloneDeep<T>(item.data!)\n      if (!this.collection.audit) {\n        set(this.hash, String(key), result)\n      }\n    } else {\n      result = cloneDeep(item)\n    }\n    return result\n  }\n\n  get counter() {\n    return this._counter\n  }\n\n  get length() {\n    return Object.keys(this.hash).length\n  }\n\n  set length(len) {\n    if (len === 0) {\n      this.reset()\n    }\n  }\n\n  async set(key: ValueType, item: T) {\n    let valiadtor = this.collection.validator(item)\n    if (valiadtor.success) {\n      let result: T | IStoredRecord<T>\n      if (this.collection.audit) {\n        result = entity_create(\n          item[this.collection.id],\n          cloneDeep(item),\n          this.collection.validation,\n        )\n      } else {\n        result = cloneDeep(item)\n      }\n\n      const keyStr = String(key)\n      const exists = Object.prototype.hasOwnProperty.call(this.hash, keyStr)\n\n      // Use the provided key instead of _counter\n      set(this.hash, keyStr, result)\n\n      // Only increment counters if this is a new key\n      if (!exists) {\n        this._counter++\n        this._count++\n      }\n\n      return is_stored_record(item) ? item.data : item\n    }\n    throw new Error('Validation error')\n  }\n\n  async update(key: ValueType, item: T) {\n    let valiadtor = this.collection.validator(item)\n    if (valiadtor.success) {\n      let result: T = item\n      const record = get(this.hash, String(key))\n      if (this.collection.audit) {\n        let res: T | IStoredRecord<T>\n        if (!is_stored_record(record)) {\n          res = entity_create(\n            item[this.collection.id],\n            item,\n            this.collection.validation,\n          )\n        } else {\n          res = entity_update(record, cloneDeep(item))\n        }\n        set(this.hash, String(key), res)\n        result = res.data\n      } else {\n        set(this.hash, String(key), cloneDeep(result))\n      }\n      return result\n    }\n    throw new Error('Validation error')\n  }\n\n  async delete(i: ValueType) {\n    const item = get(this.hash, i?.toString() ?? 'undefined')\n    let result: T\n    if (is_stored_record<T>(item)) {\n      entity_delete(item)\n      result = cloneDeep(item.data)\n      this._count--\n    } else {\n      unset(this.hash, i?.toString() ?? 'undefined')\n      this._count--\n      result = cloneDeep(item)\n    }\n    return result\n  }\n\n  async reset() {\n    this._count = 0\n    this._counter = 0\n    this.hash = {}\n  }\n\n  get keys() {\n    return Object.keys(this.hash)\n  }\n\n  load(obj: StoredIList): IList<T> {\n    this.hash = obj.hash\n    this._count = obj._count\n    this._counter = obj._counter\n    return this\n  }\n\n  construct() {\n    return new List<T>()\n  }\n\n  persist(): StoredIList {\n    return {\n      counter: this._counter,\n      tree: {} as any, // List doesn't use tree, but interface requires it\n      _count: this._count,\n      _counter: this._counter,\n      hash: this.hash,\n    }\n  }\n\n  get forward(): AsyncIterable<T> {\n    return {\n      [Symbol.asyncIterator]: () => this.toArray(),\n    }\n  }\n  get backward(): AsyncIterable<T> {\n    return {\n      [Symbol.asyncIterator]: () => this.toArrayReverse(),\n    }\n  }\n\n  async *toArray() {\n    for (const key of this.keys) {\n      yield get(this.hash, key)\n    }\n  }\n  async *toArrayReverse() {\n    for (const key of this.keys.reverse()) {\n      yield get(this.hash, key)\n    }\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport { ValueType } from 'b-pl-tree'\nimport { diff } from 'jsondiffpatch'\nimport { IStoredRecord } from '../types/IStoredRecord'\nimport { version_create } from './version_create'\nimport { ZodType } from 'zod'\n\nexport function entity_create<T extends Item>(\n  id: ValueType,\n  item: T,\n  schema?: ZodType<T>,\n): IStoredRecord<T> {\n  return {\n    id,\n    version: 0,\n    next_version: 1,\n    data: item,\n    created: Date.now(),\n    updated: undefined,\n    deleted: undefined,\n    schema,\n    history: [version_create(0, diff({}, item)!)],\n  }\n}\n",
    "import { Delta } from 'jsondiffpatch'\nimport { IVersion } from '../types/IVersion'\n\nexport function version_create(version: number, delta: Delta): IVersion {\n  return {\n    version,\n    delta,\n    date: Date.now(),\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport { diff } from 'jsondiffpatch'\nimport { IStoredRecord } from '../types/IStoredRecord'\nimport { version_create } from './version_create'\n\nexport function entity_update<T extends Item>(\n  record: IStoredRecord<T>,\n  item: T,\n): IStoredRecord<T> {\n  const delta = diff(record.data, item)\n  const v = version_create(record.next_version, delta!)\n  record.history.push(v)\n  return {\n    ...record,\n    data: item,\n    updated: Date.now(),\n    next_version: record.next_version + 1,\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport { diff } from 'jsondiffpatch'\nimport { IStoredRecord } from '../types/IStoredRecord'\nimport { version_create } from './version_create'\n\nexport function entity_delete<T extends Item>(\n  record: IStoredRecord<T>,\n): IStoredRecord<T> {\n  const delta = diff({}, record.data)\n  const v = version_create(record.next_version, delta!)\n  record.history.push(v)\n  return {\n    ...record,\n    data: {} as T,\n    deleted: Date.now(),\n    next_version: record.next_version + 1,\n  }\n}\n",
    "import { IStoredRecord } from '../types/IStoredRecord'\nimport { Item } from '../types/Item'\n\nexport function is_stored_record<T extends Item>(item: T | IStoredRecord<T>): item is IStoredRecord<T> {\n  if (!item || typeof item !== 'object') return false\n  return (\n    Object.prototype.hasOwnProperty.call(item, 'version') &&\n    typeof (item as any).version === 'number' &&\n    Object.prototype.hasOwnProperty.call(item, 'next_version') &&\n    typeof (item as any).next_version === 'number' &&\n    Object.prototype.hasOwnProperty.call(item, 'created') &&\n    typeof (item as any).created === 'number' &&\n    Object.prototype.hasOwnProperty.call(item, 'history') &&\n    Array.isArray((item as any).history)\n  )\n}\n",
    "import Collection from './collection'\nimport { Item } from './types/Item'\nimport { IStorageAdapter } from './IStorageAdapter'\n\nexport default class AdapterMemory<T extends Item>\n  implements IStorageAdapter<T>\n{\n  get name() {\n    return 'AdapterMemory' as const\n  }\n  collection!: Collection<T>\n  clone(): AdapterMemory<T> {\n    return new AdapterMemory<T>()\n  }\n\n  init(collection: Collection<T>): this {\n    this.collection = collection\n    return this\n  }\n\n  restore(name?: string): Promise<any> {\n    return Promise.resolve({})\n  }\n\n  store(name: string) {\n    return Promise.resolve()\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport { ISerializedCollectionConfig } from '../ICollectionConfig'\nimport Collection, { serializeIndex } from '../collection'\n\nexport function serialize_collection_config<T extends Item>(\n  collection: Collection<T>,\n): ISerializedCollectionConfig {\n  const res: ISerializedCollectionConfig = {} as ISerializedCollectionConfig\n  res.audit = collection.audit ? true : undefined\n  res.root = collection.root\n  res.rotate = collection.rotate ?? undefined\n  res.ttl = collection.ttl ? collection.ttl : undefined\n  res.name = collection.name\n  res.adapter = collection.storage.name\n  res.list = collection.list.name\n  res.id = collection.id || 'id'\n  res.auto = collection.auto ?? undefined\n  // Ð´Ð¾Ð±Ð°Ð²Ð¸ÑÑ ÑÐµÑÐ¸Ð°Ð»Ð¸Ð·Ð°ÑÐ¸Ñ ÑÑÐµÐ¼Ñ\n  // Ð¸Ð»Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ñ ajv??\n  res.indexList = Object.keys(collection.indexDefs).map((name) => {\n    const res = collection.indexDefs[name]\n    return serializeIndex<T>(res)\n  })\n  return res\n}\n",
    "import { ValueType, BPlusTree } from 'b-pl-tree'\nimport { StoredIList } from '../types/StoredIList'\nimport { Item } from '../types/Item'\nimport fs from 'fs-extra'\nimport pathlib from 'path'\nimport { IList } from '../IList'\nimport Collection from '../collection'\nimport { entity_delete } from '../utils/entity_delete'\nimport { entity_update } from '../utils/entity_update'\nimport { IStoredRecord } from '../types/IStoredRecord'\nimport { entity_create } from '../utils/entity_create'\nimport { is_stored_record } from '../utils/is_stored_record'\nimport { cloneDeep } from 'lodash-es'\nimport { fromZodError } from 'zod-validation-error'\nimport { cloneBPlusTree, serializeBPlusTree, deserializeBPlusTree } from '../utils/btree-serialization'\n\nexport class FileStorage<T extends Item>\n  implements IList<T>\n{\n  get name() {\n    return 'FileStorage' as const\n  }\n  singlefile: boolean = false\n\n  //  ÑÑÐ°Ð½Ð¸ÑÑ Ð¿ÑÐ¾Ð¼Ð¸ÑÑ ÑÐ¸Ð¿Ð° ÐºÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ Ð´Ð°Ð½Ð½ÑÑ Ðº ÐºÐ¾ÑÐ¾ÑÑÐ¼ Ð±ÑÐ» Ð´Ð¾ÑÑÑÐ¿, Ð¸ ÐºÐ¾ÑÐ¾ÑÑÐµ Ð½Ðµ Ð¾Ð±Ð½Ð¾Ð²Ð»ÑÐ»Ð¸ÑÑ\n  // Ð° Ð½Ð° Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð²ÑÑÑÐ°Ð²Ð»ÑÑÑ Ð½Ð¾Ð²ÑÐ¹ Ð¿ÑÐ¾Ð¼Ð¸Ñ\n  // ÑÐ°ÐºÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼ Ð´Ð°Ð½Ð½ÑÐµ Ð²ÑÐµÐ³Ð´Ð° Ð±ÑÐ´ÑÑ ÑÐ²ÐµÐ¶Ð¸Ð¼Ð¸... ÐµÑÐ»Ð¸ Ð½ÐµÑ Ð´ÑÑÐ³Ð¾Ð³Ð¾ ÑÐ¸ÑÐ°ÑÐµÐ»Ñ Ð¿Ð¸ÑÐ°ÑÐµÐ»Ñ ÑÐ°Ð¹Ð»Ð¾Ð²\n  // Ð¼Ð¾Ð¶Ð½Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÑ Ð´Ð»Ñ Ð¼Ð¾Ð½Ð¸ÑÑÐ¾Ð¸Ð½Ð³Ð° Ð·Ð° ÑÐ°Ð¹Ð»Ð°Ð¼Ð¸\n  tree: BPlusTree<string, ValueType> = new BPlusTree(32, true)\n  get folder(): string {\n    return pathlib.join(this.collection.root, this.collection.name)\n  }\n  private keyField?: string\n  constructor(keyField?: string) {\n    this.keyField = keyField\n  }\n  exists!: Promise<boolean>\n  collection!: Collection<T>\n  construct() {\n    return new FileStorage<T>()\n  }\n\n  init(collection: Collection<T>): IList<T> {\n    this.collection = collection\n    if (this.keyField && !this.collection.indexDefs[this.keyField].unique) {\n      throw new Error(`key field ${this.keyField} is not unique`)\n    }\n    this.exists = fs\n      .ensureDir(this.folder)\n      .then((_) => true)\n      .catch((_) => false)\n    return this\n  }\n  async clone(): Promise<IList<T>> {\n    if (await this.exists) {\n      const res = new FileStorage<T>()\n      res.tree = cloneBPlusTree(this.tree)\n      return res\n    }\n    throw new Error('folder not found')\n  }\n  persist(): StoredIList {\n    return {\n      keyField: this.keyField,\n      counter: this._counter,\n      tree: serializeBPlusTree(this.tree),\n    }\n  }\n\n  load(obj: StoredIList): IList<T> {\n    this._counter = obj.counter\n    // prefer name that in configuration\n    this.keyField = !obj.keyField\n      ? this.keyField\n      : this.keyField\n      ? this.keyField\n      : obj.keyField\n    this.tree = deserializeBPlusTree(obj.tree)\n    return this\n  }\n\n  get forward() {\n    return {\n      [Symbol.asyncIterator]: () => this.toArray(),\n    }\n  }\n\n  get backward() {\n    return {\n      [Symbol.asyncIterator]: () => this.toArrayReverse(),\n    }\n  }\n\n  async *toArray() {\n    const res = await this.exists\n    if (res) {\n      const it = this.tree.each()(this.tree)\n      let cursor = it.next()\n      while (!cursor.done && cursor.value) {\n        yield await fs.readJSON(this.get_path(cursor.value.value))\n        cursor = it.next()\n      }\n    } else throw new Error('folder not found')\n  }\n\n  async *toArrayReverse() {\n    if (await this.exists) {\n      const it = this.tree.each(false)(this.tree)\n      let cursor = it.next()\n      while (!cursor.done && cursor.value) {\n        yield await fs.readJSON(this.get_path(cursor.value.value))\n        cursor = it.next()\n      }\n    } else throw new Error('folder not found')\n  }\n\n  private key_filename(key: ValueType) {\n    return `${key?.toString() ?? 'undefined'}.json`\n  }\n\n  private set_path(key: ValueType) {\n    return pathlib.join(this.folder, this.key_filename(key))\n  }\n\n  private get_path(value: string) {\n    return pathlib.join(this.folder, value)\n  }\n\n  async reset(): Promise<void> {\n    if (await this.exists) {\n      await fs.remove(this.folder)\n      this.tree.reset()\n      this.exists = fs\n        .ensureDir(this.folder)\n        .then((_) => true)\n        .catch((_) => false)\n    } else throw new Error('folder not found')\n  }\n\n  async get(key: ValueType): Promise<T | undefined> {\n    if (await this.exists) {\n      const value = this.tree.findFirst(key)\n      if (value) {\n        const location = this.get_path(value)\n        const result: T | IStoredRecord<T> = await fs.readJSON(location)\n        if (is_stored_record(result)) {\n          if (!this.collection.audit) {\n            await fs.writeJSON(location, result)\n          }\n          return result.data\n        } else {\n          return result\n        }\n      }\n    }\n    throw new Error('folder not found')\n  }\n\n  async set(key: ValueType, item: T): Promise<T> {\n    if (await this.exists) {\n      let valiadtor = this.collection.validator(item)\n      if (valiadtor.success) {\n        this._counter++\n        // checkif exists\n        // Ð±ÐµÑÐµÐ¼ Ð½Ð¾Ð²ÑÐ¹ ÐºÐ»ÑÑ\n        const uid = this.keyField\n          ? item[this.keyField]\n            ? item[this.keyField]\n            : key\n          : key\n\n        // Ð¿Ð¸ÑÐµÐ¼ Ð² ÑÐ°Ð¹Ð»\n\n        let result: T | IStoredRecord<T>\n        if (this.collection.audit) {\n          result = entity_create(\n            item[this.collection.id],\n            cloneDeep(item),\n            this.collection.validation,\n          )\n        } else {\n          result = cloneDeep(item)\n        }\n\n        await fs.writeJSON(this.set_path(uid), result)\n        // Ð²ÑÑÐ°Ð²Ð»ÑÐµÐ¼ Ð² ÑÑÐ°Ð½Ð¸Ð»Ð¸ÑÐµ\n        this.tree.insert(key, this.key_filename(uid))\n        return this.collection.audit ? (result as IStoredRecord<T>).data : (result as T)\n      } else {\n        console.log(fromZodError((valiadtor as any).errors))\n        throw new Error('Validation error')\n      }\n    }\n    throw new Error('folder not found')\n  }\n\n  async update(key: ValueType, item: T): Promise<T> {\n    // checkif exists\n    if (await this.exists) {\n      let valiadtor = this.collection.validator(item)\n      if (valiadtor.success) {\n        // Ð¸ÑÐµÐ¼ ÑÐµÐºÑÑÐµÐµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ ÑÐ°Ð¹Ð»Ð°\n        const location = this.get_path(this.tree.findFirst(key))\n        let result: T = item\n\n        const record = (await fs.readJSON(location)) as T\n        if (this.collection.audit) {\n          let res: T | IStoredRecord<T>\n          if (!is_stored_record(record)) {\n            res = entity_create(\n              item[this.collection.id],\n              cloneDeep(item),\n              this.collection.validation,\n            )\n          } else {\n            res = entity_update<T>(record, cloneDeep(item))\n          }\n          result = res.data\n          await fs.writeJSON(location, res)\n        } else {\n          // Ð·Ð°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ Ð² ÑÐ°Ð¹Ð»\n          await fs.writeJSON(location, result)\n        }\n        return result\n      } else {\n        console.log(fromZodError((valiadtor as any).errors))\n        throw new Error('Validation error')\n      }\n    }\n    throw new Error('folder not found')\n  }\n\n  async delete(key: ValueType): Promise<T> {\n    if (await this.exists) {\n      const value = this.tree.findFirst(key)\n      if (value) {\n        const location = this.get_path(value)\n        const item = await fs.readJSON(location)\n        let result: T\n        if (is_stored_record<T>(item)) {\n          result = item.data\n          const res = entity_delete(item)\n          await fs.writeJSON(location, res)\n        } else {\n          result = item\n          await fs.unlink(location)\n        }\n        this.tree.remove(key)\n        return result\n      }\n    }\n    throw new Error('folder not found')\n  }\n\n  _counter: number = 0\n  get counter(): number {\n    return this._counter\n  }\n  get length(): number {\n    return this.tree.size\n  }\n}\n",
    "import fs from 'fs'\nimport path from 'path'\nimport fse from 'fs-extra'\nimport { ICollectionConfig, ISerializedCollectionConfig } from './ICollectionConfig'\nimport { IDataCollection } from './IDataCollection'\nimport Collection from './collection'\nimport { Item } from './types/Item'\n\nimport AdapterFile from './AdapterFile'\nimport { deserialize_collection_config } from './collection/deserialize_collection_config'\nimport { serialize_collection_config } from './collection/serialize_collection_config'\nimport { FileStorage } from './storage/FileStorage'\nimport { List } from './storage/List'\nimport { IndexDef } from './types/IndexDef'\n\n// biome-ignore lint/complexity/noBannedTypes: Ð±ÑÐ´ÐµÑ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½\nexport type TransactionOptions = {}\n\nexport interface CSTransaction {\n  startTransaction(options: TransactionOptions): Promise<void>\n  abortTransaction(): Promise<void>\n  commitTransaction(): Promise<void>\n  endSession(): Promise<void>\n}\n\nexport class CSDatabase implements CSTransaction {\n  private root: string\n  private name: string\n  private inTransaction = false\n  private collections: Map<string, Collection<any>>\n\n  constructor(root: string, name?: string) {\n    this.root = root\n    this.name = name || 'default'\n    this.collections = new Map()\n  }\n\n  private async writeSchema() {\n    const result = {} as Record<string, ISerializedCollectionConfig>\n    this.collections.forEach((collection, name) => {\n      result[name] = serialize_collection_config(collection)\n    })\n    await fse.ensureDir(this.root)\n    fs.writeFileSync(path.join(this.root, `${this.name}.json`), JSON.stringify(result, null, 2))\n  }\n\n  async connect() {\n    await this.load()\n  }\n\n  async load() {\n    const exists = fs.existsSync(path.join(this.root, `${this.name}.json`))\n    if (!exists) {\n      fse.ensureDirSync(this.root)\n    } else {\n      const result = fse.readJSONSync(path.join(this.root, `${this.name}.json`)) as Record<\n        string,\n        ISerializedCollectionConfig\n      >\n\n      this.collections.clear()\n      for (const name in result) {\n        const config = result[name]\n        const collection = Collection.create(deserialize_collection_config(config))\n        await collection.load()\n        this.registerCollection(collection)\n      }\n    }\n  }\n\n  async close() {}\n\n  collectionList: Map<string, ICollectionConfig<any>> = new Map()\n\n  private registerCollection(collection: Collection<any>) {\n    if (!this.collections.has(collection.name)) {\n      this.collections.set(collection.name, collection)\n      return\n    }\n    throw new Error(`collection ${collection.name} already exists`)\n  }\n\n  async createCollection<T extends Item>(name: string): Promise<IDataCollection<T>> {\n    const [, collectionType = 'List'] = name.split(':')\n    const collection = Collection.create({\n      name,\n      list: collectionType === 'List' ? new List<T>() : new FileStorage<T>(),\n      adapter: new AdapterFile<T>(),\n      root: path.join(this.root, this.name),\n    })\n\n    this.registerCollection(collection)\n    await this.writeSchema()\n    return collection\n  }\n\n  listCollections(): Array<IDataCollection<any>> {\n    const result: Array<IDataCollection<any>> = []\n    this.collections.forEach((collection) => {\n      result.push(collection)\n    })\n    return result\n  }\n\n  async dropCollection(name: string): Promise<boolean> {\n    let result = false\n    if (this.collections.has(name)) {\n      const collection = this.collections.get(name)!\n      await collection.reset()\n      result = this.collections.delete(name)\n      await this.writeSchema()\n    }\n    return result\n  }\n\n  collection<T extends Item>(name: string): IDataCollection<T> | undefined {\n    if (this.collections.has(name)) {\n      return this.collections.get(name)\n    }\n    throw new Error(`collection ${name} not found`)\n  }\n\n  async createIndex(collection: string, name: string, def: IndexDef<any>) {\n    if (this.collections.has(collection)) {\n      const col = this.collections.get(collection)!\n      if (col.listIndexes(name)) {\n        col.dropIndex(name)\n        await col.createIndex(name, def)\n      }\n      await this.writeSchema()\n      return\n    }\n    throw new Error(`collection ${collection} not found`)\n  }\n\n  async dropIndex(collection: string, name: string) {\n    if (this.collections.has(collection)) {\n      this.collections.get(collection)?.dropIndex(name)\n      await this.writeSchema()\n      return\n    }\n    throw new Error(`collection ${collection} not found`)\n  }\n\n  async persist() {\n    const res: Array<Promise<void>> = []\n    this.collections.forEach((collection) => {\n      res.push(collection.persist())\n    })\n    return Promise.all(res)\n  }\n\n  async startSession(): Promise<CSTransaction> {\n    if (!this.inTransaction) {\n      await this.persist()\n    }\n    return this\n  }\n\n  async endSession(): Promise<void> {\n    this.inTransaction = false\n  }\n  async startTransaction(options: TransactionOptions): Promise<void> {\n    this.inTransaction = true\n  }\n  async abortTransaction(): Promise<void> {\n    this.inTransaction = false\n  }\n  async commitTransaction(): Promise<void> {\n    // Ð¿ÑÐ¾Ð²ÐµÑÑÑÑ ÐºÐ°ÐºÐ¸Ðµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ Ð±ÑÐ»Ð¸ Ð²Ð½ÐµÑÐµÐ½Ñ, ÑÑÐ¾ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ð»Ð¾ÑÑ Ð¸ ÑÐ¾Ð·Ð´Ð°Ð²Ð°ÑÑ ÑÑÐ°Ð½Ð·Ð°ÐºÑÐ¸Ñ Ð´Ð»Ñ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ\n    await this.persist()\n    this.inTransaction = false\n  }\n  // extra operations\n\n  async first(collection: string): Promise<any> {\n    return this.collections.get(collection)!.first()\n  }\n  async last(collection: string): Promise<any> {\n    return this.collections.get(collection)!.last()\n  }\n  async lowest(collection: string, key: string): Promise<any> {\n    return this.collections.get(collection)!.lowest(key)\n  }\n  async greatest(collection: string, key: string): Promise<any> {\n    return this.collections.get(collection)!.greatest(key)\n  }\n  async oldest(collection: string): Promise<any> {\n    return this.collections.get(collection)!.oldest()\n  }\n  async latest(collection: string): Promise<any> {\n    return this.collections.get(collection)!.latest()\n  }\n  async findById(collection: string, id: any) {\n    return this.collections.get(collection)!.findById(id)\n  }\n  async findBy(collection: string, key: string, id: any) {\n    return this.collections.get(collection)!.findBy(key, id)\n  }\n  async findFirstBy(collection: string, key: string, id: any) {\n    return this.collections.get(collection)!.findFirstBy(key, id)\n  }\n  async findLastBy(collection: string, key: string, id: any) {\n    return this.collections.get(collection)!.findLastBy(key, id)\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport {\n  ICollectionConfig,\n  ISerializedCollectionConfig,\n} from '../ICollectionConfig'\nimport { List } from '../storage/List'\nimport AdapterMemory from '../AdapterMemory'\nimport AdapterFile from '../AdapterFile'\nimport { FileStorage } from '../storage/FileStorage'\nimport { deserializeIndex } from '../collection'\n\nexport function deserialize_collection_config<T extends Item>(\n  config: ISerializedCollectionConfig,\n) {\n  const res = {} as ICollectionConfig<T>\n  res.name = config.name\n  res.root = config.root\n  res.rotate = config.rotate\n  res.ttl = config.ttl\n  res.audit = config?.audit ?? false\n  res.id = config.id || 'id'\n  res.auto = config.auto\n  res.indexList = config.indexList.map((index) => deserializeIndex<T>(index))\n  res.adapter =\n    config.adapter === 'AdapterMemory' ? new AdapterMemory() : new AdapterFile()\n  res.list =\n    config.list === 'List' ? new List<T>() : new FileStorage<T>()\n  return res\n}\n"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAoB,IAApB;AACe,IAAf;AAAA;AAKA,MAAqB,YAA0D;AAAA,MACzE,IAAI,GAAG;AAAA,IACT,OAAO;AAAA;AAAA,MAEL,IAAI,GAAW;AAAA,IACjB,IAAI,KAAK,WAAW,KAAK,YAAY;AAAA,MACnC,OAAO,oBAAQ,KAAK,KAAK,WAAW,MAAM,GAAG,KAAK,WAAW,WAAW;AAAA,IAC1E;AAAA,IACA,OAAO,oBAAQ,KAAK,KAAK,WAAW,MAAM,KAAK,WAAW,MAAM,eAAe;AAAA;AAAA,EAEjF;AAAA,EACA,KAAK,GAAG;AAAA,IACN,OAAO,IAAI;AAAA;AAAA,EAGb,IAAI,CAAC,aAA2B;AAAA,IAC9B,KAAK,aAAa;AAAA,IAClB,OAAO;AAAA;AAAA,OAGH,QAAO,CAAC,OAAe;AAAA,IAC3B,IAAI,OAAO,KAAK;AAAA,IAChB,IAAI,OAAM;AAAA,MACR,MAAM,IAAI,KAAK,oBAAQ,MAAM,KAAK,IAAI,EAAE;AAAA,MACxC,EAAE,OAAO;AAAA,MACT,OAAO,EAAE;AAAA,MACT,OAAO,oBAAQ,OAAO,CAAC;AAAA,IACzB;AAAA,IACA,IAAI,wBAAG,eAAe,IAAI,GAAG;AAAA,MAC3B,OAAO,wBAAG,SAAS,IAAI;AAAA,IACzB;AAAA,IACA,OAAO;AAAA;AAAA,OAGH,MAAK,CAAC,OAAc;AAAA,IACxB,IAAI,OAAO,KAAK;AAAA,IAChB,IAAI,OAAM;AAAA,MACR,MAAM,IAAI,KAAK,oBAAQ,MAAM,KAAK,IAAI,EAAE;AAAA,MACxC,EAAE,OAAO;AAAA,MACT,OAAO,EAAE;AAAA,MACT,OAAO,oBAAQ,OAAO,CAAC;AAAA,IACzB;AAAA,IACA,MAAM,wBAAG,WAAW,IAAI;AAAA,IAExB,MAAM,wBAAG,UAAU,MAAM,KAAK,WAAW,MAAM,GAAG;AAAA,MAChD,QAAQ;AAAA,IACV,CAAC;AAAA;AAEL;;;ACtDA,IAAM,QAAQ;AAAA,EACZ,IAAG;AAAA,EACH,IAAI;AAAA,EACJ,GAAG,OAAO;AAAA,EACV,GAAG,OAAO,OAAO;AAAA,EACjB,GAAG,OAAO,OAAO,KAAK;AAAA,EACtB,GAAG,OAAO,OAAO,KAAK,KAAK;AAAA,EAC3B,GAAG,OAAO,OAAO,KAAK,KAAK,KAAK;AAClC;AAEA,SAAwB,KAAK,CAAC,KAAa,aAAiC,MAAM;AAAA,EAChF,IAAI,oBAAoB;AAAA,EAExB,MAAM,SAAS,IAAI,YAAY,EAAE,MAAM,sBAAsB;AAAA,EAE7D,IAAI,WAAW,MAAM;AAAA,IACnB,WAAW,KAAK,QAAQ;AAAA,MACtB,MAAM,QAAQ,WAAW,EAAE,MAAM,WAAW,EAAG,EAAE;AAAA,MACjD,MAAM,OAAO,EAAE,MAAM,SAAS,EAAG;AAAA,MAEjC,qBAAqB,gBAAgB,OAAO,IAAI;AAAA,IAClD;AAAA,EACF;AAAA,EAEA,OAAO,oBAAoB,MAAM;AAAA;AAGnC,SAAS,eAAe,CAAC,OAAe,MAA0B;AAAA,EAChE,MAAM,SAAS,MAAM;AAAA,EAErB,IAAI,QAAQ;AAAA,IACV,OAAO,QAAQ;AAAA,EACjB;AAAA,EAEA,MAAM,IAAI,MAAM,aAAa,+BAA+B;AAAA;;;AChC3C,IAAnB;;;ACCO,SAAS,YAA4B,CAC1C,MACA,OACA,OACA;AAAA,EACA,OAAO,MAAK;AAAA;;;ACLP,SAAS,aAA6B,CAC3C,MACA,OACA,OACA;AAAA,EACA,OAAO,KAAK,IAAI;AAAA;;;ACRA,IAAlB;AAQO,IAAM,aAAa,aACvB,OAAO;AAAA,EACN,WAAW,aAAE,OAAO,EAAE,SAAS;AAAA,EAC/B,IAAI,aAAE,MAAM,CAAC,aAAE,OAAO,GAAG,aAAE,OAAO,CAAC,CAAC,EAAE,SAAS;AACjD,CAAC,EACA,YAAY;;;AHIS,IAAxB;;;AIeO,SAAS,eAAe,CAAC,OAAoC;AAAA,EAClE,OACE,SAAS,OAAO,UAAU,YAAY,OAAO,MAAM,aAAa;AAAA;AAAA;AAK7D,MAAM,2BAA2B,MAAM;AAAA,EACnC;AAAA,EACT;AAAA,EACA;AAAA,EAEA,WAAW,CAAC,SAAiB,UAAkB,OAAa;AAAA,IAE1D,IAAI,cAAc;AAAA,IAClB,IAAI,UAAU,WAAW;AAAA,MACvB,IAAI;AAAA,QACF,cAAc,KAAK,UACjB,OACA,CAAC,MAAM,QAAS,OAAO,QAAQ,WAAW,IAAI,SAAS,IAAI,GAC7D;AAAA,QACA,OAAO,GAAG;AAAA,QACV,cAAc,OAAO,KAAK;AAAA;AAAA,IAE9B;AAAA,IACA,MACE,GAAG,aAAa,UAAU,cAAc,YAAY,iBAAiB,IACvE;AAAA,IACA,KAAK,OAAO;AAAA,IACZ,KAAK,WAAW;AAAA,IAChB,KAAK,QAAQ;AAAA;AAEjB;;ACvDO,MAAM,YAAuC;AAAA,EAClD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,YAA0B;AAAA,IACpC,KAAK,MAAM,QAAQ,UAAU,GAAG;AAAA,MAC9B,MAAM,IAAI,mBACR,wCACA,QACA,UACF;AAAA,IACF;AAAA,IACA,KAAK,aAAa,WAAW,IAAI,CAAC,cAAc;AAAA,MAC9C,KAAK,aAAa,OAAO,cAAc,UAAU;AAAA,QAC/C,MAAM,IAAI,mBACR,4CACA,QACA,SACF;AAAA,MACF;AAAA,MACA,OAAO;AAAA,KACR;AAAA;AAAA,EAGH,QAAQ,CAAC,OAAY,SAAwB;AAAA,IAC3C,OAAO,KAAK,WAAW,MAAM,CAAC,cAC5B,UAAU,SAAS,OAAO,OAAO,CACnC;AAAA;AAEJ;AAAA;AAGO,MAAM,WAAsC;AAAA,EACjD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,YAA0B;AAAA,IACpC,KAAK,MAAM,QAAQ,UAAU,GAAG;AAAA,MAC9B,MAAM,IAAI,mBACR,uCACA,OACA,UACF;AAAA,IACF;AAAA,IACA,KAAK,aAAa,WAAW,IAAI,CAAC,cAAc;AAAA,MAC9C,KAAK,aAAa,OAAO,cAAc,UAAU;AAAA,QAC/C,MAAM,IAAI,mBACR,2CACA,OACA,SACF;AAAA,MACF;AAAA,MACA,OAAO;AAAA,KACR;AAAA;AAAA,EAGH,QAAQ,CAAC,OAAY,SAAwB;AAAA,IAC3C,OAAO,KAAK,WAAW,KAAK,CAAC,cAC3B,UAAU,SAAS,OAAO,OAAO,CACnC;AAAA;AAEJ;AAAA;AAGO,MAAM,YAAuC;AAAA,EAClD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,WAAuB;AAAA,IACjC,KAAK,gBAAgB,SAAS,GAAG;AAAA,MAC/B,MAAM,IAAI,mBACR,wDACA,QACA,SACF;AAAA,IACF;AAAA,IACA,KAAK,YAAY;AAAA;AAAA,EAGnB,QAAQ,CAAC,OAAY,SAAwB;AAAA,IAC3C,QAAQ,KAAK,UAAU,SAAS,OAAO,OAAO;AAAA;AAElD;AAAA;AAGO,MAAM,YAAuC;AAAA,EAClD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,YAA0B;AAAA,IACpC,KAAK,MAAM,QAAQ,UAAU,GAAG;AAAA,MAC9B,MAAM,IAAI,mBACR,wCACA,QACA,UACF;AAAA,IACF;AAAA,IACA,KAAK,aAAa,WAAW,IAAI,CAAC,cAAc;AAAA,MAC9C,KAAK,aAAa,OAAO,cAAc,UAAU;AAAA,QAC/C,MAAM,IAAI,mBACR,4CACA,QACA,SACF;AAAA,MACF;AAAA,MACA,OAAO;AAAA,KACR;AAAA;AAAA,EAGH,QAAQ,CAAC,OAAY,SAAwB;AAAA,IAC3C,QAAQ,KAAK,WAAW,KAAK,CAAC,cAC5B,UAAU,SAAS,OAAO,OAAO,CACnC;AAAA;AAEJ;AAGO,IAAM,mBAAmB;AAAA,EAC9B,MAAM;AAAA,EACN,KAAK;AAAA,EACL,MAAM;AAAA,EACN,MAAM;AACR;;AChIO,MAAM,eAA0C;AAAA,EACrD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAC7B,IAAI,OAAO,UAAU,WAAW;AAAA,MAC9B,MAAM,IAAI,mBACR,oCACA,WACA,KACF;AAAA,IACF;AAAA,IACA,KAAK,cAAc;AAAA;AAAA,EAGrB,QAAQ,CAAC,OAAqB;AAAA,IAC5B,OAAO,KAAK,cAAc,UAAU,YAAY,UAAU;AAAA;AAE9D;AAAA;AAGO,MAAM,aAAwC;AAAA,EACnD,OAAO;AAAA,EACC;AAAA,SAIO,eAGX;AAAA,IACF,QAAQ,CAAC,MAAM,OAAO,MAAM,aAAa,OAAO,UAAU,CAAC;AAAA,IAC3D,GAAG,CAAC,MAAM,OAAO,MAAM,aAAa,OAAO,UAAU,CAAC;AAAA,IACtD,QAAQ,CAAC,MAAM,OAAO,MAAM;AAAA,IAC5B,GAAG,CAAC,MAAM,OAAO,MAAM;AAAA,IACvB,QAAQ,CAAC,MACP,OAAO,MAAM,YACb,MAAM,SACL,MAAM,QAAQ,CAAC,OACd,aAAa,WACb,aAAa,aACb,aAAa,iBACb,OAAO,WAAW,eAAe,aAAa,WAC/C,EAAU,cAAc;AAAA,IAC3B,GAAG,CAAC,MACF,OAAO,MAAM,YACb,MAAM,SACL,MAAM,QAAQ,CAAC,OACd,aAAa,WACb,aAAa,aACb,aAAa,iBACb,OAAO,WAAW,eAAe,aAAa,WAC/C,EAAU,cAAc;AAAA,IAC3B,OAAO,CAAC,MAAM,MAAM,QAAQ,CAAC;AAAA,IAC7B,GAAG,CAAC,MAAM,MAAM,QAAQ,CAAC;AAAA,IACzB,SAAS,CAAC,MACR,aAAa,cACZ,OAAO,WAAW,eAAe,aAAa;AAAA,IACjD,GAAG,CAAC,MACF,aAAa,cACZ,OAAO,WAAW,eAAe,aAAa;AAAA,IACjD,WAAW,CAAC,MAAM,MAAM;AAAA,IACxB,GAAG,CAAC,MAAM,MAAM;AAAA,IAChB,UAAU,CAAC,MACT,OAAO,MAAM,YACb,MAAM,QACL,EAAU,cAAc;AAAA,IAC3B,GAAG,CAAC,MACF,OAAO,MAAM,YACb,MAAM,QACL,EAAU,cAAc;AAAA,IAC3B,MAAM,CAAC,MAAM,OAAO,MAAM;AAAA,IAC1B,SAAS,CAAC,MAAM,OAAO,MAAM;AAAA,IAC7B,GAAG,CAAC,MAAM,OAAO,MAAM;AAAA,IACvB,MAAM,CAAC,MAAM,aAAa;AAAA,IAC1B,GAAG,CAAC,MAAM,aAAa;AAAA,IACvB,MAAM,CAAC,MAAM,MAAM;AAAA,IACnB,IAAI,CAAC,MAAM,MAAM;AAAA,IACjB,OAAO,CAAC,MAAM,aAAa;AAAA,IAC3B,IAAI,CAAC,MAAM,aAAa;AAAA,IACxB,KAAK,CAAC,MAAM,OAAO,MAAM,YAAY,OAAO,UAAU,CAAC;AAAA,IACvD,IAAI,CAAC,MAAM,OAAO,MAAM,YAAY,OAAO,UAAU,CAAC;AAAA,IACtD,MAAM,CAAC,MACL,OAAO,MAAM,YAAa,OAAO,MAAM,YAAY,OAAO,UAAU,CAAC;AAAA,IACvE,IAAI,CAAC,MACH,OAAO,MAAM,YAAa,OAAO,MAAM,YAAY,OAAO,UAAU,CAAC;AAAA,IACvE,QAAQ,CAAC,MAAM,OAAO,MAAM,YAAY,OAAO,MAAM;AAAA,EACvD;AAAA,EAEA,WAAW,CAAC,OAAmB;AAAA,IAC7B,MAAM,eAAe,MAAM,QAAQ,KAAK,IAAI,QAAQ,CAAC,KAAK;AAAA,IAE1D,KACG,aAAa,MAAM,CAAC,MAAM,OAAO,MAAM,YAAY,OAAO,MAAM,QAAQ,GACzE;AAAA,MACA,MAAM,IAAI,mBACR,gEACA,SACA,KACF;AAAA,IACF;AAAA,IAEA,KAAK,WAAW,aAAa,IAAI,CAAC,MAAM;AAAA,MACtC,MAAM,UAAU,aAAa,aAAa;AAAA,MAC1C,KAAK,SAAS;AAAA,QACZ,MAAM,IAAI,mBACR,oCAAoC,KACpC,SACA,CACF;AAAA,MACF;AAAA,MACA,OAAO;AAAA,KACR;AAAA,IAED,IAAI,KAAK,SAAS,WAAW,GAAG;AAAA,MAC9B,MAAM,IAAI,mBACR,gCACA,SACA,KACF;AAAA,IACF;AAAA;AAAA,EAGF,QAAQ,CAAC,OAAY,UAAyB;AAAA,IAC5C,OAAO,KAAK,SAAS,KAAK,CAAC,YAAY,QAAQ,KAAK,CAAC;AAAA;AAEzD;AAGO,IAAM,mBAAmB;AAAA,EAC9B,SAAS;AAAA,EACT,OAAO;AACT;;ACtHA,IAAM,kBAAkB;AAAA,EACtB,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,SAAS;AAAA,EACT,MAAM;AAER;AAEA,SAAS,gBAAgB,CAAC,OAAwB;AAAA,EAChD,IAAI,UAAU;AAAA,IAAM,OAAO,gBAAgB;AAAA,EAC3C,MAAM,SAAS,OAAO;AAAA,EACtB,IAAI,WAAW,YAAY,WAAW;AAAA,IAAU,OAAO,gBAAgB;AAAA,EACvE,IAAI,WAAW;AAAA,IAAU,OAAO,gBAAgB;AAAA,EAChD,IAAI,WAAW;AAAA,IAAW,OAAO,gBAAgB;AAAA,EACjD,IAAI,iBAAiB;AAAA,IAAM,OAAO,gBAAgB;AAAA,EAClD,IAAI,MAAM,QAAQ,KAAK;AAAA,IAAG,OAAO,gBAAgB;AAAA,EACjD,IAAI,WAAW;AAAA,IAAU,OAAO,gBAAgB;AAAA,EAEhD,OAAO;AAAA;AAQF,SAAS,iBAAiB,CAAC,IAAa,IAA4B;AAAA,EAEzE,IAAI,OAAO,aAAa,OAAO,WAAW;AAAA,IAExC,IAAI,OAAO,aAAa,OAAO;AAAA,MAAW,OAAO;AAAA,IAEjD,OAAO;AAAA,EACT;AAAA,EAGA,IAAI,YAAY,IAAI,EAAE,GAAG;AAAA,IACvB,OAAO;AAAA,EACT;AAAA,EAEA,MAAM,aAAa,iBAAiB,EAAE;AAAA,EACtC,MAAM,aAAa,iBAAiB,EAAE;AAAA,EAGtC,IAAI,eAAe,YAAY;AAAA,IAC7B,OAAO,aAAa,aAAa,KAAK;AAAA,EACxC;AAAA,EAIA,IAAI,eAAe,gBAAgB,QAAQ;AAAA,IACzC,IAAI;AAAA,MACF,MAAM,KAAK,OAAO,OAAO,WAAW,KAAK,OAAO,EAAY;AAAA,MAC5D,MAAM,KAAK,OAAO,OAAO,WAAW,KAAK,OAAO,EAAY;AAAA,MAC5D,OAAO,KAAK,KAAK,KAAK,KAAK,KAAK,IAAI;AAAA,MACpC,MAAM;AAAA,MACN,MAAM,KAAK;AAAA,MACX,MAAM,KAAK;AAAA,MACX,IAAI,KAAK;AAAA,QAAI,OAAO;AAAA,MACpB,IAAI,KAAK;AAAA,QAAI,OAAO;AAAA,MAEpB,IAAI,MAAM,EAAE,KAAK,MAAM,EAAE;AAAA,QAAG,OAAO;AAAA,MACnC,IAAI,MAAM,EAAE,KAAK,MAAM,EAAE;AAAA,QAAG,OAAO,MAAM,EAAE,IAAI,KAAK;AAAA,MACpD,OAAO;AAAA;AAAA,EAEX;AAAA,EACA,IAAI,eAAe,gBAAgB,QAAQ;AAAA,IACzC,OAAQ,KAAiB,KAAgB,KAAK;AAAA,EAChD;AAAA,EACA,IAAI,eAAe,gBAAgB,MAAM;AAAA,IAEvC,MAAM,QAAS,GAAY,QAAQ;AAAA,IACnC,MAAM,QAAS,GAAY,QAAQ;AAAA,IACnC,OAAO,QAAQ,QAAQ,KAAK,QAAQ,QAAQ,IAAI;AAAA,EAClD;AAAA,EACA,IAAI,eAAe,gBAAgB,SAAS;AAAA,IAE1C,OAAQ,KAAkB,KACtB,KACC,KAAkB,KACjB,IACA;AAAA,EACR;AAAA,EACA,IAAI,eAAe,gBAAgB,OAAO;AAAA,IAExC,MAAM,OAAO;AAAA,IACb,MAAM,OAAO;AAAA,IACb,MAAM,MAAM,KAAK,IAAI,KAAK,QAAQ,KAAK,MAAM;AAAA,IAC7C,SAAS,IAAI,EAAG,IAAI,KAAK,KAAK;AAAA,MAC5B,MAAM,OAAO,kBAAkB,KAAK,IAAI,KAAK,EAAE;AAAA,MAC/C,IAAI,SAAS,KAAK,SAAS,MAAM;AAAA,QAE/B,OAAO;AAAA,MACT;AAAA,IAEF;AAAA,IAEA,OAAO,KAAK,SAAS,KAAK,SAAS,KAAK,KAAK,SAAS,KAAK,SAAS,IAAI;AAAA,EAC1E;AAAA,EAIA,OAAO;AAAA;AAUF,SAAS,WAAW,CAAC,MAAe,MAAwB;AAAA,EACjE,IAAI,SAAS,MAAM;AAAA,IACjB,OAAO;AAAA,EACT;AAAA,EAGA,IAAI,gBAAgB,QAAQ,gBAAgB,MAAM;AAAA,IAChD,OAAO,KAAK,QAAQ,MAAM,KAAK,QAAQ;AAAA,EACzC;AAAA,EAGA,IAAI,MAAM,QAAQ,IAAI,KAAK,MAAM,QAAQ,IAAI,GAAG;AAAA,IAC9C,IAAI,KAAK,WAAW,KAAK,QAAQ;AAAA,MAC/B,OAAO;AAAA,IACT;AAAA,IACA,SAAS,IAAI,EAAG,IAAI,KAAK,QAAQ,KAAK;AAAA,MAEpC,KAAK,YAAY,KAAK,IAAI,KAAK,EAAE,GAAG;AAAA,QAClC,OAAO;AAAA,MACT;AAAA,IACF;AAAA,IACA,OAAO;AAAA,EACT;AAAA,EAqBA,OAAO;AAAA;AAAA;AAIF,MAAM,WAAyC;AAAA,EACpD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAE7B,KAAK,aAAa;AAAA;AAAA,EAGpB,QAAQ,CAAC,OAAY,UAAyB;AAAA,IAI5C,IAAI,KAAK,eAAe,WAAW;AAAA,MAEjC,OAAO,UAAU;AAAA,IACnB;AAAA,IAEA,IAAI,UAAU,aAAa,KAAK,eAAe,WAAW;AAAA,MACxD,OAAO;AAAA,IACT;AAAA,IAEA,OAAO,YAAY,OAAO,KAAK,UAAU;AAAA;AAE7C;AAAA;AAGO,MAAM,WAAyC;AAAA,EACpD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAE7B,KAAK,aAAa;AAAA;AAAA,EAGpB,QAAQ,CAAC,OAAY,UAAyB;AAAA,IAG5C,IAAI,KAAK,eAAe,WAAW;AAAA,MACjC,OAAO,UAAU;AAAA,IACnB;AAAA,IAEA,IAAI,UAAU,aAAa,KAAK,eAAe,WAAW;AAAA,MACxD,OAAO;AAAA,IACT;AAAA,IAEA,QAAQ,YAAY,OAAO,KAAK,UAAU;AAAA;AAE9C;AAAA;AAGO,MAAM,WAAyC;AAAA,EACpD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAI7B,KAAK,aAAa;AAAA;AAAA,EAGpB,QAAQ,CAAC,OAAY,UAAyB;AAAA,IAE5C,OAAO,kBAAkB,OAAO,KAAK,UAAU,MAAM;AAAA;AAEzD;AAAA;AAGO,MAAM,YAA0C;AAAA,EACrD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAC7B,KAAK,aAAa;AAAA;AAAA,EAGpB,QAAQ,CAAC,OAAY,UAAyB;AAAA,IAE5C,MAAM,aAAa,kBAAkB,OAAO,KAAK,UAAU;AAAA,IAC3D,OAAO,eAAe,KAAK,eAAe;AAAA;AAE9C;AAAA;AAGO,MAAM,WAAyC;AAAA,EACpD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAC7B,KAAK,aAAa;AAAA;AAAA,EAGpB,QAAQ,CAAC,OAAY,UAAyB;AAAA,IAE5C,OAAO,kBAAkB,OAAO,KAAK,UAAU,MAAM;AAAA;AAEzD;AAAA;AAGO,MAAM,YAA0C;AAAA,EACrD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAC7B,KAAK,aAAa;AAAA;AAAA,EAGpB,QAAQ,CAAC,OAAY,UAAyB;AAAA,IAE5C,MAAM,aAAa,kBAAkB,OAAO,KAAK,UAAU;AAAA,IAC3D,OAAO,eAAe,MAAM,eAAe;AAAA;AAE/C;AAAA;AAGO,MAAM,WAAyC;AAAA,EACpD,OAAO;AAAA,EAEC;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAC7B,KAAK,MAAM,QAAQ,KAAK,GAAG;AAAA,MACzB,MAAM,IAAI,mBAAmB,yBAAyB,OAAO,KAAK;AAAA,IACpE;AAAA,IAEA,KAAK,cAAc;AAAA;AAAA,EAGrB,QAAQ,CAAC,OAAY,UAAyB;AAAA,IAS5C,MAAM,cAAc,KAAK,YAAY,KAAK,CAAC,SAAS;AAAA,MAClD,IAAI,gBAAgB,QAAQ;AAAA,QAE1B,OAAO,OAAO,UAAU,YAAY,KAAK,KAAK,KAAK;AAAA,MACrD;AAAA,MAEA,OAAO,kBAAkB,OAAO,IAAI,MAAM;AAAA,KAC3C;AAAA,IAED,IAAI,aAAa;AAAA,MACf,OAAO;AAAA,IACT;AAAA,IAGA,IAAI,MAAM,QAAQ,KAAK,GAAG;AAAA,MACxB,OAAO,MAAM,KAAK,CAAC,cACjB,KAAK,YAAY,KAAK,CAAC,cAAc;AAAA,QACnC,IAAI,qBAAqB,QAAQ;AAAA,UAC/B,OAAO,OAAO,cAAc,YAAY,UAAU,KAAK,SAAS;AAAA,QAClE;AAAA,QACA,OAAO,kBAAkB,WAAW,SAAS,MAAM;AAAA,OACpD,CACH;AAAA,IACF;AAAA,IAEA,OAAO;AAAA;AAEX;AAAA;AAGO,MAAM,YAA0C;AAAA,EACrD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAC7B,KAAK,MAAM,QAAQ,KAAK,GAAG;AAAA,MACzB,MAAM,IAAI,mBAAmB,0BAA0B,QAAQ,KAAK;AAAA,IACtE;AAAA,IACA,KAAK,cAAc;AAAA;AAAA,EAGrB,QAAQ,CAAC,OAAY,UAAyB;AAAA,IAM5C,MAAM,cAAc,KAAK,YAAY,KAAK,CAAC,SAAS;AAAA,MAClD,IAAI,gBAAgB,QAAQ;AAAA,QAE1B,OAAO,OAAO,UAAU,YAAY,KAAK,KAAK,KAAK;AAAA,MACrD;AAAA,MAEA,OAAO,kBAAkB,OAAO,IAAI,MAAM;AAAA,KAC3C;AAAA,IAED,IAAI,aAAa;AAAA,MACf,OAAO;AAAA,IACT;AAAA,IAGA,IAAI,MAAM,QAAQ,KAAK,GAAG;AAAA,MACxB,MAAM,aAAa,MAAM,KAAK,CAAC,cAC7B,KAAK,YAAY,KAAK,CAAC,cAAc;AAAA,QACnC,IAAI,qBAAqB,QAAQ;AAAA,UAC/B,OAAO,OAAO,cAAc,YAAY,UAAU,KAAK,SAAS;AAAA,QAClE;AAAA,QACA,OAAO,kBAAkB,WAAW,SAAS,MAAM;AAAA,OACpD,CACH;AAAA,MACA,QAAQ;AAAA,IACV;AAAA,IAEA,OAAO;AAAA;AAEX;AAGO,IAAM,sBAAsB;AAAA,EACjC,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,MAAM;AAAA,EACN,KAAK;AAAA,EACL,MAAM;AAAA,EACN,KAAK;AAAA,EACL,MAAM;AAER;;;ACjZO,MAAM,YAAqC;AAAA,EAChD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAC7B,KAAK,MAAM,QAAQ,KAAK,GAAG;AAAA,MACzB,MAAM,IAAI,mBAAmB,0BAA0B,QAAQ,KAAK;AAAA,IACtE;AAAA,IACA,KAAK,SAAS;AAAA;AAAA,EAGhB,QAAQ,CAAC,OAAqB;AAAA,IAC5B,KAAK,MAAM,QAAQ,KAAK,GAAG;AAAA,MACzB,OACE,KAAK,OAAO,WAAW,KACvB,kBAAkB,OAAO,KAAK,OAAO,EAAE,MAAM;AAAA,IAEjD;AAAA,IAEA,OAAO,KAAK,OAAO,MAAM,CAAC,cACxB,MAAM,KAAK,CAAC,cAAc,kBAAkB,WAAW,SAAS,MAAM,CAAC,CACzE;AAAA;AAEJ;AAAA;AAGO,MAAM,kBAA2C;AAAA,EACtD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,WAA2B;AAAA,IACrC,IAAI,OAAO,cAAc,YAAY;AAAA,MACnC,MAAM,IAAI,mBACR,4CACA,cACA,SACF;AAAA,IACF;AAAA,IACA,KAAK,YAAY;AAAA;AAAA,EAGnB,QAAQ,CAAC,OAAqB;AAAA,IAC5B,KAAK,MAAM,QAAQ,KAAK,GAAG;AAAA,MACzB,OAAO;AAAA,IACT;AAAA,IACA,OAAO,MAAM,KAAK,CAAC,SAAS,KAAK,UAAU,IAAI,CAAC;AAAA;AAEpD;AAAA;AAGO,MAAM,aAAsC;AAAA,EACjD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAC7B,IAAI,OAAO,UAAU,YAAY,QAAQ,MAAM,OAAO,UAAU,KAAK,GAAG;AAAA,MACtE,MAAM,IAAI,mBACR,yCACA,SACA,KACF;AAAA,IACF;AAAA,IACA,KAAK,eAAe;AAAA;AAAA,EAGtB,QAAQ,CAAC,OAAqB;AAAA,IAC5B,KAAK,MAAM,QAAQ,KAAK,GAAG;AAAA,MACzB,OAAO;AAAA,IACT;AAAA,IACA,OAAO,MAAM,WAAW,KAAK;AAAA;AAEjC;AAGO,IAAM,iBAAiB;AAAA,EAC5B,MAAM;AAAA,EACN,YAAY;AAAA,EACZ,OAAO;AACT;;AChFO,MAAM,YAA0C;AAAA,EACrD,OAAO;AAAA,EACC;AAAA,EACA;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAC7B,KACG,MAAM,QAAQ,KAAK,KACpB,MAAM,WAAW,KAChB,OAAO,MAAM,OAAO,YAAY,OAAO,MAAM,OAAO,YACpD,OAAO,MAAM,OAAO,YAAY,OAAO,MAAM,OAAO,UACrD;AAAA,MACA,MAAM,IAAI,mBACR,yEACA,QACA,KACF;AAAA,IACF;AAAA,IAEA,OAAO,SAAS,aAAa;AAAA,IAG7B,IACG,OAAO,YAAY,YAAY,YAAY,KAC3C,OAAO,YAAY,YAAY,YAAY,OAAO,CAAC,GACpD;AAAA,MACA,MAAM,IAAI,mBAAmB,+BAA+B,QAAQ,KAAK;AAAA,IAC3E;AAAA,IAIA,KAAK,UAAU;AAAA,IACf,KAAK,YAAY;AAAA;AAAA,EAGnB,QAAQ,CAAC,OAAqB;AAAA,IAE5B,IAAI,OAAO,UAAU,YAAY,OAAO,UAAU,UAAU;AAAA,MAC1D,OAAO;AAAA,IACT;AAAA,IAGA,IAAI;AAAA,MACF,IACE,OAAO,UAAU,YACjB,OAAO,KAAK,YAAY,YACxB,OAAO,KAAK,cAAc,UAC1B;AAAA,QAEA,MAAM,cAAc,OAAO,KAAK;AAAA,QAChC,MAAM,gBAAgB,OAAO,KAAK,OAAO;AAAA,QACzC,MAAM,kBAAkB,OAAO,KAAK,SAAS;AAAA,QAE7C,OAAO,cAAc,kBAAkB;AAAA,MACzC;AAAA,MAEA,OAAO,QAAS,KAAK,YAAwB,KAAK;AAAA,MAClD,OAAO,GAAG;AAAA,MAEV,OAAO;AAAA;AAAA;AAGb;AAAA;AAGO,MAAM,cAA4C;AAAA,EACvD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAC7B,IAAI;AAAA,IACJ,IAAI,UAA8B;AAAA,IAElC,IAAI,iBAAiB,QAAQ;AAAA,MAC3B,KAAK,UAAU;AAAA,MACf;AAAA,IACF,EAAO,SAAI,OAAO,UAAU,UAAU;AAAA,MACpC,aAAa;AAAA,IACf,EAAO,SACL,OAAO,UAAU,YACjB,UAAU,QACV,YAAY,OACZ;AAAA,MAEA,MAAM,YAAa,MAAc;AAAA,MAEjC,IAAI,qBAAqB,QAAQ;AAAA,QAE/B,KAAK,UAAU;AAAA,QACf;AAAA,MACF,EAAO,SAAI,OAAO,cAAc,UAAU;AAAA,QAExC,aAAa;AAAA,QACb,UAAW,MAAc;AAAA,QACzB,IAAI,YAAY,aAAa,OAAO,YAAY,UAAU;AAAA,UACxD,MAAM,IAAI,mBACR,6CACA,UACA,KACF;AAAA,QACF;AAAA,MACF,EAAO;AAAA,QACL,MAAM,IAAI,mBACR,2CACA,UACA,KACF;AAAA;AAAA,IAEJ,EAAO;AAAA,MACL,MAAM,IAAI,mBACR,oEACA,UACA,KACF;AAAA;AAAA,IAGF,IAAI;AAAA,MACF,KAAK,UAAU,IAAI,OAAO,YAAY,OAAO;AAAA,MAC7C,OAAO,GAAG;AAAA,MACV,MAAM,UAAU,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC;AAAA,MACzD,MAAM,IAAI,mBACR,0CAA0C,WAC1C,UACA,KACF;AAAA;AAAA;AAAA,EAIJ,QAAQ,CAAC,OAAqB;AAAA,IAE5B,IAAI,OAAO,UAAU,UAAU;AAAA,MAC7B,OAAO;AAAA,IACT;AAAA,IAEA,OAAO,KAAK,QAAQ,KAAK,KAAK;AAAA;AAElC;AAAA;AAGO,MAAM,cAA4C;AAAA,EACvD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAC7B,IAAI,OAAO,UAAU,YAAY;AAAA,MAC/B,KAAK,KAAK;AAAA,IACZ,EAAO,SAAI,OAAO,UAAU,UAAU;AAAA,MACpC,QAAQ,KACN,gHACF;AAAA,MACA,IAAI;AAAA,QAEF,KAAK,KAAK,IAAI,SAAS,OAAO,WAAW,QAAQ;AAAA,QAIjD,OAAO,GAAG;AAAA,QACV,MAAM,UAAU,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC;AAAA,QACzD,MAAM,IAAI,mBACR,yCAAyC,WACzC,UACA,KACF;AAAA;AAAA,IAEJ,EAAO;AAAA,MACL,MAAM,IAAI,mBACR,qDACA,UACA,KACF;AAAA;AAAA;AAAA,EAIJ,QAAQ,CAAC,QAAa,SAAwB;AAAA,IAE5C,IAAI,OAAO,YAAY,YAAY,YAAY,MAAM;AAAA,MACnD,OAAO;AAAA,IACT;AAAA,IACA,IAAI;AAAA,MAEF,OAAO,QAAQ,KAAK,GAAG,KAAK,SAAS,OAAO,CAAC;AAAA,MAC7C,OAAO,GAAG;AAAA,MACV,QAAQ,MACN,oCAAoC,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC,KAC7E,OACF;AAAA,MACA,OAAO;AAAA;AAAA;AAGb;AAGO,IAAM,sBAAsB;AAAA,EACjC,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,QAAQ;AACV;;ACpMA,SAAS,eAAe,CAAC,OAA2B;AAAA,EAClD,IAAI,OAAO,UAAU,UAAU;AAAA,IAE7B,MAAM,WAAW;AAAA,IACjB,KAAK,OAAO,UAAU,QAAQ,GAAG;AAAA,MAC/B,MAAM,IAAI,mBACR,8BACA,WACA,KACF;AAAA,IACF;AAAA,IAEA,IAAI,WAAW,GAAG;AAAA,MAChB,MAAM,IAAI,mBACR,0CACA,WACA,KACF;AAAA,IACF;AAAA,IACA,OAAO;AAAA,EACT;AAAA,EACA,IAAI,MAAM,QAAQ,KAAK,GAAG;AAAA,IAExB,IACE,MAAM,MACJ,CAAC,QAAQ,OAAO,QAAQ,YAAY,OAAO,UAAU,GAAG,KAAK,OAAO,CACtE,GACA;AAAA,MAEA,MAAM,eAAe;AAAA,MACrB,OAAO,aAAa,OAClB,CAAC,MAAc,QAAgB,OAAQ,KAAK,KAC5C,CACF;AAAA,IACF,EAAO;AAAA,MAEL,MAAM,IAAI,mBACR,8DACA,WACA,KACF;AAAA;AAAA,EAEJ;AAAA,EAEA,MAAM,IAAI,mBACR,mGACA,WACA,KACF;AAAA;AAAA;AAIK,MAAM,mBAA8C;AAAA,EACzD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAC7B,KAAK,UAAU,gBAAgB,KAAK;AAAA;AAAA,EAGtC,QAAQ,CAAC,OAAqB;AAAA,IAC5B,IAAI,OAAO,UAAU,aAAa,OAAO,UAAU,KAAK,GAAG;AAAA,MACzD,OAAO;AAAA,IACT;AAAA,IACA,QAAQ,QAAQ,KAAK,aAAa,KAAK;AAAA;AAE3C;AAAA;AAGO,MAAM,mBAA8C;AAAA,EACzD,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAC7B,KAAK,UAAU,gBAAgB,KAAK;AAAA;AAAA,EAGtC,QAAQ,CAAC,OAAqB;AAAA,IAC5B,IAAI,OAAO,UAAU,aAAa,OAAO,UAAU,KAAK,GAAG;AAAA,MACzD,OAAO;AAAA,IACT;AAAA,IACA,QAAQ,QAAQ,KAAK,aAAa;AAAA;AAEtC;AAAA;AAGO,MAAM,qBAAgD;AAAA,EAC3D,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAC7B,KAAK,UAAU,gBAAgB,KAAK;AAAA;AAAA,EAGtC,QAAQ,CAAC,OAAqB;AAAA,IAC5B,IAAI,OAAO,UAAU,aAAa,OAAO,UAAU,KAAK,GAAG;AAAA,MACzD,OAAO;AAAA,IACT;AAAA,IACA,QAAQ,QAAQ,KAAK,aAAa;AAAA;AAEtC;AAAA;AAGO,MAAM,qBAAgD;AAAA,EAC3D,OAAO;AAAA,EACC;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAC7B,KAAK,UAAU,gBAAgB,KAAK;AAAA;AAAA,EAGtC,QAAQ,CAAC,OAAqB;AAAA,IAC5B,IAAI,OAAO,UAAU,aAAa,OAAO,UAAU,KAAK,GAAG;AAAA,MACzD,OAAO;AAAA,IACT;AAAA,IACA,QAAQ,QAAQ,KAAK,aAAa,KAAK;AAAA;AAE3C;AAGO,IAAM,mBAAmB;AAAA,EAC9B,aAAa;AAAA,EACb,aAAa;AAAA,EACb,eAAe;AAAA,EACf,eAAe;AACjB;;ACjHO,MAAM,uBAAqD;AAAA,EAChE,OAAO;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,EAER,WAAW,CAAC,OAAmB;AAAA,IAE7B,KAAK,SAAS,OAAO,UAAU,UAAU;AAAA,MACvC,MAAM,IAAI,mBACR,yCACA,SACA,KACF;AAAA,IACF;AAAA,IAEA,MAAM,UAAU;AAAA,IAChB,IAAI,OAAO,QAAQ,YAAY,UAAU;AAAA,MACvC,MAAM,IAAI,mBACR,kCACA,SACA,KACF;AAAA,IACF;AAAA,IAGA,KAAK,cAAc,QAAQ,QACxB,MAAM,KAAK,EACX,OAAO,CAAC,SAAS,KAAK,SAAS,CAAC,EAChC,IAAI,CAAC,SAAS,KAAK,KAAK,CAAC;AAAA,IAE5B,IAAI,KAAK,YAAY,WAAW,GAAG;AAAA,MACjC,MAAM,IAAI,mBACR,iCACA,SACA,KACF;AAAA,IACF;AAAA,IAGA,KAAK,gBAAgB,QAAQ,mBAAmB;AAAA,IAChD,KAAK,qBAAqB,QAAQ,wBAAwB;AAAA;AAAA,EAG5D,QAAQ,CAAC,OAAqB;AAAA,IAE5B,IAAI,OAAO,UAAU,UAAU;AAAA,MAC7B,OAAO;AAAA,IACT;AAAA,IAGA,IAAI,aAAa;AAAA,IACjB,IAAI,QAAQ,KAAK;AAAA,IAEjB,KAAK,KAAK,eAAe;AAAA,MACvB,aAAa,WAAW,YAAY;AAAA,MACpC,QAAQ,MAAM,IAAI,CAAC,SAAS,KAAK,YAAY,CAAC;AAAA,IAChD;AAAA,IAEA,KAAK,KAAK,oBAAoB;AAAA,MAC5B,aAAa,KAAK,iBAAiB,UAAU;AAAA,MAC7C,QAAQ,MAAM,IAAI,CAAC,SAAS,KAAK,iBAAiB,IAAI,CAAC;AAAA,IACzD;AAAA,IAGA,OAAO,MAAM,MAAM,CAAC,SAAS,WAAW,SAAS,IAAI,CAAC;AAAA;AAAA,EAIhD,gBAAgB,CAAC,MAAsB;AAAA,IAC7C,OAAO,KAAK,UAAU,KAAK,EAAE,QAAQ,oBAAoB,EAAE;AAAA;AAE/D;AAGO,IAAM,sBAAsB;AAAA,EACjC,OAAO;AACT;;ACjBO,SAAS,aAAa,CAAC,KAA8C;AAAA,EAC1E,OACE,OAAO,QAAQ,YACf,QAAQ,SACP,MAAM,QAAQ,GAAG,KAClB,OAAO,KAAK,GAAG,EAAE,WAAW;AAAA;AAIzB,SAAS,gBAAgB,CAAC,KAA8C;AAAA,EAC7E,OACE,OAAO,QAAQ,YACf,QAAQ,SACP,MAAM,QAAQ,GAAG,KAClB,OAAO,KAAK,GAAG,EAAE,SAAS;AAAA;;;ACvEvB,SAAS,WAAW,CACzB,KACA,SACgB;AAAA,EAEhB,IAAI,eAAe,QAAQ;AAAA,IACzB,IAAI;AAAA,MACF,MAAM,KAAK,eAAe,UAAU,GAAiB;AAAA,MACrD,OAAO,CAAC,eAAoB;AAAA,QAE1B,IAAI,MAAM,QAAQ,UAAU,GAAG;AAAA,UAC7B,OAAO,WAAW,KAAK,UAAQ,GAAG,SAAS,IAAI,CAAC;AAAA,QAClD;AAAA,QACA,OAAO,GAAG,SAAS,UAAU;AAAA;AAAA,MAE/B,OAAO,GAAG;AAAA,MACV,IAAI,aAAa;AAAA,QAAoB,MAAM;AAAA,MAC3C,MAAM,IAAI,MACR,mCAAmC,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC,GAC9E;AAAA;AAAA,EAEJ;AAAA,EAGA,IAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ,MAAM,QAAQ,GAAG,GAAG;AAAA,IAEjE,OAAO,CAAC,WAAe,kBAAkB,QAAO,GAAG,MAAM;AAAA,EAC3D;AAAA,EAGA,IAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ,YAAY,KAAK;AAAA,IAE9D,MAAM,OAAO,OAAO,KAAK,GAAG;AAAA,IAC5B,MAAM,yBAAyB,KAAK,MAClC,CAAC,MAAM,MAAM,YAAY,MAAM,UACjC;AAAA,IAEA,IAAI,0BAA0B,KAAK,UAAU,KAAK,KAAK,UAAU,GAAG;AAAA,MAGlE,IAAI;AAAA,QACF,MAAM,KAAK,eAAe,UAAU,GAAiB;AAAA,QACrD,OAAO,CAAC,eAAoB;AAAA,UAE1B,IAAI,MAAM,QAAQ,UAAU,GAAG;AAAA,YAC7B,OAAO,WAAW,KAAK,UAAQ,GAAG,SAAS,IAAI,CAAC;AAAA,UAClD;AAAA,UACA,OAAO,GAAG,SAAS,UAAU;AAAA;AAAA,QAE/B,OAAO,GAAG;AAAA,QACV,IAAI,aAAa;AAAA,UAAoB,MAAM;AAAA,QAC3C,MAAM,IAAI,MACR,mCAAmC,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC,GAC9E;AAAA;AAAA,IAEJ,EAAO;AAAA,MAEL,MAAM,IAAI,MACR,qEAAqE,KAAK,UAAU,GAAG,GACzF;AAAA;AAAA,EAEJ;AAAA,EAIA,IAAI,iBAAiB,GAAG,GAAG;AAAA,IACzB,MAAM,OAAO,OAAO,KAAK,GAAG;AAAA,IAC5B,MAAM,aAAa,KAAK,IAAI,CAAC,SAAS;AAAA,MAEpC,OAAO,cAAc,KAAgC,MAAM,OAAO;AAAA,KACnE;AAAA,IAED,OAAO,CAAC,WAAe,WAAW,MAAM,CAAC,SAAS,KAAK,MAAK,CAAC;AAAA,EAC/D,EAEK,SAAI,cAAc,GAAG,GAAG;AAAA,IAC3B,MAAM,OAAO,OAAO,KAAK,GAAG,EAAE;AAAA,IAE9B,MAAM,OAAO,cAAc,KAAgC,MAAM,OAAO;AAAA,IACxE,OAAO,CAAC,WAAe,KAAK,MAAK;AAAA,EACnC,EAGK;AAAA,IAEH,OAAO,CAAC,WAAe,kBAAkB,QAAO,GAAG,MAAM;AAAA;AAAA;AAK7D,SAAS,aAAa,CACpB,KACA,MACA,SACgB;AAAA,EAGhB,IAAI,UAAU,OAAO;AAAA,IAEnB,OAAO,QAAQ,MAAM,IAAI,KAAK;AAAA,EAChC;AAAA,EAGA,QAAQ;AAAA,SACD,QAAQ;AAAA,MACX,KAAK,MAAM,QAAQ,IAAI,IAAI,GAAG;AAAA,QAC5B,MAAM,IAAI,mBAAmB,0BAA0B,QAAQ,IAAI,IAAI;AAAA,MACzE;AAAA,MACA,MAAM,aAAc,IAAI,KAAwB,IAAI,CAAC,MACnD,YAAY,GAAG,OAAO,CACxB;AAAA,MACA,OAAO,CAAC,WAAe,WAAW,MAAM,CAAC,SAAS,KAAK,MAAK,CAAC;AAAA,IAC/D;AAAA,SACK,OAAO;AAAA,MACV,KAAK,MAAM,QAAQ,IAAI,GAAG,GAAG;AAAA,QAC3B,MAAM,IAAI,mBAAmB,yBAAyB,OAAO,IAAI,GAAG;AAAA,MACtE;AAAA,MACA,MAAM,aAAc,IAAI,IAAuB,IAAI,CAAC,MAClD,YAAY,GAAG,OAAO,CACxB;AAAA,MACA,OAAO,CAAC,WAAe,WAAW,KAAK,CAAC,SAAS,KAAK,MAAK,CAAC;AAAA,IAC9D;AAAA,SACK,QAAQ;AAAA,MAEX,MAAM,YAAY,YAAY,IAAI,MAAM,OAAO;AAAA,MAC/C,OAAO,CAAC,YAAgB,UAAU,MAAK;AAAA,IACzC;AAAA,SACK,QAAQ;AAAA,MACX,KAAK,MAAM,QAAQ,IAAI,IAAI,GAAG;AAAA,QAC5B,MAAM,IAAI,mBAAmB,0BAA0B,QAAQ,IAAI,IAAI;AAAA,MACzE;AAAA,MACA,MAAM,aAAc,IAAI,KAAwB,IAAI,CAAC,MACnD,YAAY,GAAG,OAAO,CACxB;AAAA,MAEA,OAAO,CAAC,YAAgB,WAAW,KAAK,CAAC,SAAS,KAAK,MAAK,CAAC;AAAA,IAC/D;AAAA,SAEK,UAAU;AAAA,MACb,IAAI;AAAA,QAEF,MAAM,KAAK,eAAe,UAAU,IAAI,MAAoB;AAAA,QAE5D,OAAO,CAAC,QAAa,GAAG,SAAS,WAAW,GAAG;AAAA,QAC/C,OAAO,GAAG;AAAA,QAEV,IAAI,aAAa;AAAA,UAAoB,MAAM;AAAA,QAC3C,MAAM,IAAI,MACR,mCAAmC,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC,GAC9E;AAAA;AAAA,IAEJ;AAAA,SAEK,cAAc;AAAA,MACjB,IACE,OAAO,IAAI,eAAe,YAC1B,IAAI,eAAe,QACnB,MAAM,QAAQ,IAAI,UAAU,GAC5B;AAAA,QACA,MAAM,IAAI,mBACR,4CACA,cACA,IAAI,UACN;AAAA,MACF;AAAA,MAEA,MAAM,mBAAmB,YAAY,IAAI,YAAY,OAAO;AAAA,MAE5D,MAAM,KAAK,IAAI,kBAAkB,gBAAgB;AAAA,MACjD,OAAO,CAAC,eAAoB,GAAG,SAAS,UAAU;AAAA,IACpD;AAAA;AAAA,EAIF,IAAI,WAAW,IAAI,GAAG;AAAA,IACpB,IAAI;AAAA,MAEF,MAAM,KAAK,eAAe,MAAsB,IAAI,KAAmB;AAAA,MAGvE,OAAO,CAAC,eAAoB;AAAA,QAG1B,IAAI,MAAM,QAAQ,UAAU,MAAM,CAAC,QAAQ,SAAS,cAAc,SAAS,WAAW,QAAQ,KAAK,EAAE,SAAS,IAAI,GAAG;AAAA,UACnH,OAAO,WAAW,KAAK,UAAQ,GAAG,SAAS,IAAI,CAAC;AAAA,QAClD;AAAA,QACA,OAAO,GAAG,SAAS,UAAU;AAAA;AAAA,MAE/B,OAAO,GAAG;AAAA,MAEV,IAAI,aAAa;AAAA,QAAoB,MAAM;AAAA,MAC3C,MAAM,IAAI,MACR,kBAAkB,kBAAkB,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC,GAC/E;AAAA;AAAA,EAEJ;AAAA,EAIA,MAAM,oBAAoB,YAAY,IAAI,OAAO,OAAO;AAAA,EAExD,OAAO,CAAC,QAAa;AAAA,IAGnB,MAAM,QAAQ,KAAK,MAAM,GAAG;AAAA,IAC5B,IAAI,aAAkB;AAAA,IACtB,WAAW,QAAQ,OAAO;AAAA,MACxB,IACE,OAAO,eAAe,YACtB,eAAe,UACb,QAAQ,aACV;AAAA,QACA,aAAa;AAAA,QACb;AAAA,MACF;AAAA,MACA,aAAa,WAAW;AAAA,IAC1B;AAAA,IACA,OAAO,kBAAkB,UAAU;AAAA;AAAA;AAKhC,SAAS,eAAe,CAC7B,QACA,SACgB;AAAA,EAChB,IAAI;AAAA,IACF,MAAM,SAAS,YAAY,QAAO,OAAO;AAAA,IACzC,OAAO;AAAA,IACP,OAAO,GAAG;AAAA,IAEV,MAAM,UAAU,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC;AAAA,IAEzD,IAAI,cAAc;AAAA,IAClB,IAAI;AAAA,MACF,cAAc,KAAK,UAAU,QAAO,MAAM,CAAC;AAAA,MAC3C,MAAM;AAAA,MACN,cAAc,OAAO,MAAK;AAAA;AAAA,IAE5B,MAAM,IAAI,MACR,uCAAuC,mBAAmB,aAC5D;AAAA;AAAA;;;AC9PG,SAAS,SAAS,CAAC,OAA+B;AAAA,EACvD,IAAI,UAAU;AAAA,IAAM,OAAO;AAAA,EAC3B,IAAI,UAAU;AAAA,IAAW,OAAO;AAAA,EAEhC,MAAM,SAAS,OAAO;AAAA,EAEtB,IAAI,WAAW;AAAA,IAAU,OAAO;AAAA,EAChC,IAAI,WAAW;AAAA,IAAW,OAAO;AAAA,EACjC,IAAI,WAAW;AAAA,IAAU,OAAO;AAAA,EAGhC,IAAI,iBAAiB;AAAA,IAAM,OAAO;AAAA,EAClC,IAAI,iBAAiB;AAAA,IAAQ,OAAO;AAAA,EAGpC,IAAI,OAAO,WAAW,eAAe,iBAAiB;AAAA,IAAQ,OAAO;AAAA,EAErE,IAAI,MAAM,QAAQ,KAAK;AAAA,IAAG,OAAO;AAAA,EAGjC,IAAI,WAAW;AAAA,IAAU,OAAO;AAAA,EAMhC,OAAO;AAAA;;;AC5BT,IAAM,gBAAgB;AAAA,EACpB,MAAM;AAAA,EACN,WAAW;AAAA,EACX,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAEV;AAQA,SAAS,cAAc,CAAC,OAAwB;AAAA,EAC9C,MAAM,OAAO,UAAU,KAAK;AAAA,EAC5B,OAAO,OACF,cAAc,SAAuC,WACtD;AAAA;AAaC,SAAS,aAAa,CAAC,IAAa,IAA4B;AAAA,EAGrE,IAAI,OAAO,aAAa,OAAO,WAAW;AAAA,IAGxC,OAAO;AAAA,EACT;AAAA,EAGA,IAAI,aAAY,IAAI,EAAE,GAAG;AAAA,IACvB,OAAO;AAAA,EACT;AAAA,EAEA,MAAM,aAAa,eAAe,EAAE;AAAA,EACpC,MAAM,aAAa,eAAe,EAAE;AAAA,EAGpC,IAAI,eAAe,YAAY;AAAA,IAC7B,OAAO,aAAa,aAAa,KAAK;AAAA,EACxC;AAAA,EAOA,IAAI,OAAO,OAAO,YAAY,OAAO,OAAO,UAAU;AAAA,IACpD,OAAO,KAAK,KAAK,KAAK;AAAA,EACxB;AAAA,EAEA,IAAI,OAAO,OAAO,YAAY,OAAO,OAAO,UAAU;AAAA,IACpD,OAAO,KAAK,KAAK,KAAK;AAAA,EACxB;AAAA,EAEA,IAAI,OAAO,OAAO,aAAa,OAAO,OAAO,WAAW;AAAA,IAEtD,OAAO,OAAO,SAAS,OAAO,OAAO,KAAK;AAAA,EAC5C;AAAA,EAEA,IAAI,cAAc,QAAQ,cAAc,MAAM;AAAA,IAC5C,MAAM,QAAQ,GAAG,QAAQ;AAAA,IACzB,MAAM,QAAQ,GAAG,QAAQ;AAAA,IACzB,OAAO,QAAQ,QAAQ,KAAK;AAAA,EAC9B;AAAA,EAOA,IAAI,eAAe,cAAc,OAAO;AAAA,IAGtC,OAAO;AAAA,EACT;AAAA,EAIA,OAAO;AAAA;AAaF,SAAS,YAAW,CAAC,IAAa,IAAsB;AAAA,EAC7D,IAAI,OAAO,IAAI;AAAA,IACb,OAAO;AAAA,EACT;AAAA,EAGA,IAAI,cAAc,QAAQ,cAAc,MAAM;AAAA,IAC5C,OAAO,GAAG,QAAQ,MAAM,GAAG,QAAQ;AAAA,EACrC;AAAA,EAGA,IAAI,MAAM,QAAQ,EAAE,KAAK,MAAM,QAAQ,EAAE,GAAG;AAAA,IAC1C,IAAI,GAAG,WAAW,GAAG,QAAQ;AAAA,MAC3B,OAAO;AAAA,IACT;AAAA,IACA,SAAS,IAAI,EAAG,IAAI,GAAG,QAAQ,KAAK;AAAA,MAClC,KAAK,aAAY,GAAG,IAAI,GAAG,EAAE,GAAG;AAAA,QAC9B,OAAO;AAAA,MACT;AAAA,IACF;AAAA,IACA,OAAO;AAAA,EACT;AAAA,EAGA,IACE,OAAO,OAAO,YACd,OAAO,QACP,OAAO,OAAO,YACd,OAAO,UACL,cAAc,WACd,cAAc,UACf,MAAM,QAAQ,EAAE,MAChB,MAAM,QAAQ,EAAE,OACf,cAAc,aACd,cAAc,aACd,OAAO,WAAW,eAAe,cAAc,aAC/C,OAAO,WAAW,eAAe,cAAc,SACjD;AAAA,IACA,MAAM,QAAQ,OAAO,KAAK,EAAY;AAAA,IACtC,MAAM,QAAQ,OAAO,KAAK,EAAY;AAAA,IAEtC,IAAI,MAAM,WAAW,MAAM,QAAQ;AAAA,MACjC,OAAO;AAAA,IACT;AAAA,IAEA,WAAW,QAAO,OAAO;AAAA,MAEvB,KACG,OAAO,UAAU,eAAe,KAAK,IAAI,IAAG,MAC5C,aAAa,GAAW,OAAO,GAAW,KAAI,GAC/C;AAAA,QACA,OAAO;AAAA,MACT;AAAA,IACF;AAAA,IACA,OAAO;AAAA,EACT;AAAA,EAGA,IAAI,cAAc,UAAU,cAAc,QAAQ;AAAA,IAChD,OAAO,GAAG,WAAW,GAAG,UAAU,GAAG,UAAU,GAAG;AAAA,EACpD;AAAA,EAGA,OAAO;AAAA;;;ACzKT,SAAS,iBAAiB,CACxB,MACyC;AAAA,EACzC,OAAO,SAAQ,UAAU,SAAQ,SAAS,SAAQ,UAAU,SAAQ;AAAA;AA2C/D,SAAS,YAAY,CAC1B,OACA,SACe;AAAA,EACf,MAAM,UAA8B;AAAA,IAClC,QAAQ,CAAC;AAAA,IACT;AAAA,IACA,YAAY,CAAC;AAAA,IACb,eAAe,CAAC;AAAA,IAChB,gBAAgB,CAAC;AAAA,IACjB,mBAAmB,MAAM,QAAQ,OAAO;AAAA,IACxC,aAAa,CAAC,SAAiB,UAAkB;AAAA,MAC/C,MAAM,WAAW,GAAG,cAAY;AAAA,MAChC,IAAI,QAAQ,WAAW,WAAW;AAAA,QAChC,OAAO,QAAQ,WAAW;AAAA,MAC5B;AAAA,MACA,MAAM,UAAU,SAAS,QAAQ,cAAc;AAAA,MAC/C,MAAM,eAAe,mBAAmB,SAAS,SAAS,IAAI;AAAA,MAC9D,MAAM,aAAa,mBAAmB,OAAO,SAAS,IAAI;AAAA,MAC1D,QAAQ,cAAc,KAAK,EAAE,SAAS,cAAc,WAAW,CAAC;AAAA,MAChE,QAAQ,WAAW,YAAY;AAAA,MAC/B,OAAO;AAAA;AAAA,EAEX;AAAA,EAEA,IAAI;AAAA,IAEF,MAAM,iBAAiB,mBAAmB,OAAO,OAAO,OAAO;AAAA,IAG/D,MAAM,cAAc,CAAC,GAAG,QAAQ,MAAM;AAAA,IACtC,MAAM,iBAAiB,QAAQ;AAAA,IAC/B,MAAM,kBAAkB;AAAA,MACtB;AAAA,MACA;AAAA,MACA,kBAAkB;AAAA,IACpB;AAAA,IACA,MAAM,cAAc,OAAO,KAAK,eAAe;AAAA,IAI/C,MAAM,iBAAoC,CAAC;AAAA,IAE3C,IAAI,gCAAwC;AAAA,IAC5C,IAAI,6BAAqC;AAAA,IAEzC,QAAQ,cAAc,QACpB,GAAG,SAAS,cAAc,cAAc,UAAU;AAAA,MAChD,MAAM,UAAU,QAAQ,OACtB,SAAS,aAAa,UAAU,GAAG,aAAa,SAAS,CAAC,CAAC;AAAA,MAE7D,MAAM,QAAQ,QAAQ,OACpB,SAAS,WAAW,UAAU,GAAG,WAAW,SAAS,CAAC,CAAC;AAAA,MAIzD,iCAAiC,WAAW;AAAA;AAAA,MAC5C,8BAA8B,KAAK,6BAA6B;AAAA;AAAA,MAGhE,IAAI;AAAA,QACF,eAAe,KAAK,IAAI,OAAO,SAAS,KAAK,CAAC;AAAA,QAC9C,OAAO,YAAY;AAAA,QAEnB,eAAe,KAAK,IAAI;AAAA,QACxB,QAAQ,MACN,0BAA0B,aAC1B,sBAAsB,QAAQ,WAAW,UAAU,UACrD;AAAA;AAAA,KAGN;AAAA,IAGA,MAAM,aAAa;AAAA;AAAA;AAAA;AAAA,MAIjB,YAAY,IAAI,CAAC,UAAS,YAAY,sCAAqC,EAAE,KAAK;AAAA,KAAQ;AAAA;AAAA,sBAE1E,KAAK,UAAU,WAAW;AAAA;AAAA;AAAA;AAAA,EAI9C,8BAA8B,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4BAMT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA0BxB,MAAM,kBAAkB;AAAA;AAAA,cAEd,YAAY,IAAI,CAAC,UAAS,SAAS,oBAAmB,QAAO,EAAE,KAAK;AAAA,CAAI;AAAA;AAAA;AAAA;AAAA,cAIxE,2BAA2B,KAAK;AAAA;AAAA;AAAA;AAAA,oCAIV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAyBhC,MAAM,0BAA0B,IAAI,SAClC,YACA,gBACA,mBACA,mBACA,OACA,eACF;AAAA,IAGA,MAAM,eAAe,wBAAwB,KAC3C,MACA,iBACA,aACA,gBACA,cACF;AAAA,IAEA,OAAO;AAAA,MACL,MAAM,WAAW,KAAK;AAAA,MACtB,MAAM;AAAA,IACR;AAAA,IACA,OAAO,GAAG;AAAA,IAEV,MAAM,UAAU,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC;AAAA,IACzD,QAAQ,MAAM,mCAAmC,SAAS,CAAC;AAAA,IAC3D,OAAO;AAAA,MACL,MAAM,yBAAyB;AAAA,MAC/B,MAAM,MAAM;AAAA,QACV,MAAM,IAAI,MAAM,6BAA6B,SAAS;AAAA;AAAA,MAExD,OAAO;AAAA,MACP,cAAc;AAAA,IAChB;AAAA;AAAA;AAOJ,SAAS,kBAAkB,CACzB,OACA,SACA,QAAiB,OACT;AAAA,EAmBR,MAAM,QAAQ,QAAQ,kBAAkB;AAAA,EACxC,QAAQ,OAAO,KAAK,KAAK;AAAA,EACzB,OAAO,QAAQ,WAAW,WAAW,WAAW;AAAA;AAWlD,SAAS,kBAAkB,CACzB,WACA,QACA,SACQ;AAAA,EAoBR,IAAI,qBAAqB,QAAQ;AAAA,IAC/B,MAAM,UAAU,UAAU;AAAA,IAC1B,MAAM,QAAQ,UAAU;AAAA,IAExB,IAAI,YAAY,KAAK,KAAK,GAAG;AAAA,MAC3B,MAAM,IAAI,mBACR,4CAA4C,SAC5C,UACA,SACF;AAAA,IACF;AAAA,IACA,MAAM,WAAW,QAAQ,YAAY,SAAS,KAAK;AAAA,IACnD,OAAO,IAAI,+BAA+B,0BAA0B,iBAAiB;AAAA,EACvF;AAAA,EAGA,IACE,OAAO,cAAc,YACrB,cAAc,QACd,MAAM,QAAQ,SAAS,GACvB;AAAA,IACA,MAAM,YAAY,mBAAmB,WAAW,OAAO;AAAA,IACvD,OAAO,eAAe,WAAW;AAAA,EACnC;AAAA,EAGA,MAAM,OAAO,OAAO,KAAK,SAAS;AAAA,EAClC,MAAM,cAAc;AAAA,EAGpB,IAAI,KAAK,WAAW,GAAG;AAAA,IACrB,MAAM,OAAM,KAAK;AAAA,IACjB,MAAM,QAAQ,YAAY;AAAA,IAG1B,IAAI,kBAAkB,IAAG,KAAK,SAAQ,UAAU;AAAA,MAE9C,IAAI,SAAQ,UAAU;AAAA,QACpB,gBAAgB,MAAK,OAAO,QAAQ,OAAO;AAAA,QAC3C,OAAO;AAAA,MACT;AAAA,MAEA,QAAQ;AAAA,aACD;AAAA,UACH,KAAK,MAAM,QAAQ,KAAK;AAAA,YACtB,MAAM,IAAI,mBAAmB,0BAA0B,MAAK,KAAK;AAAA,UACnE,OACE,MACG,IACC,CAAC,aACC,IAAI,mBAAmB,UAAU,QAAQ,OAAO,IACpD,EACC,KAAK,MAAM,KAAK;AAAA,aAElB;AAAA,UACH,KAAK,MAAM,QAAQ,KAAK;AAAA,YACtB,MAAM,IAAI,mBAAmB,yBAAyB,MAAK,KAAK;AAAA,UAClE,OACE,MACG,IACC,CAAC,aACC,IAAI,mBAAmB,UAAU,QAAQ,OAAO,IACpD,EACC,KAAK,MAAM,KAAK;AAAA,aAElB;AAAA,UAEH,OAAO,KAAK,mBAAmB,OAAO,QAAQ,OAAO;AAAA,aAClD;AAAA,UACH,KAAK,MAAM,QAAQ,KAAK;AAAA,YACtB,MAAM,IAAI,mBAAmB,0BAA0B,MAAK,KAAK;AAAA,UACnE,OACE,MACG,IACC,CAAC,aACC,KAAK,mBAAmB,UAAU,QAAQ,OAAO,IACrD,EACC,KAAK,MAAM,KAAK;AAAA;AAAA,IAG3B;AAAA,IAIA,IAAI,KAAI,WAAW,GAAG,GAAG;AAAA,MACvB,OAAO,gBAAgB,MAAK,OAAO,QAAQ,OAAO;AAAA,IACpD;AAAA,EAEF;AAAA,EAIA,IAAI,YAAY,eAAe,KAAK,SAAS,QAAQ,GAAG;AAAA,IAKtD,OAAO,gBAAgB,UAAU,WAAW,QAAQ,OAAO;AAAA,EAC7D;AAAA,EAIA,IAAI,KAAK,SAAS,KAAK,KAAK,MAAM,UAAO,KAAI,WAAW,GAAG,CAAC,GAAG;AAAA,IAE7D,MAAM,qBAAqB,KAAK,IAAI,UAAO;AAAA,MACzC,MAAM,QAAQ,YAAY;AAAA,MAC1B,OAAO,gBAAgB,MAAK,OAAO,QAAQ,OAAO;AAAA,KACnD;AAAA,IACD,OAAO,mBAAmB,KAAK,MAAM;AAAA,EACvC;AAAA,EAIA,MAAM,kBAAkB,KAAK,IAAI,CAAC,SAAQ;AAAA,IAExC,IAAI,SAAQ,UAAU;AAAA,MACpB,gBAAgB,MAAK,YAAY,OAAM,QAAQ,OAAO;AAAA,MACtD,OAAO;AAAA,IACT;AAAA,IAGA,IAAI,kBAAkB,IAAG,GAAG;AAAA,MAC1B,MAAM,SAAQ,YAAY;AAAA,MAC1B,QAAQ;AAAA,aACD;AAAA,UACH,KAAK,MAAM,QAAQ,MAAK;AAAA,YACtB,MAAM,IAAI,mBAAmB,0BAA0B,MAAK,MAAK;AAAA,UACnE,OACE,OAAO,OACJ,IACC,CAAC,aACC,IAAI,mBAAmB,UAAU,QAAQ,OAAO,IACpD,EACC,KAAK,MAAM,KAAK,UAAU;AAAA,aAE5B;AAAA,UACH,KAAK,MAAM,QAAQ,MAAK;AAAA,YACtB,MAAM,IAAI,mBAAmB,yBAAyB,MAAK,MAAK;AAAA,UAClE,OACE,OAAO,OACJ,IACC,CAAC,aACC,IAAI,mBAAmB,UAAU,QAAQ,OAAO,IACpD,EACC,KAAK,MAAM,KAAK,WAAW;AAAA,aAE7B;AAAA,UACH,OAAO,KAAK,mBAAmB,QAAO,QAAQ,OAAO;AAAA,aAClD;AAAA,UACH,KAAK,MAAM,QAAQ,MAAK;AAAA,YACtB,MAAM,IAAI,mBAAmB,0BAA0B,MAAK,MAAK;AAAA,UACnE,OACE,OAAO,OACJ,IACC,CAAC,aACC,KAAK,mBAAmB,UAAU,QAAQ,OAAO,IACrD,EACC,KAAK,MAAM,KAAK,UAAU;AAAA;AAAA,IAGrC;AAAA,IAEA,MAAM,QAAQ,YAAY;AAAA,IAC1B,MAAM,gBAAgB,KAAI,MAAM,GAAG,EAAE,OAAO,CAAC,KAAK,SAAS;AAAA,MACzD,KAAK,6BAA6B,KAAK,IAAI,GAAG;AAAA,QAC5C,MAAM,cAAc,KAAK,QAAQ,OAAO,MAAM,EAAE,QAAQ,MAAM,MAAK;AAAA,QACnE,OAAO,GAAG,UAAU;AAAA,MACtB;AAAA,MACA,OAAO,GAAG,QAAQ;AAAA,OACjB,MAAM;AAAA,IAET,OAAO,mBAAmB,OAAO,eAAe,OAAO;AAAA,GACxD;AAAA,EAGD,MAAM,mBAAmB,gBAAgB,OAAO,CAAC,MAAM,MAAM,MAAM;AAAA,EACnE,IAAI,iBAAiB,WAAW;AAAA,IAAG,OAAO;AAAA,EAC1C,OAAO,iBAAiB,KAAK,MAAM;AAAA;AAYrC,SAAS,eAAe,CACtB,UACA,OACA,QACA,SACQ;AAAA,EACR,MAAM,cAAc,CAAC,OAAgC;AAAA,IACnD,MAAM,YAAY,mBAAmB,OAAO,OAAO;AAAA,IACnD,MAAM,aAAa,iBAAiB,WAAW;AAAA,IAC/C,QAAQ;AAAA,WACD;AAAA,QACH,OAAO,IAAI;AAAA,WACR;AAAA,QACH,OAAO,IAAI;AAAA,WACR;AAAA,QACH,OAAO,mCAAmC;AAAA,WACvC;AAAA,QACH,OAAO,oCAAoC;AAAA;AAAA;AAAA,EAIjD,QAAQ;AAAA,SAED,OAAO;AAAA,MACV,MAAM,YAAY,mBAAmB,OAAO,OAAO;AAAA,MACnD,OAAO,eAAe,WAAW;AAAA,IACnC;AAAA,SACK;AAAA,MACH,OAAO,YAAY,GAAG;AAAA,SACnB;AAAA,MACH,OAAO,YAAY,IAAI;AAAA,SACpB;AAAA,MACH,OAAO,YAAY,GAAG;AAAA,SACnB;AAAA,MACH,OAAO,YAAY,IAAI;AAAA,SACpB,OAAO;AAAA,MACV,MAAM,YAAY,mBAAmB,OAAO,OAAO;AAAA,MACnD,OAAO,gBAAgB,WAAW;AAAA,IACpC;AAAA,SACK,OAAO;AAAA,MACV,KAAK,MAAM,QAAQ,KAAK;AAAA,QACtB,MAAM,IAAI,mBAAmB,yBAAyB,OAAO,KAAK;AAAA,MACpE,MAAM,YAAY,mBAAmB,OAAO,OAAO;AAAA,MAGnD,OAAO;AAAA,wBACW;AAAA,cACV,4BAA4B;AAAA,cAC5B,2CAA2C;AAAA;AAAA,IAErD;AAAA,SACK,QAAQ;AAAA,MACX,KAAK,MAAM,QAAQ,KAAK;AAAA,QACtB,MAAM,IAAI,mBAAmB,0BAA0B,QAAQ,KAAK;AAAA,MACtE,MAAM,YAAY,mBAAmB,OAAO,OAAO;AAAA,MAEnD,OAAO;AAAA,wBACW;AAAA,cACV,4BAA4B;AAAA,cAC5B,2CAA2C;AAAA;AAAA,IAErD;AAAA,SAGK;AAAA,MACH,IAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,MAAM,QAAQ,KAAK,GAAG;AAAA,QAEvE,MAAM,iBAAiB,SAAS;AAAA,UAC9B,MAAM,IAAI,mBACR,gEACA,QACA,KACF;AAAA,QACF;AAAA,MAEF;AAAA,MAIA,OAAO,KAAK,mBAAmB,OAAO,QAAQ,OAAO;AAAA,SAGlD,WAAW;AAAA,MACd,IAAI,OAAO,UAAU,WAAW;AAAA,QAC9B,MAAM,IAAI,mBACR,oCACA,WACA,KACF;AAAA,MACF;AAAA,MACA,OAAO,GAAG,UAAU,QAAQ,QAAQ;AAAA,IACtC;AAAA,SAEK,SAAS;AAAA,MAEZ,IAAI;AAAA,MAEJ,IAAI,MAAM,QAAQ,KAAK,GAAG;AAAA,QACxB,sBAAsB,MAAM,IAAI,CAAC,MAAM,OAAO,CAAC,EAAE,YAAY,CAAC;AAAA,MAChE,EAAO,SAAI,OAAO,UAAU,UAAU;AAAA,QACpC,sBAAsB,CAAC,MAAM,YAAY,CAAC;AAAA,MAC5C,EAAO;AAAA,QACL,MAAM,IAAI,mBACR,sEACA,SACA,KACF;AAAA;AAAA,MAIF,MAAM,aAAa;AAAA,QACjB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,MACA,WAAW,WAAW,qBAAqB;AAAA,QACzC,KAAK,WAAW,SAAS,OAAO,GAAG;AAAA,UAGjC,MAAM,IAAI,mBACR,0CAA0C,WAC1C,SACA,KACF;AAAA,QACF;AAAA,MACF;AAAA,MAGA,MAAM,kBAAkB,mBAAmB,qBAAqB,OAAO;AAAA,MAIvE,OAAO,yCAAyC,mEAAmE;AAAA,IACrH;AAAA,SAGK,UAAU;AAAA,MACb,IAAI;AAAA,MACJ,IAAI,QAAgB;AAAA,MAEpB,IAAI,OAAO,UAAU,UAAU;AAAA,QAC7B,UAAU;AAAA,MACZ,EAAO,SAAI,iBAAiB,QAAQ;AAAA,QAClC,UAAU,MAAM;AAAA,QAChB,QAAQ,MAAM;AAAA,MAChB,EAAO,SACL,OAAO,UAAU,YACjB,UAAU,QACV,YAAY,OACZ;AAAA,QACA,MAAM,WAAW;AAAA,QACjB,IAAI,OAAO,SAAS,WAAW,UAAU;AAAA,UACvC,MAAM,IAAI,mBACR,4EACA,UACA,KACF;AAAA,QACF;AAAA,QACA,UAAU,SAAS;AAAA,QACnB,IAAI,SAAS,aAAa,WAAW;AAAA,UACnC,IAAI,OAAO,SAAS,aAAa,UAAU;AAAA,YACzC,MAAM,IAAI,mBACR,sCACA,UACA,KACF;AAAA,UACF;AAAA,UACA,QAAQ,SAAS;AAAA,QACnB;AAAA,MACF,EAAO;AAAA,QACL,MAAM,IAAI,mBACR,4EACA,UACA,KACF;AAAA;AAAA,MAIF,IAAI,YAAY,KAAK,KAAK,GAAG;AAAA,QAC3B,MAAM,IAAI,mBACR,0CAA0C,SAC1C,UACA,KACF;AAAA,MACF;AAAA,MAEA,MAAM,WAAW,QAAQ,YAAY,SAAS,KAAK;AAAA,MAGnD,OAAO;AAAA,wBACW;AAAA,cACV,mDAAmD,wBAAwB;AAAA,sBACnE,0BAA0B,wBAAwB,iBAAiB;AAAA;AAAA,IAErF;AAAA,SACK,QAAQ;AAAA,MACX,KAAK,MAAM,QAAQ,KAAK,KAAK,MAAM,WAAW,GAAG;AAAA,QAC/C,MAAM,IAAI,mBACR,sDACA,QACA,KACF;AAAA,MACF;AAAA,MACA,OAAO,SAAS,aAAa;AAAA,MAC7B,IACE,OAAO,YAAY,YACnB,OAAO,cAAc,aACpB,OAAO,UAAU,OAAO,MACxB,OAAO,UAAU,SAAS,GAC3B;AAAA,QAEA,MAAM,IAAI,mBACR,sDACA,QACA,KACF;AAAA,MACF;AAAA,MACA,IAAI,YAAY,GAAG;AAAA,QACjB,MAAM,IAAI,mBAAmB,4BAA4B,QAAQ,KAAK;AAAA,MACxE;AAAA,MAEA,MAAM,cAAc,mBAAmB,SAAS,OAAO;AAAA,MACvD,MAAM,gBAAgB,mBAAmB,WAAW,OAAO;AAAA,MAE3D,OAAO,WAAW,2CAA2C,cAAc,YAAY,mBAAmB;AAAA,IAC5G;AAAA,SAEK,UAAU;AAAA,MAEb,IAAI,OAAO,UAAU,YAAY,OAAO,UAAU,YAAY;AAAA,QAC5D,MAAM,IAAI,mBACR,iDACA,UACA,KACF;AAAA,MACF;AAAA,MACA,IAAI;AAAA,QACF,MAAM,UAAU,IAAI,cAAc,KAAY;AAAA,QAC9C,QAAQ,eAAe,KAAK,OAAO;AAAA,QACnC,OAAO;AAAA,QACP,OAAO,GAAG;AAAA,QACV,IAAI,aAAa,oBAAoB;AAAA,UACnC,MAAM;AAAA,QACR,EAAO;AAAA,UACL,MAAM,IAAI,mBACR,4BAA4B,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC,KACrE,UACA,KACF;AAAA;AAAA;AAAA,IAGN;AAAA,SAGK,SAAS;AAAA,MACZ,IACE,OAAO,UAAU,YACjB,UAAU,UACR,aAAa,QACf;AAAA,QACA,MAAM,IAAI,mBACR,oDACA,SACA,KACF;AAAA,MACF;AAAA,MACA,MAAM,YAAY;AAAA,MAElB,IAAI,OAAO,UAAU,YAAY,UAAU;AAAA,QACzC,MAAM,IAAI,mBACR,kDACA,SACA,KACF;AAAA,MACF;AAAA,MACA,MAAM,eAAe,UAAU,QAAQ,KAAK;AAAA,MAC5C,IAAI,iBAAiB,IAAI;AAAA,QACvB,MAAM,IAAI,mBACR,iDACA,SACA,KACF;AAAA,MACF;AAAA,MAEA,IAAI,gBAAgB;AAAA,MACpB,IAAI,oBAAoB,WAAW;AAAA,QACjC,IAAI,OAAO,UAAU,mBAAmB,WAAW;AAAA,UACjD,MAAM,IAAI,mBACR,mDACA,SACA,KACF;AAAA,QACF;AAAA,QACA,gBAAgB,UAAU;AAAA,MAC5B;AAAA,MAGA,MAAM,cAAc,aAAa,MAAM,KAAK;AAAA,MAC5C,MAAM,YAAY,mBAAmB,aAAa,OAAO;AAAA,MACzD,MAAM,oBAAoB,mBAAmB,eAAe,OAAO;AAAA,MAGnE,OAAO;AAAA;AAAA,sDAEyC;AAAA,0BAC5B;AAAA,kDACwB;AAAA,mDACC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAM/B;AAAA;AAAA,IAEhB;AAAA,SAGK;AAAA,SACA;AAAA,SACA;AAAA,SACA,iBAAiB;AAAA,MACpB,IAAI;AAAA,MACJ,IAAI,OAAO,UAAU,YAAY,OAAO,UAAU,KAAK,KAAK,SAAS,GAAG;AAAA,QACtE,UAAU;AAAA,MACZ,EAAO,SAAI,MAAM,QAAQ,KAAK,GAAG;AAAA,QAC/B,UAAU;AAAA,QACV,WAAW,OAAO,OAAO;AAAA,UACvB,IAAI,OAAO,QAAQ,aAAa,OAAO,UAAU,GAAG,KAAK,MAAM,GAAG;AAAA,YAChE,MAAM,IAAI,mBACR,kDAAkD,YAClD,UACA,KACF;AAAA,UACF;AAAA,UACA,WAAW,KAAK;AAAA,QAClB;AAAA,MACF,EAAO;AAAA,QACL,MAAM,IAAI,mBACR,GAAG,8FACH,UACA,KACF;AAAA;AAAA,MAGF,MAAM,WAAW,mBAAmB,SAAS,OAAO;AAAA,MACpD,MAAM,WAAW,WAAW,2CAA2C;AAAA,MAEvE,QAAQ;AAAA,aACD;AAAA,UACH,OAAO,GAAG,gBAAgB,YAAY,iBAAiB;AAAA,aACpD;AAAA,UACH,OAAO,GAAG,gBAAgB,YAAY;AAAA,aACnC;AAAA,UACH,OAAO,GAAG,gBAAgB,YAAY;AAAA,aACnC;AAAA,UAIH,OAAO,GAAG,gBAAgB,YAAY,iBAAiB;AAAA;AAAA,MAE3D;AAAA,IACF;AAAA,SAGK,QAAQ;AAAA,MACX,KAAK,MAAM,QAAQ,KAAK,GAAG;AAAA,QACzB,MAAM,IAAI,mBACR,gCACA,QACA,KACF;AAAA,MACF;AAAA,MACA,MAAM,iBAAiB,mBAAmB,OAAO,OAAO;AAAA,MAIxD,MAAM,QAAQ;AAAA,gCACY;AAAA,sBACV;AAAA,sBACA;AAAA,2BACK;AAAA;AAAA;AAAA;AAAA,MAKrB,MAAM,gBAAgB;AAAA,iCACK,cAAc,8CAA8C,WAAW;AAAA;AAAA,MAElG,OAAO,KAAK,MAAM,KAAK,UAAU,cAAc,KAAK;AAAA,IACtD;AAAA,SACK,SAAS;AAAA,MACZ,IAAI,OAAO,UAAU,aAAa,OAAO,UAAU,KAAK,KAAK,QAAQ,GAAG;AAAA,QACtE,MAAM,IAAI,mBACR,yCACA,SACA,KACF;AAAA,MACF;AAAA,MACA,MAAM,WAAW,mBAAmB,OAAO,OAAO;AAAA,MAElD,OAAO,kBAAkB,cAAc,qBAAqB;AAAA,IAC9D;AAAA,SACK,cAAc;AAAA,MAEjB,IAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,MAAM,QAAQ,KAAK,GAAG;AAAA,QACvE,MAAM,IAAI,mBACR,sCACA,cACA,KACF;AAAA,MACF;AAAA,MAIA,MAAM,eAAe,mBAAmB,OAAO,QAAQ,OAAO;AAAA,MAI9D,OAAO;AAAA,gCACmB;AAAA,kBACd;AAAA;AAAA,kCAEgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQ9B;AAAA;AAAA,MAME,IAAI,WAAW,QAAwB,GAAG;AAAA,QACxC,QAAQ,KACN,aAAa,8DACf;AAAA,MACF;AAAA,MACA,MAAM,IAAI,mBACR,yBAAyB,YACzB,UACA,KACF;AAAA;AAAA,EAIJ,OAAO;AAAA;;;AC94BF,SAAS,KAAK,CACnB,KACA,UAAwB,CAAC,GACT;AAAA,EAChB,QAAQ,WAAW,cAAc,OAAO,QAAQ,UAAU;AAAA,EAE1D,IAAI,OAAO;AAAA,IACT,QAAQ,IAAI,4BAAiB,cAAc,gBAAgB,YAAY;AAAA,IACvE,QAAQ,IAAI,8BAAmB,KAAK,UAAU,KAAK,MAAM,CAAC,CAAC;AAAA,EAC7D;AAAA,EAGA,IAAI,aAAa;AAAA,IACf,IAAI;AAAA,MAAO,QAAQ,IAAI,mDAAwC;AAAA,IAC/D,OAAO,gBAAgB,KAAK,SAAS;AAAA,EACvC;AAAA,EAGA,IAAI;AAAA,IAGF,MAAM,iBAAiB,aAAa,KAAK,SAAS;AAAA,IAElD,IAAI,eAAe,MAAM;AAAA,MACvB,IAAI,OAAO;AAAA,QACT,QAAQ,IAAI,uBAAsB;AAAA,QAClC,QAAQ,IAAI,oBAAmB,eAAe,IAAI;AAAA,MACpD;AAAA,MACA,OAAO,eAAe;AAAA,IACxB,EAAO;AAAA,MACL,IAAI;AAAA,QAAO,QAAQ,IAAI,0DAAyD;AAAA,MAChF,QAAQ,KAAK,+DAA+D,eAAe,KAAK;AAAA,MAChG,OAAO,gBAAgB,KAAK,SAAS;AAAA;AAAA,IAEvC,OAAO,OAAY;AAAA,IACnB,IAAI;AAAA,MAAO,QAAQ,IAAI,4DAA2D,MAAM,OAAO;AAAA,IAC/F,QAAQ,KAAK,8DAA8D,MAAM,OAAO;AAAA,IACxF,OAAO,gBAAgB,KAAK,SAAS;AAAA;AAAA;;AC/ClC,IAAM,eAAe;AAAA,KACvB;AAAA,KACA;AAAA,KACA;AAAA,KACA;AAAA,KACA;AAAA,KACA;AAAA,KACA;AACL;AASO,SAAS,UAAU,CAAC,OAAsC;AAAA,EAC/D,OAAO,SAAS;AAAA;AAIX,SAAS,cAAc,CAC5B,UACA,OACe;AAAA,EACf,MAAM,gBAAgB,aAAa;AAAA,EACnC,OAAO,IAAI,cAAc,KAAK;AAAA;;;AClDhC,gBAAuB,IAAoB,CACzC,aACA,WACmB;AAAA,EACnB,MAAM,cAAc,OAAO,cAAc,aAAa,YAAY,MAAM,SAAS;AAAA,EACjF,iBAAiB,WAAW,YAAW,KAAK,UAAU;AAAA,IACpD,IAAI,YAAY,OAAO,GAAG;AAAA,MACxB,MAAM;AAAA,MACN;AAAA,IACF;AAAA,EACF;AAAA;;;ACVF,gBAAuB,KAAqB,CAC1C,aACA,WACmB;AAAA,EACnB,MAAM,cAAc,OAAO,cAAc,aAAa,YAAY,MAAM,SAAS;AAAA,EACjF,iBAAiB,WAAW,YAAW,KAAK,SAAS;AAAA,IACnD,IAAI,YAAY,OAAO,GAAG;AAAA,MACxB,MAAM;AAAA,MACN;AAAA,IACF;AAAA,EACF;AAAA;;;ACRF,gBAAuB,GAAmB,CACxC,aACA,WACmB;AAAA,EACnB,MAAM,cAAc,OAAO,cAAc,aAAa,YAAY,MAAM,SAAS;AAAA,EACjF,iBAAiB,WAAW,YAAW,KAAK,SAAS;AAAA,IACnD,IAAI,YAAY,OAAO,GAAG;AAAA,MACxB,MAAM;AAAA,IACR;AAAA,EACF;AAAA;;;ACRK,SAAS,oBAAoC,CAClD,aACA,KACA;AAAA,EACA,MAAM,SAAqB,CAAC;AAAA,EAE5B,SAAS,IAAI,EAAG,IAAI,YAAW,SAAS,QAAQ,KAAK,GAAG;AAAA,IACtD,OAAO,KAAK,YAAW,QAAQ,GAAG,GAAG,CAAC;AAAA,EACxC;AAAA,EAEA,OAAO,CAAC,MAAW;AAAA,IACjB,OAAO,QAAQ,CAAC,MAAM,IAAI,CAAC,CAAC;AAAA;AAAA;;;ACfhC,eAAsB,YAA4B,CAChD,aACA,IACA,IACA,GACA;AAAA,EACA,MAAM,QAAQ,IAAI,YAAW,QAAQ,IAAI,CAAC,SAAS,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC;AAAA;;;ACNrE,eAAsB,UAA0B,CAAC,aAA2B;AAAA,EAC1E,IAAI,YAAW,KAAK;AAAA,IAGlB,MAAM,MAAM,KAAK,IAAI;AAAA,IACrB,MAAM,aAAa,MAAM,YAAW;AAAA,IAGpC,MAAM,WAAW,YAAW,QAAQ;AAAA,IACpC,KAAK;AAAA,MAAU;AAAA,IAGf,MAAM,eAA4B,CAAC;AAAA,IAGnC,MAAM,mBAAmB,SAAS,GAAG,UAAU,EAAE,QAAQ;AAAA,IAEzD,IAAI,SAAS,iBAAiB,KAAK;AAAA,IACnC,QAAQ,OAAO,QAAQ,OAAO,OAAO;AAAA,MACnC,IAAI,OAAO,MAAM,UAAU,WAAW;AAAA,QACpC,aAAa,KAAK,OAAO,MAAM,KAAK;AAAA,MACtC;AAAA,MACA,SAAS,iBAAiB,KAAK;AAAA,IACjC;AAAA,IAGA,WAAW,UAAU,cAAc;AAAA,MACjC,MAAM,YAAW,aAAa,MAAM;AAAA,IACtC;AAAA,IAEA,IAAI,aAAa,SAAS,GAAG;AAAA,MAC3B,MAAM,YAAW,QAAQ;AAAA,IAC3B;AAAA,EACF;AAAA;;;AClCK,SAAS,YAA4B,CAC1C,aACA,KACA;AAAA,EACA,YAAW,QAAQ,QAAQ,CAAC,SAAS,KAAK,GAAG,CAAC;AAAA;;;ACP5B,IAApB;AAGqC,IAArC;;;ACHyB,IAAzB;AAMO,SAAS,oBAAoC,CAClD,MACA,MACA,aACA,KACA,OACA,SACW;AAAA,EACX,IAAI;AAAA,EAGJ,MAAM,WAAW,YAAW,UAAU;AAAA,EACtC,MAAM,sBAAsB,UAAU,QAAQ,SAAS,KAAK,SAAS;AAAA,EAErE,IAAI,SAAS;AAAA,IACX,IAAI,kBAAkB;AAAA,MAEpB,QAAQ,QAAQ,IAAI;AAAA,IACtB,EAAO;AAAA,MAEL,QAAQ,qBAAO,MAAW,IAAU;AAAA,MACpC,IAAI,SAAS,QAAQ,OAAM;AAAA,QACzB,QAAQ,MAAM,MAAM,YAAW,MAAM,YAAW,IAAI,KAAK;AAAA,QACzD,qBAAI,MAAM,MAAY,KAAK;AAAA,MAC7B;AAAA,MAEA,QAAQ,QAAQ,KAAK;AAAA;AAAA,EAEzB,EAAO;AAAA,IAEL,QAAQ,qBAAO,MAAW,IAAU;AAAA,IACpC,IAAI,SAAS,QAAQ,OAAM;AAAA,MACzB,QAAQ,MAAM,MAAM,YAAW,MAAM,YAAW,IAAI,KAAK;AAAA,MACzD,qBAAI,MAAM,MAAY,KAAK;AAAA,IAC7B;AAAA;AAAA,EAGF,OAAO;AAAA;;;AC3CW,IAApB;AAGO,SAAS,SAAS,CACvB,MACA,MACA,SACW;AAAA,EACX,IAAI,SAAS;AAAA,IAEX,OAAO,QAAQ,IAAI;AAAA,EACrB;AAAA,EAGA,OAAO,sBAAI,MAAM,IAAU;AAAA;;;ACVtB,SAAS,iCAAiD,CAC/D,aACA,OACA,MACA,SACA,WACA,SACoB;AAAA,EACpB,MAAM,WAAU,SAAS,OAAO;AAAA,IAC9B,IAAI,aAAY,SAAS,MAAM;AAAA,MAC7B,OAAO,CAAC,OAAO,mBAAmB,yBAAwB,cAAc;AAAA,IAC1E;AAAA,IACE,IACF,WACA,YAAW,QAAQ,eAAe,IAAG,KACrC,YAAW,QAAQ,MAAK,UAAU,KAAK,MAAM,WAC7C;AAAA,MACA,OAAO,CAAC,OAAO,gBAAgB,+BAA8B,OAAO;AAAA,IACtE;AAAA,EACA;AAAA,EACA,OAAO,CAAC,IAAI;AAAA;;;ACpBd,eAAsB,iCAAiD,CACrE,aACA,OACA,MACA,SACA,WACA,SACA,KAC6B;AAAA,EAC7B,MAAM,WAAU,SAAS,OAAO;AAAA,IAC9B,IAAI,aAAY,SAAS,MAAM;AAAA,MAC7B,OAAO,CAAC,OAAO,mBAAmB,yBAAwB,cAAc;AAAA,IAC1E;AAAA,IACA,IACE,WACA,YAAW,QAAQ,eAAe,IAAG,GACrC;AAAA,MACA,MAAM,mBAAmB,YAAW,QAAQ,MAAK,UAAU,KAAK;AAAA,MAChE,IAAI,qBAAqB,WAAW;AAAA,QAElC,MAAM,eAAe,MAAM,YAAW,KAAK,IAAI,gBAAgB;AAAA,QAC/D,IAAI,gBAAgB,aAAa,YAAW,QAAQ,KAAI;AAAA,UACtD,OAAO,CAAC,OAAO,gBAAgB,+BAA8B,OAAO;AAAA,QACtE;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,OAAO,CAAC,IAAI;AAAA;;;AC5Bd,eAAsB,cAA8B,CAClD,aACA;AAAA,EACA,WAAW,UAAU,YAAW,SAAS;AAAA,IACvC,OAAO;AAAA,EACT;AAAA;;;ACRkB,IAApB;AAAA;AAUO,MAAM,kBAAkB;AAAA,SAKb,oBAAoB;AAAA,SAO7B,gBAAgC,CAAC,UAG5B;AAAA,IACV,UAAU,SAAS,QAAQ,SAAS,KAAK,SAAS;AAAA;AAAA,SAQ7C,oBAAoC,CAAC,UAInB;AAAA,IAEvB,IAAI,SAAS,QAAQ,SAAS,MAAM;AAAA,MAClC,OAAO,CAAC;AAAA,QACN,KAAK,SAAS;AAAA,QACd,OAAO,SAAS,SAAS;AAAA,MAC3B,CAAC;AAAA,IACH;AAAA,IAGA,IAAI,SAAS,MAAM;AAAA,MACjB,OAAO,SAAS,KAAK,IAAI,YAAU;AAAA,QACjC,IAAI,OAAO,WAAW,UAAU;AAAA,UAC9B,OAAO,EAAE,KAAK,QAAQ,OAAO,MAAM;AAAA,QACrC,EAAO,SAAI,OAAO,WAAW,YAAY,SAAS,QAAQ;AAAA,UACxD,OAAO,EAAE,KAAK,OAAO,KAAK,OAAO,OAAO,SAAS,MAAM;AAAA,QACzD,EAAO;AAAA,UACL,OAAO,EAAE,KAAK,QAAoB,OAAO,MAAM;AAAA;AAAA,OAElD;AAAA,IACH;AAAA,IAEA,MAAM,IAAI,MAAM,2DAA2D;AAAA;AAAA,SAUtE,iBAAiC,CACtC,QACQ;AAAA,IAER,IAAI,OAAM,SAAS,KAAK,OAAO,OAAM,OAAO,UAAU;AAAA,MACpD,OAAQ,OAAmB,KAAK,GAAG;AAAA,IACrC;AAAA,IAGA,MAAM,SAAS;AAAA,IACf,IAAI,OAAO,WAAW,GAAG;AAAA,MAEvB,OAAO,OAAO,OAAO,GAAG,GAAG;AAAA,IAC7B;AAAA,IAGA,OAAO,OAAO,IAAI,WAAS;AAAA,MACzB,MAAM,SAAS,OAAO,MAAM,GAAG;AAAA,MAC/B,OAAO,MAAM,UAAU,SAAS,GAAG,gBAAgB;AAAA,KACpD,EAAE,KAAK,GAAG;AAAA;AAAA,SASN,qBAAqC,CAC1C,QACA,YAAoB,kBAAkB,mBACN;AAAA,IAChC,IAAI,OAAO,WAAW,GAAG;AAAA,MACvB;AAAA,IACF;AAAA,IAEA,IAAI,OAAO,WAAW,GAAG;AAAA,MAEvB,MAAM,QAAQ,OAAO;AAAA,MACrB,OAAO,CAAC,SAAY,sBAAI,MAAM,MAAM,GAAa;AAAA,IACnD;AAAA,IAGA,OAAO,CAAC,SAAY;AAAA,MAClB,MAAM,SAAS,OAAO,IAAI,WAAS,sBAAI,MAAM,MAAM,GAAa,CAAC;AAAA,MACjE,OAAO,kBAAkB,UAAU,QAAQ,SAAS;AAAA;AAAA;AAAA,SAUjD,gBAAgC,CACrC,QACA,YAAoB,kBAAkB,mBACI;AAAA,IAC1C,IAAI,OAAO,WAAW,GAAG;AAAA,MACvB,MAAM,QAAQ,OAAO;AAAA,MACrB,IAAI,MAAM,UAAU,QAAQ;AAAA,QAC1B,OAAO,CAAC,GAAQ,MAAW;AAAA,UACzB,IAAI,IAAI;AAAA,YAAG,OAAO;AAAA,UAClB,IAAI,IAAI;AAAA,YAAG,OAAO;AAAA,UAClB,OAAO;AAAA;AAAA,MAEX;AAAA,MAEA;AAAA,IACF;AAAA,IAGA,OAAO,CAAC,GAAW,MAAsB;AAAA,MACvC,MAAM,UAAU,kBAAkB,YAAY,GAAG,SAAS;AAAA,MAC1D,MAAM,UAAU,kBAAkB,YAAY,GAAG,SAAS;AAAA,MAE1D,SAAS,IAAI,EAAG,IAAI,KAAK,IAAI,QAAQ,QAAQ,QAAQ,QAAQ,OAAO,MAAM,GAAG,KAAK;AAAA,QAChF,MAAM,QAAQ,OAAO;AAAA,QACrB,MAAM,SAAS,QAAQ;AAAA,QACvB,MAAM,SAAS,QAAQ;AAAA,QAGvB,IAAI,WAAW,QAAQ,WAAW;AAAA,UAAM;AAAA,QACxC,IAAI,WAAW;AAAA,UAAM,OAAO,MAAM,UAAU,QAAQ,KAAK;AAAA,QACzD,IAAI,WAAW;AAAA,UAAM,OAAO,MAAM,UAAU,QAAQ,IAAI;AAAA,QAGxD,IAAI,cAAa;AAAA,QACjB,IAAI,OAAO,WAAW,YAAY,OAAO,WAAW,UAAU;AAAA,UAC5D,cAAa,OAAO,cAAc,MAAM;AAAA,QAC1C,EAAO,SAAI,OAAO,WAAW,YAAY,OAAO,WAAW,UAAU;AAAA,UACnE,cAAa,SAAS;AAAA,QACxB,EAAO,SAAI,kBAAkB,QAAQ,kBAAkB,MAAM;AAAA,UAC3D,cAAa,OAAO,QAAQ,IAAI,OAAO,QAAQ;AAAA,QACjD,EAAO;AAAA,UAEL,cAAa,OAAO,MAAM,EAAE,cAAc,OAAO,MAAM,CAAC;AAAA;AAAA,QAG1D,IAAI,gBAAe,GAAG;AAAA,UACpB,OAAO,MAAM,UAAU,UAAU,cAAa;AAAA,QAChD;AAAA,MACF;AAAA,MAEA,OAAO;AAAA;AAAA;AAAA,SAUJ,SAAS,CAAC,QAAe,YAAoB,kBAAkB,mBAA2B;AAAA,IAC/F,OAAO,OAAO,IAAI,WAAS;AAAA,MACzB,IAAI,UAAU,QAAQ,UAAU,WAAW;AAAA,QACzC,OAAO;AAAA,MACT;AAAA,MAEA,MAAM,cAAc,OAAO,KAAK;AAAA,MAEhC,OAAO,YACJ,QAAQ,OAAO,MAAM,EACrB,QAAQ,IAAI,OAAO,UAAU,QAAQ,uBAAuB,MAAM,GAAG,GAAG,GAAG,KAAK,WAAW;AAAA,KAC/F,EAAE,KAAK,SAAS;AAAA;AAAA,SASZ,WAAW,CAAC,YAAoB,YAAoB,kBAAkB,mBAA0B;AAAA,IACrG,KAAK,YAAY;AAAA,MACf,OAAO,CAAC;AAAA,IACV;AAAA,IAGA,MAAM,QAAkB,CAAC;AAAA,IACzB,IAAI,UAAU;AAAA,IACd,IAAI,IAAI;AAAA,IAER,OAAO,IAAI,WAAW,QAAQ;AAAA,MAC5B,IAAI,WAAW,OAAO,QAAQ,IAAI,IAAI,WAAW,QAAQ;AAAA,QAEvD,WAAW,WAAW,IAAI;AAAA,QAC1B,KAAK;AAAA,MACP,EAAO,SAAI,WAAW,OAAO,WAAW;AAAA,QAEtC,MAAM,KAAK,YAAY,KAAK,OAAO,OAAO;AAAA,QAC1C,UAAU;AAAA,QACV;AAAA,MACF,EAAO;AAAA,QACL,WAAW,WAAW;AAAA,QACtB;AAAA;AAAA,IAEJ;AAAA,IAGA,MAAM,KAAK,YAAY,KAAK,OAAO,OAAO;AAAA,IAE1C,OAAO;AAAA;AAAA,SASF,OAAO,CAAC,GAAW,GAAmB;AAAA,IAC3C,IAAI,IAAI;AAAA,MAAG,OAAO;AAAA,IAClB,IAAI,IAAI;AAAA,MAAG,OAAO;AAAA,IAClB,OAAO;AAAA;AAAA,SASF,aAA6B,CAClC,MACA,UACO;AAAA,IACP,OAAO,SAAS,IAAI,UAAQ;AAAA,MAC1B,IAAI,OAAO,SAAS,UAAU;AAAA,QAC5B,OAAO,sBAAI,MAAM,IAAI;AAAA,MACvB;AAAA,MACA,OAAO,sBAAI,MAAM,IAAc;AAAA,KAChC;AAAA;AAAA,SAUI,SAAyB,CAC9B,MACA,UACA,YAAoB,kBAAkB,mBAC9B;AAAA,IACR,MAAM,SAAS,kBAAkB,cAAc,MAAM,QAAQ;AAAA,IAC7D,OAAO,kBAAkB,UAAU,QAAQ,SAAS;AAAA;AAAA,SAQ/C,gBAAgB,CAAC,UAAwC;AAAA,IAC9D,KAAK,MAAM,QAAQ,QAAQ,KAAK,SAAS,WAAW,GAAG;AAAA,MACrD,OAAO;AAAA,IACT;AAAA,IAEA,OAAO,SAAS,MAAM,UACpB,OAAO,SAAS,YAAY,KAAK,SAAS,CAC5C;AAAA;AAAA,SAQK,uBAAuB,CAAC,UAAuC;AAAA,IACpE,OAAO,SAAS,IAAI,UAAQ,OAAO,IAAI,CAAC,EAAE,KAAK,GAAG;AAAA;AAAA,SAQ7C,YAAY,CAAC,OAAqB;AAAA,IACvC,OAAO,UAAU,QAAQ,UAAU,aAAa,UAAU;AAAA;AAAA,SASrD,gBAAgB,CACrB,QACA,YAAoB,kBAAkB,mBAC9B;AAAA,IAER,MAAM,iBAAiB,CAAC;AAAA,IACxB,SAAS,IAAI,EAAG,IAAI,OAAO,QAAQ,KAAK;AAAA,MACtC,IAAI,OAAO,OAAO,WAAW;AAAA,QAC3B,eAAe,KAAK,OAAO,EAAE;AAAA,MAC/B,EAAO;AAAA,QACL;AAAA;AAAA,IAEJ;AAAA,IAEA,OAAO,kBAAkB,UAAU,gBAAgB,SAAS;AAAA;AAGhE;;;ANtUO,SAAS,YAA4B,CAC1C,aACA,MACA,UACA;AAAA,EACA;AAAA,IACE,cAAO;AAAA,IACP,kBAAS;AAAA,IACT,kBAAS;AAAA,IACT,sBAAW;AAAA,IACX;AAAA,IACA,YAAY,kBAAkB;AAAA,MAC5B;AAAA,EAEJ,MAAM,KAAK,YAAY;AAAA,EAGvB,MAAM,mBAAmB,kBAAkB,qBAAqB,QAAQ;AAAA,EACxE,MAAM,mBAAmB,iBAAiB,SAAS;AAAA,EAGnD,KAAK,MAAK;AAAA,IACR,OAAM,kBAAkB,kBAAkB,gBAAgB;AAAA,EAC5D;AAAA,EAEA,IAAI,UAAS,KAAK;AAAA,IAChB,MAAM,WAAW,SAAS;AAAA,EAC5B;AAAA,EAEA,IAAI,aAAY;AAAA,IACd,UAAU,CAAC,UACT,OAAO,WAAW,MAAM,SAAS,EAAE,YAAY,IAAI;AAAA,EACvD;AAAA,EAGA,KAAK,SAAS;AAAA,IACZ,UAAU,kBAAkB,sBAAsB,kBAAkB,SAAS;AAAA,EAC/E;AAAA,EAGA,YAAW,UAAU,QAAO;AAAA,IAC1B,KAAK,mBAAmB,YAAY,iBAAiB,GAAG;AAAA,IACxD,MAAM,mBAAmB,mBAAmB;AAAA,IAC5C,QAAQ,mBAAmB,iBAAiB,GAAG,QAAQ;AAAA,IACvD,WAAW,mBAAmB,YAAY;AAAA,IAC1C;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EAEA,IAAI,YAAW,QAAQ,eAAe,IAAG,GAAG;AAAA,IAC1C,MAAM,IAAI,MAAM,kBAAkB,qBAAoB;AAAA,EACxD;AAAA,EAEA,MAAM,SACJ,SAAQ,MACJ,CAAC,SAAY;AAAA,IACX,MAAM,QAAQ,qBACZ,MACA,MACA,aACA,KACA,OACA,OACF;AAAA,IACA,OAAO,OAAO,WAAW,kCACvB,aACA,OACA,MACA,SACA,WACA,OACF;AAAA,IACA,KAAK;AAAA,MAAO,MAAM,IAAI,MAAM,OAAO;AAAA,IACnC,MAAM,WAAU,SAAS,OAAO;AAAA,MAC9B,OAAO,CAAC,gBACN,YAAW,QAAQ,MAAK,OACtB,UAAU,YAAY,QAAQ,MAC9B,WACF;AAAA,IACJ;AAAA,MAEF,CAAC,SAAY;AAAA,IACX,IAAI,QAAQ;AAAA,IACZ,MAAM,eAAe,OAAO,KAAK,IAAI,EAAE,OAAO,CAAC,MAAK,UAAU;AAAA,MAC5D,KAAK,YAAW,UAAU,QAAQ;AAAA,QAChC,QAAQ;AAAA,QACR,KAAI,SAAS;AAAA,aACR,YAAW,UAAU;AAAA,UACxB,KAAK;AAAA,QACP;AAAA,MACF;AAAA,MACA,OAAO;AAAA,OACN,CAAC,CAAgC;AAAA,IAEpC,IAAI,OAAO;AAAA,MACT,YAAW,YAAY;AAAA,WAClB,YAAW;AAAA,WACX;AAAA,MACL;AAAA,MACA,cAAc,aAAY,YAAY;AAAA,MACtC,eAAe,WAAU;AAAA,IAC3B;AAAA,IACA,OAAO,CAAC,gBAAwB;AAAA,MAAG;AAAA;AAAA;AAAA,EAG3C,MAAM,SACJ,SAAQ,MACJ,OAAO,IAAoB,IAAoB,kBAA0B;AAAA,IACvE,MAAM,WAAW,qBACf,IACA,MACA,aACA,KACA,OACA,OACF;AAAA,IACA,MAAM,WAAW,UAAU,IAAI,MAAK,OAAO;AAAA,IAC3C,IAAI,YAAY,MAAM;AAAA,MACpB,OAAO,OAAO,WAAW,MAAM,kCAC7B,aACA,UACA,MACA,SACA,WACA,SACC,GAAW,YAAW,GACzB;AAAA,MACA,KAAK;AAAA,QAAO,MAAM,IAAI,MAAM,OAAO;AAAA,MACnC,IAAI,aAAa,UAAU;AAAA,QACzB,IAAI,SAAQ;AAAA,UACV,YAAW,QAAQ,MAAK,OAAO,QAAQ;AAAA,QACzC,EAAO;AAAA,UACL,YAAW,QAAQ,MAAK,eAAe,UAAU,CAAC,YAChD,QAAO,YAAW,KAAK,WAAY,GAAW,YAAW,MAAM,IACjE;AAAA;AAAA,QAEF,YAAW,QAAQ,MAAK,OACtB,aAAa,YAAY,WAAW,MACpC,aACF;AAAA,MACF;AAAA,IACF,EAAO;AAAA,MACL,IAAI,SAAQ;AAAA,QACV,YAAW,QAAQ,MAAK,OAAO,QAAQ;AAAA,MACzC,EAAO;AAAA,QACL,YAAW,QAAQ,MAAK,eAAe,UAAU,CAAC,YAChD,QAAO,YAAW,KAAK,WAAY,GAAW,YAAW,MAAM,IACjE;AAAA;AAAA;AAAA,MAIN;AAAA,EAEN,MAAM,SACJ,SAAQ,MACJ,CAAC,SAAY;AAAA,IACX,MAAM,QAAQ,UAAU,QAAQ,IAAI,IAAI,sBAAI,MAAM,IAAG,KAAK;AAAA,IAC1D,YAAW,QAAQ,MAAK,eACtB,OACA,CAAC,YACC,QAAO,YAAW,KAAK,WAAW,KAAK,YAAW,MAAM,IAC5D;AAAA,MAEF;AAAA,EAEN,MAAM,SACJ,SAAQ,MACJ,MAAM;AAAA,IACJ,KAAK,YAAW,QAAQ,eAAe,IAAG,GAAG;AAAA,MAE3C,MAAM,aAAa,kBAAkB,iBAAiB,kBAAkB,SAAS;AAAA,MACjF,YAAW,QAAQ,QAAO,IAAI,2BAAuB,WAAW,SAAQ,UAAU;AAAA,IACpF;AAAA,MAEF;AAAA,EAEN,MAAM,UACJ,SAAQ,MACJ,YAAY;AAAA,IACV,KAAK,YAAW,QAAQ,eAAe,IAAG,GAAG;AAAA,MAE3C,MAAM,aAAa,kBAAkB,iBAAiB,kBAAkB,SAAS;AAAA,MACjF,YAAW,QAAQ,QAAO,IAAI,2BAAuB,WAAW,SAAQ,UAAU;AAAA,MAClF,IAAI,YAAW,KAAK,SAAS,GAAG;AAAA,QAC9B,iBAAiB,QAAQ,YAAW,KAAK,SAAS;AAAA,UAChD,SAAS,IAAI,IAAI,KAAK,YAAW,GAAG;AAAA,QACtC;AAAA,MACF;AAAA,IACF;AAAA,MAEF;AAAA,EAEN,IAAI;AAAA,IAAQ,YAAW,QAAQ,KAAK,MAAM;AAAA,EAC1C,IAAI;AAAA,IAAS,YAAW,SAAS,KAAK,OAAO;AAAA,EAC7C,IAAI;AAAA,IAAQ,YAAW,QAAQ,KAAK,MAAM;AAAA,EAC1C,IAAI;AAAA,IAAQ,YAAW,QAAQ,KAAK,MAAM;AAAA,EAC1C,IAAI;AAAA,IAAQ,YAAW,QAAQ,KAAK,MAAM;AAAA;;;AOhNrC,SAAS,aAA6B,CAC3C,aACA,YACM;AAAA,EACN,WAAW,QAAO,YAAW;AAAA,IAC3B,aAAgB,aAAY,MAAK,WAAU,KAAI;AAAA,EACjD;AAAA;;;ACTK,SAAS,YAA4B,CAC1C,aACA,MACA;AAAA,EACA,IAAI,MAAM;AAAA,IACR,IAAI,KAAK,UAAU;AAAA,MACjB,MAAM,MAAM,KAAK,IAAI;AAAA,MACrB,OAAO,MAAM,KAAK,YAAY,YAAW;AAAA,IAC3C,EAAO;AAAA,MACL,OAAO;AAAA;AAAA,EAEX,EAAO;AAAA,IACL,OAAO;AAAA;AAAA;;;ACVX,eAAsB,oBAAoC,CACxD,aACA,OACmB;AAAA,EACnB,IAAI,aAAsB;AAAA,EAE1B,MAAM,SAAS,MAAM,OAAO,CAAC,MAAM;AAAA,IACjC,IAAI,aAAa,aAAY,CAAC,GAAG;AAAA,MAC/B,OAAO;AAAA,IACT,EAAO;AAAA,MACL,aAAa;AAAA,MACb,OAAO;AAAA;AAAA,GAEV;AAAA,EAED,IAAI,YAAY;AAAA,IACd,IAAI,YAAW,OAAO,YAAW,KAAK,SAAS,GAAG;AAAA,MAChD,MAAM,WAAW,WAAU;AAAA,IAC7B;AAAA,EACF;AAAA,EACA,OAAO;AAAA;;;ACpBT,eAAsB,iBAAiC,CACrD,aACA,MACA,OACmB;AAAA,EACnB,MAAM,SAAmB,CAAC;AAAA,EAC1B,IAAI,YAAW,QAAQ,OAAM;AAAA,IAC3B,MAAM,OAAO,YAAW,QAAQ,MAAK,KAAK,KAAK;AAAA,IAC/C,WAAW,QAAO,MAAM;AAAA,MACtB,MAAM,OAAM,MAAM,YAAW,KAAK,IAAI,IAAG;AAAA,MACzC,OAAO,KAAK,IAAI;AAAA,IAClB;AAAA,EACF;AAAA,EACA,OAAO,qBAAqB,aAAY,MAAM;AAAA;;;ACbhD,eAAsB,mBAAmC,CACvD,aACA,QACwB;AAAA,EACxB,IAAI,aAAa;AAAA,EAEjB,IAAI,WAAW,aAAa,aAAY,MAAM,GAAG;AAAA,IAC/C,aAAa;AAAA,EACf;AAAA,EACA,IAAI,YAAY;AAAA,IACd,IAAI,YAAW,OAAO,YAAW,KAAK,SAAS,GAAG;AAAA,MAChD,MAAM,WAAW,WAAU;AAAA,IAC7B;AAAA,EACF;AAAA,EACA,OAAO,aAAa,YAAY;AAAA;;;ACnBf,IAAnB;;;ACKO,SAAS,iBAAiC,CAC/C,YACA,OACa;AAAA,EACb,QAAQ,KAAK,MAAM,QAAQ,QAAQ,UAAU,eAAe;AAAA,EAC5D,OAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS,aACL,YACA,MAAM,UACN,KAAK,MAAM,OAAO,IAClB;AAAA,IACJ,KAAK,MAAM,MACP,WAAW,SAAS,MAAM,OACxB,WAAW,SAAS,MAAM,OAC1B,KAAK,MAAM,GAAG,IAChB;AAAA,EACN;AAAA;;;ADnBK,SAAS,aAA6B,CAC3C,aACA,QACyB;AAAA,EACzB,OAAS,MAAI,QAAO,CAAC,UAAU;AAAA,IAC7B,OAAO,kBAAkB,aAAY,KAAK;AAAA,GAC3C,EAAE,OAAO,CAAC,MAAK,QAAQ;AAAA,IACtB,KAAI,IAAI,OAAO;AAAA,IACf,OAAO;AAAA,KACN,CAAC,CAA4B;AAAA;;;AEV3B,IAPP;AAeO,SAAS,kBAA0C,CACxD,MACyB;AAAA,EACzB,OAAO,gCAAc,IAAI;AAAA;AAGpB,SAAS,oBAA4C,CAC1D,MACiB;AAAA,EACjB,OAAO,iCAAqB,IAAI;AAAA;AAU3B,SAAS,cAAsC,CACpD,QACiB;AAAA,EACjB,MAAM,aAAa,gCAAc,MAAM;AAAA,EACvC,OAAO,iCAAqB,UAAU;AAAA;;;AClCjC,SAAS,mBAAmB,CACjC,SACuC;AAAA,EACvC,OAAO,OAAO,KAAK,OAAO,EAAE,OAAO,CAAC,MAAK,QAAQ;AAAA,IAC/C,KAAI,OAAO,qBAAqB,QAAQ,IAAI;AAAA,IAC5C,OAAO;AAAA,KACN,CAAC,CAA0C;AAAA;;;ACNzC,SAAS,iBAAiB,CAC/B,SAC+C;AAAA,EAC/C,OAAO,OAAO,KAAK,OAAO,EAAE,OAAO,CAAC,MAAK,QAAQ;AAAA,IAC/C,KAAI,OAAO,mBAAmB,QAAQ,IAAI;AAAA,IAC1C,OAAO;AAAA,KACN,CAAC,CAAkD;AAAA;;;ACVrC,IAAnB;;;ACKO,SAAS,eAA+B,CAC7C,aACA,QACgB;AAAA,EAChB,QAAQ,WAAK,aAAM,iBAAQ,iBAAQ,qBAAU,4BAAe;AAAA,EAC5D,OAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS,cACL,YACA,OAAM,UACN,OAAM,QAAQ,SAAS,IACvB;AAAA,IACJ,KAAK,OAAM,MACP,WAAW,SAAS,OAAM,IAAI,QAC5B,OAAM,IAAI,OACV,OAAM,IAAI,SAAS,IACrB;AAAA,EACN;AAAA;;;ADnBK,SAAS,WAA2B,CACzC,aACA,QAC4B;AAAA,EAC5B,OAAS,OAAI,QAAO,CAAC,UAAU;AAAA,IAC7B,OAAO,gBAAgB,aAAY,KAAK;AAAA,GACzC,EAAE,OAAO,CAAC,MAAK,QAAQ;AAAA,IACtB,KAAI,IAAI,OAAiB;AAAA,IACzB,OAAO;AAAA,KACN,CAAC,CAA+B;AAAA;;;AEZrC,eAAsB,eAA+B,CACnD,OACA,QACA,MACwB;AAAA,EACxB,MAAM,cACJ,QACA,WAAW,OAAU;AAAA,IACnB,MAAM,OAAO;AAAA,IACb,MAAM;AAAA,IACN,SAAS,OAAO,QAAQ,MAAM;AAAA,IAC9B,MAAM,OAAO,KAAK,UAAU;AAAA,EAG9B,CAAC;AAAA,EAEH,YAAW,YAAY,OAAO;AAAA,EAC9B,YAAW,KAAK,OAAO;AAAA,EACvB,YAAW,MAAM,OAAO;AAAA,EAExB,YAAW,UAAU,CAAC;AAAA,EACtB,YAAW,UAAU,CAAC;AAAA,EACtB,YAAW,UAAU,CAAC;AAAA,EACtB,YAAW,UAAU,CAAC;AAAA,EAEtB,YAAW,UAAU,CAAC;AAAA,EACtB,cAAc,aAAY,YAAW,SAAS;AAAA,EAC9C,MAAM,eAAe,WAAU;AAAA,EAC/B,iBAAiB,QAAQ,OAAO,KAAK,SAAS;AAAA,IAC5C,MAAM,YAAW,KAAK,IAAI;AAAA,EAC5B;AAAA,EACA,MAAM,YAAW,QAAQ;AAAA,EACzB,OAAO;AAAA;;;ACjCT,eAAsB,aAA6B,CACjD,QACe;AAAA,EACf,MAAM,gBAAgB,GAAG,OAAO,QAAQ,IAAI,KAAK,EAAE,OAAO,KAAK,MAAM;AAAA,EAErE,MAAM,OAAO,MAAM;AAAA,EACnB,MAAM,OAAO,QAAQ;AAAA;;;ACJvB,eAAsB,uBAAuC,CAC3D,aACA,MACA,OACwB;AAAA,EACxB,IAAI,YAAW,QAAQ,OAAM;AAAA,IAC3B,MAAM,MAAK,YAAW,QAAQ,MAAK,UAAU,KAAK;AAAA,IAClD,MAAM,SACJ,OAAM,OAAO,MAAM,YAAW,KAAK,IAAI,GAAE,IAAI;AAAA,IAC/C,OAAO,oBAAoB,aAAY,MAAM;AAAA,EAC/C;AAAA;;;ACVF,eAAsB,sBAAsC,CAC1D,aACA,MACA,OACwB;AAAA,EACxB,IAAI,YAAW,QAAQ,OAAM;AAAA,IAC3B,MAAM,MAAK,YAAW,QAAQ,MAAK,SAAS,KAAK;AAAA,IACjD,MAAM,SAAS,OAAM,OAAO,MAAM,YAAW,KAAK,IAAI,GAAE,IAAI;AAAA,IAC5D,OAAO,oBAAoB,aAAY,MAAM;AAAA,EAC/C;AAAA;;;ACZF,eAAsB,eAA+B,CACnD,aACA;AAAA,EACA,WAAW,WAAW,YAAW,UAAU;AAAA,IACzC,MAAM,QAAQ;AAAA,EAChB;AAAA;;;ACPyC,IAA3C;;;ACCqB,IAArB;;;ACCO,SAAS,cAAc,CAAC,SAAiB,OAAwB;AAAA,EACtE,OAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,MAAM,KAAK,IAAI;AAAA,EACjB;AAAA;;;ADDK,SAAS,aAA6B,CAC3C,KACA,MACA,QACkB;AAAA,EAClB,OAAO;AAAA,IACL;AAAA,IACA,SAAS;AAAA,IACT,cAAc;AAAA,IACd,MAAM;AAAA,IACN,SAAS,KAAK,IAAI;AAAA,IAClB,SAAS;AAAA,IACT,SAAS;AAAA,IACT;AAAA,IACA,SAAS,CAAC,eAAe,GAAG,0BAAK,CAAC,GAAG,IAAI,CAAE,CAAC;AAAA,EAC9C;AAAA;;;AErBmB,IAArB;AAIO,SAAS,aAA6B,CAC3C,QACA,MACkB;AAAA,EAClB,MAAM,QAAQ,2BAAK,OAAO,MAAM,IAAI;AAAA,EACpC,MAAM,IAAI,eAAe,OAAO,cAAc,KAAM;AAAA,EACpD,OAAO,QAAQ,KAAK,CAAC;AAAA,EACrB,OAAO;AAAA,OACF;AAAA,IACH,MAAM;AAAA,IACN,SAAS,KAAK,IAAI;AAAA,IAClB,cAAc,OAAO,eAAe;AAAA,EACtC;AAAA;;;AChBmB,IAArB;AAIO,SAAS,aAA6B,CAC3C,QACkB;AAAA,EAClB,MAAM,QAAQ,2BAAK,CAAC,GAAG,OAAO,IAAI;AAAA,EAClC,MAAM,IAAI,eAAe,OAAO,cAAc,KAAM;AAAA,EACpD,OAAO,QAAQ,KAAK,CAAC;AAAA,EACrB,OAAO;AAAA,OACF;AAAA,IACH,MAAM,CAAC;AAAA,IACP,SAAS,KAAK,IAAI;AAAA,IAClB,cAAc,OAAO,eAAe;AAAA,EACtC;AAAA;;;ACbK,SAAS,gBAAgC,CAAC,MAAsD;AAAA,EACrG,KAAK,QAAQ,OAAO,SAAS;AAAA,IAAU,OAAO;AAAA,EAC9C,OACE,OAAO,UAAU,eAAe,KAAK,MAAM,SAAS,KACpD,OAAQ,KAAa,YAAY,YACjC,OAAO,UAAU,eAAe,KAAK,MAAM,cAAc,KACzD,OAAQ,KAAa,iBAAiB,YACtC,OAAO,UAAU,eAAe,KAAK,MAAM,SAAS,KACpD,OAAQ,KAAa,YAAY,YACjC,OAAO,UAAU,eAAe,KAAK,MAAM,SAAS,KACpD,MAAM,QAAS,KAAa,OAAO;AAAA;;;ALDhC,MAAM,KAAyC;AAAA,MAChD,IAAI,GAAG;AAAA,IACT,OAAO;AAAA;AAAA,EAET,aAAsB;AAAA,EACtB,OAA6B,CAAC;AAAA,EAC9B,WAAmB;AAAA,EACnB,SAAiB;AAAA,EACjB;AAAA,EACA,SAA2B,QAAQ,QAAQ,IAAI;AAAA,EAE/C,IAAI,CAAC,aAAqC;AAAA,IACxC,KAAK,aAAa;AAAA,IAClB,OAAO;AAAA;AAAA,OAGH,MAAK,GAAsB;AAAA,IAC/B,MAAM,QAAO,IAAI;AAAA,IACjB,MAAK,KAAK,KAAK,QAAQ,CAAC;AAAA,IACxB,OAAO;AAAA;AAAA,OAGH,IAAG,CAAC,MAAgB;AAAA,IACxB,MAAM,OAAO,sBAAI,KAAK,MAAM,OAAO,IAAG,CAAC;AAAA,IACvC,IAAI;AAAA,IACJ,IAAI,iBAAoB,IAAI,GAAG;AAAA,MAC7B,SAAS,4BAAa,KAAK,IAAK;AAAA,MAChC,KAAK,KAAK,WAAW,OAAO;AAAA,QAC1B,sBAAI,KAAK,MAAM,OAAO,IAAG,GAAG,MAAM;AAAA,MACpC;AAAA,IACF,EAAO;AAAA,MACL,SAAS,4BAAU,IAAI;AAAA;AAAA,IAEzB,OAAO;AAAA;AAAA,MAGL,OAAO,GAAG;AAAA,IACZ,OAAO,KAAK;AAAA;AAAA,MAGV,MAAM,GAAG;AAAA,IACX,OAAO,OAAO,KAAK,KAAK,IAAI,EAAE;AAAA;AAAA,MAG5B,MAAM,CAAC,KAAK;AAAA,IACd,IAAI,QAAQ,GAAG;AAAA,MACb,KAAK,MAAM;AAAA,IACb;AAAA;AAAA,OAGI,IAAG,CAAC,MAAgB,MAAS;AAAA,IACjC,IAAI,YAAY,KAAK,WAAW,UAAU,IAAI;AAAA,IAC9C,IAAI,UAAU,SAAS;AAAA,MACrB,IAAI;AAAA,MACJ,IAAI,KAAK,WAAW,OAAO;AAAA,QACzB,SAAS,cACP,KAAK,KAAK,WAAW,KACrB,4BAAU,IAAI,GACd,KAAK,WAAW,UAClB;AAAA,MACF,EAAO;AAAA,QACL,SAAS,4BAAU,IAAI;AAAA;AAAA,MAGzB,MAAM,SAAS,OAAO,IAAG;AAAA,MACzB,MAAM,SAAS,OAAO,UAAU,eAAe,KAAK,KAAK,MAAM,MAAM;AAAA,MAGrE,sBAAI,KAAK,MAAM,QAAQ,MAAM;AAAA,MAG7B,KAAK,QAAQ;AAAA,QACX,KAAK;AAAA,QACL,KAAK;AAAA,MACP;AAAA,MAEA,OAAO,iBAAiB,IAAI,IAAI,KAAK,OAAO;AAAA,IAC9C;AAAA,IACA,MAAM,IAAI,MAAM,kBAAkB;AAAA;AAAA,OAG9B,OAAM,CAAC,MAAgB,MAAS;AAAA,IACpC,IAAI,YAAY,KAAK,WAAW,UAAU,IAAI;AAAA,IAC9C,IAAI,UAAU,SAAS;AAAA,MACrB,IAAI,SAAY;AAAA,MAChB,MAAM,SAAS,sBAAI,KAAK,MAAM,OAAO,IAAG,CAAC;AAAA,MACzC,IAAI,KAAK,WAAW,OAAO;AAAA,QACzB,IAAI;AAAA,QACJ,KAAK,iBAAiB,MAAM,GAAG;AAAA,UAC7B,OAAM,cACJ,KAAK,KAAK,WAAW,KACrB,MACA,KAAK,WAAW,UAClB;AAAA,QACF,EAAO;AAAA,UACL,OAAM,cAAc,QAAQ,4BAAU,IAAI,CAAC;AAAA;AAAA,QAE7C,sBAAI,KAAK,MAAM,OAAO,IAAG,GAAG,IAAG;AAAA,QAC/B,SAAS,KAAI;AAAA,MACf,EAAO;AAAA,QACL,sBAAI,KAAK,MAAM,OAAO,IAAG,GAAG,4BAAU,MAAM,CAAC;AAAA;AAAA,MAE/C,OAAO;AAAA,IACT;AAAA,IACA,MAAM,IAAI,MAAM,kBAAkB;AAAA;AAAA,OAG9B,OAAM,CAAC,GAAc;AAAA,IACzB,MAAM,OAAO,sBAAI,KAAK,MAAM,GAAG,SAAS,KAAK,WAAW;AAAA,IACxD,IAAI;AAAA,IACJ,IAAI,iBAAoB,IAAI,GAAG;AAAA,MAC7B,cAAc,IAAI;AAAA,MAClB,SAAS,4BAAU,KAAK,IAAI;AAAA,MAC5B,KAAK;AAAA,IACP,EAAO;AAAA,MACL,wBAAM,KAAK,MAAM,GAAG,SAAS,KAAK,WAAW;AAAA,MAC7C,KAAK;AAAA,MACL,SAAS,4BAAU,IAAI;AAAA;AAAA,IAEzB,OAAO;AAAA;AAAA,OAGH,MAAK,GAAG;AAAA,IACZ,KAAK,SAAS;AAAA,IACd,KAAK,WAAW;AAAA,IAChB,KAAK,OAAO,CAAC;AAAA;AAAA,MAGX,IAAI,GAAG;AAAA,IACT,OAAO,OAAO,KAAK,KAAK,IAAI;AAAA;AAAA,EAG9B,IAAI,CAAC,KAA4B;AAAA,IAC/B,KAAK,OAAO,IAAI;AAAA,IAChB,KAAK,SAAS,IAAI;AAAA,IAClB,KAAK,WAAW,IAAI;AAAA,IACpB,OAAO;AAAA;AAAA,EAGT,SAAS,GAAG;AAAA,IACV,OAAO,IAAI;AAAA;AAAA,EAGb,OAAO,GAAgB;AAAA,IACrB,OAAO;AAAA,MACL,SAAS,KAAK;AAAA,MACd,MAAM,CAAC;AAAA,MACP,QAAQ,KAAK;AAAA,MACb,UAAU,KAAK;AAAA,MACf,MAAM,KAAK;AAAA,IACb;AAAA;AAAA,MAGE,OAAO,GAAqB;AAAA,IAC9B,OAAO;AAAA,OACJ,OAAO,gBAAgB,MAAM,KAAK,QAAQ;AAAA,IAC7C;AAAA;AAAA,MAEE,QAAQ,GAAqB;AAAA,IAC/B,OAAO;AAAA,OACJ,OAAO,gBAAgB,MAAM,KAAK,eAAe;AAAA,IACpD;AAAA;AAAA,SAGK,OAAO,GAAG;AAAA,IACf,WAAW,QAAO,KAAK,MAAM;AAAA,MAC3B,MAAM,sBAAI,KAAK,MAAM,IAAG;AAAA,IAC1B;AAAA;AAAA,SAEK,cAAc,GAAG;AAAA,IACtB,WAAW,QAAO,KAAK,KAAK,QAAQ,GAAG;AAAA,MACrC,MAAM,sBAAI,KAAK,MAAM,IAAG;AAAA,IAC1B;AAAA;AAEJ;;;AMtLA,MAAqB,cAErB;AAAA,MACM,IAAI,GAAG;AAAA,IACT,OAAO;AAAA;AAAA,EAET;AAAA,EACA,KAAK,GAAqB;AAAA,IACxB,OAAO,IAAI;AAAA;AAAA,EAGb,IAAI,CAAC,aAAiC;AAAA,IACpC,KAAK,aAAa;AAAA,IAClB,OAAO;AAAA;AAAA,EAGT,OAAO,CAAC,OAA6B;AAAA,IACnC,OAAO,QAAQ,QAAQ,CAAC,CAAC;AAAA;AAAA,EAG3B,KAAK,CAAC,OAAc;AAAA,IAClB,OAAO,QAAQ,QAAQ;AAAA;AAE3B;;;ACvBO,SAAS,2BAA2C,CACzD,aAC6B;AAAA,EAC7B,MAAM,OAAmC,CAAC;AAAA,EAC1C,KAAI,QAAQ,YAAW,QAAQ,OAAO;AAAA,EACtC,KAAI,OAAO,YAAW;AAAA,EACtB,KAAI,SAAS,YAAW,UAAU;AAAA,EAClC,KAAI,MAAM,YAAW,MAAM,YAAW,MAAM;AAAA,EAC5C,KAAI,OAAO,YAAW;AAAA,EACtB,KAAI,UAAU,YAAW,QAAQ;AAAA,EACjC,KAAI,OAAO,YAAW,KAAK;AAAA,EAC3B,KAAI,KAAK,YAAW,MAAM;AAAA,EAC1B,KAAI,OAAO,YAAW,QAAQ;AAAA,EAG9B,KAAI,YAAY,OAAO,KAAK,YAAW,SAAS,EAAE,IAAI,CAAC,UAAS;AAAA,IAC9D,MAAM,OAAM,YAAW,UAAU;AAAA,IACjC,OAAO,eAAkB,IAAG;AAAA,GAC7B;AAAA,EACD,OAAO;AAAA;;;AzDgCF,IAAM,UAAU;AAAA;AAEvB,MAAqB,WAAyD;AAAA,MACxE,MAAM,GAAgC;AAAA,IACxC,OAAO,4BAA4B,IAAI;AAAA;AAAA,SAIlC,WAAiD;AAAA,IACtD;AAAA,IACA;AAAA,EACF;AAAA,EAEA;AAAA,EACA;AAAA,OACM,YAAW,CAAC,OAAc,SAAoC;AAAA,IAClE,aAAa,MAAM,OAAM,OAAM;AAAA,IAC/B,MAAM,eAAe,IAAI;AAAA;AAAA,EAK3B,WAAW,CAAC,OAAc;AAAA,IACxB,KAAK,OAAM;AAAA,MACT,OAAO,OAAO,KAAK,KAAK,OAAO,EAAE,IAAI,CAAC,WAAU;AAAA,QAC9C;AAAA,QACA,KAAK,EAAE,MAAM,KAAK,QAAQ,OAAM;AAAA,MAClC,EAAE;AAAA,IACJ,EAAO;AAAA,MACL,IAAI,KAAK,QAAQ,QAAO;AAAA,QACtB,OAAO,CAAC,EAAE,aAAM,MAAM,EAAE,MAAM,KAAK,QAAQ,OAAM,EAAE,CAAC;AAAA,MACtD,EAAO;AAAA,QACL,OAAO,CAAC;AAAA;AAAA;AAAA;AAAA,EAKd,SAAS,CAAC,OAAc;AAAA,IACtB,OAAO,KAAK,QAAQ;AAAA;AAAA,EAGtB;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA,aAAyB;AAAA,EACzB,SAAS,CAAC,MAKN;AAAA,IACF,IAAI,KAAK,YAAY;AAAA,MACnB,OAAO,KAAK,WAAW,UAAU,IAAI;AAAA,IACvC,EAAO;AAAA,MACL,OAAO,EAAE,SAAS,MAAM,MAAM,KAAU;AAAA;AAAA;AAAA,EAI5C;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA;AAAA,EACA;AAAA,EAEA;AAAA,EAGQ,WAAW,GAAG;AAAA,SAEf,MAAsB,CAAC,QAA+B;AAAA,IAC3D,MAAM,aAA4B,IAAI;AAAA,IACtC;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA,KAAK;AAAA,QACH,MAAM;AAAA,QACN,MAAM;AAAA,QACN,KAAK;AAAA,MACP;AAAA,MACA,OAAO;AAAA,MACP;AAAA,MACA,OAAO,IAAI;AAAA,MACX,UAAU,IAAI;AAAA,MACd;AAAA,MACA;AAAA,MACA;AAAA,QACE,UAAU,CAAC;AAAA,IAEf,WAAW,UAAU;AAAA,IACrB,IAAI,YAAY;AAAA,MACd,WAAW,aAAa;AAAA,IAC1B;AAAA,IACA,WAAW,OAAO,QAAQ;AAAA,IAE1B,MAAM,QAAQ,mBAAmB,UAAU,CAAC;AAAA,IAE5C,IAAI,OAAO,SAAS,YAAY;AAAA,MAC9B,QAAQ,MAAM,SAAS;AAAA,IACzB;AAAA,IAEA,IAAI,QAAQ;AAAA,MACV,WAAW,UAAU,IAAI,oBAAQ,QAAQ,MAAM;AAAA,QAC7C,cAAc,UAAU;AAAA,OACzB;AAAA,MACD,WAAW,QAAQ,MAAM;AAAA,IAC3B;AAAA,IAEA,IAAI,KAAyB,OAAO,MAAM,WAAW,EAAE,MAAM,GAAG,IAAI;AAAA,IAEpE,IAAgB,OAAO,MAAnB,UAAuB;AAAA,MACzB,KAAK;AAAA,QACH,MAAM;AAAA,QACN,MAAM,QAAQ,OAAO,OAAO;AAAA,QAC5B,KAAK;AAAA,MACP;AAAA,IACF;AAAA,IAEA,KAAK,GAAG,MAAM;AAAA,MACZ,GAAG,OAAO;AAAA,IACZ;AAAA,IAEA,IAAI,GAAG,OAAO,MAAM;AAAA,MAClB,GAAG,MAAM;AAAA,IACX;AAAA,IAEA,KAAK,MAAM;AAAA,MACT,MAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAAA,IAEA,WAAW,OAAO,OAAO,OAAO,WAAW,MAAG,GAAG,IAAI,QAAQ;AAAA,IAE7D,WAAW,SAAS;AAAA,IACpB,WAAW,OAAO;AAAA,IAClB,WAAW,UAAU,QAAQ,KAAK,UAAU;AAAA,IAC5C,WAAW,KAAK,GAAG;AAAA,IACnB,WAAW,OAAO,GAAG;AAAA,IACrB,WAAW,UAAU,CAAC;AAAA,IACtB,WAAW,OAAO;AAAA,IAClB,WAAW,YAAY,CAAC;AAAA,IACxB,WAAW,UAAU,CAAC;AAAA,IACtB,WAAW,UAAU,CAAC;AAAA,IACtB,WAAW,UAAU,CAAC;AAAA,IACtB,WAAW,UAAU,CAAC;AAAA,IACtB,WAAW,WAAW,CAAC;AAAA,IAEvB,MAAM,WAA+B;AAAA,MACnC;AAAA,QACE,KAAK,WAAW;AAAA,QAEhB,MAAM,WAAW;AAAA,QACjB,KACE,OAAO,GAAG,OAAO,aACb,GAAG,MACH,GAAG,OAAO,WAAW,SAAS,GAAG,OAC/B,WAAW,SAAS,GAAG,OACvB,GAAG,MAAM,KAAK,GAAG,GAAG,IAAI;AAAA,QAChC,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,UAAU;AAAA,MACZ;AAAA,IACF;AAAA,IAEA,IAAI,WAAW,KAAK;AAAA,MAClB,SAAS,KAAK;AAAA,QACZ,KAAK;AAAA,QACL,MAAM;AAAA,QACN,KAAK,WAAW,SAAS;AAAA,QACzB,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,UAAU;AAAA,MACZ,CAAC;AAAA,IACH;AAAA,IAEA,IAAI,WAAW,QAAQ;AAAA,MACrB,SAAS,KAAK;AAAA,QACZ,KAAK;AAAA,QACL,MAAM;AAAA,QACN,KAAK,WAAW,SAAS;AAAA,QACzB,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,UAAU;AAAA,MACZ,CAAC;AAAA,IACH;AAAA,IAEA,cACE,YACA,SAAS,OAAO,aAAa,CAAC,CAAC,EAAE,OAAO,CAAC,MAAM,SAAS;AAAA,MACtD,IAAI,KAAK,OAAO,KAAK;AAAA,QACnB,KAAK,KAAK,OAAiB;AAAA,UACzB,KAAK;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,UACR,KAAK;AAAA,UACL,QAAQ;AAAA,UACR,UAAU;AAAA,UACV,YAAY;AAAA,QACd;AAAA,MACF,EAAO;AAAA,QAEL,IAAI;AAAA,UACF,MAAM,mBAAmB,kBAAkB,qBAAqB,IAAI;AAAA,UACpE,MAAM,mBAAmB,iBAAiB,SAAS;AAAA,UACnD,MAAM,WAAW,kBAAkB,kBAAkB,gBAAgB;AAAA,UAGrE,IAAI;AAAA,UACJ,IAAI,kBAAkB;AAAA,YACpB,YAAY,KAAK,aAAa,kBAAkB;AAAA,UAClD;AAAA,UAEA,KAAK,YAAY;AAAA,YACf,KAAK,mBAAmB,YAAY,iBAAiB,GAAG;AAAA,YACxD,MAAM,mBAAmB,mBAAmB;AAAA,YAC5C,QAAQ,mBAAmB,iBAAiB,GAAG,QAAQ;AAAA,YACvD;AAAA,YACA,MAAM,KAAK,QAAQ;AAAA,YACnB,QAAQ,KAAK,UAAU;AAAA,YACvB,KACE,KAAK,QACJ,KAAK,OAAO,WAAW,SAAS,kBAAkB;AAAA,YACrD,QAAQ,KAAK,UAAU;AAAA,YACvB,UAAU,KAAK,YAAY;AAAA,YAC3B,YAAY,KAAK;AAAA,YACjB,SAAS,KAAK;AAAA,UAChB;AAAA,UACA,OAAO,OAAO;AAAA,UACd,MAAM,IAAI,MAAM,6BAA6B,MAAM,SAAS;AAAA;AAAA;AAAA,MAGhE,OAAO;AAAA,OACN,CAAC,CAA4B,CAClC;AAAA,IACA,WAAW,KAAK,KAAK,UAAU;AAAA,IAE/B,eAAe,UAAU;AAAA,IAEzB,OAAO;AAAA;AAAA,cAGI,SAAwB,CACnC,QACA,KACA,OACA;AAAA,IACA,MAAM,QAAO,WAAW,OAAO;AAAA,MAC7B;AAAA,MACA,MAAM;AAAA,MACN,WAAW,CAAC,EAAE,KAAK,IAAI,GAAG,EAAE,KAAK,KAAI,QAAQ,MAAM,UAAU,KAAK,CAAC;AAAA,MACnE,IAAI,EAAE,MAAM,UAAU,MAAM,KAAK;AAAA,MACjC,MAAM,IAAI;AAAA,MACV,SAAS,IAAI;AAAA,IACf,CAAC;AAAA,IACD,MAAM,QAAQ,IAAI,OAAM,IAAI,CAAC,SAAS,MAAK,OAAO,IAAI,CAAC,CAAC;AAAA,IACxD,OAAO;AAAA;AAAA,OAGH,MAAK,GAAkB;AAAA,IAC3B,MAAM,KAAK,KAAK,MAAM;AAAA,IACtB,KAAK,UAAU,CAAC;AAAA,IAChB,eAAe,IAAI;AAAA;AAAA,OAGf,KAAI,CAAC,OAA8B;AAAA,IACvC,IAAI;AAAA,MACF,MAAM,SAAS,MAAM,KAAK,QAAQ,QAAQ,KAAI;AAAA,MAC9C,IAAI,QAAQ;AAAA,QACV,QAAQ,SAAS,aAAM,WAAW,SAAI,cAAQ;AAAA,QAC9C,KAAK,KAAK,KAAK,KAAI;AAAA,QACnB,KAAK,YAAY,cAAc,MAAM,SAAS;AAAA,QAC9C,KAAK,KAAK;AAAA,QACV,KAAK,MAAM;AAAA,QAEX,KAAK,UAAU,CAAC;AAAA,QAChB,KAAK,UAAU,CAAC;AAAA,QAChB,KAAK,UAAU,CAAC;AAAA,QAChB,KAAK,UAAU,CAAC;AAAA,QAEhB,KAAK,UAAU,CAAC;AAAA,QAChB,cAAc,MAAM,KAAK,SAAS;AAAA,QAElC,KAAK,UAAU,oBAAoB,OAAO;AAAA,QAC1C,MAAM,gBAAgB,IAAI;AAAA,MAC5B;AAAA,MACA,OAAO,GAAG;AAAA,IAGZ,MAAM,WAAW,IAAI;AAAA;AAAA,EAGvB,KAAK,GAOH;AAAA,IACA,OAAO;AAAA,MACL,MAAM,KAAK,KAAK,QAAQ;AAAA,MACxB,SAAS,kBAAkB,KAAK,OAAO;AAAA,MACvC,WAAW,YAAY,MAAM,KAAK,SAAS;AAAA,MAC3C,IAAI,KAAK;AAAA,MACT,KAAK,KAAK;AAAA,MACV,QAAQ,KAAK,SAAS,SAAS,KAAK,MAAM,IAAI;AAAA,IAChD;AAAA;AAAA,OAGI,QAAO,CAAC,OAA8B;AAAA,IAC1C,MAAM,KAAK,QAAQ,MAAM,KAAI;AAAA;AAAA,OAIzB,KAAI,CAAC,MAAiC;AAAA,IAE1C,MAAM,wBAAwB,qBAAqB,MAAM,IAAI;AAAA,IAC7D,MAAM,MAAK,KAAK,KAAK;AAAA,IACrB,MAAM,OAAM,MAAM,KAAK,KAAK,IAAI,KAAI,IAAI;AAAA,IACxC,sBAAsB,GAAE;AAAA,IACxB,OAAO,oBAAoB,MAAM,IAAG;AAAA;AAAA,OAGhC,OAAM,CAAC,MAAiC;AAAA,IAC5C,MAAM,OAAM,KAAK,KAAK;AAAA,IACtB,MAAM,QAAQ,MAAM,KAAK,KAAK,IAAG;AAAA,IACjC,OAAO;AAAA;AAAA,OAGH,KAAI,CAAC,MAAgC;AAAA,IACzC,MAAM,MAAK,KAAI,KAAK;AAAA,IACpB,MAAM,OAAO,MAAM,KAAK,SAAS,GAAE;AAAA,IACnC,MAAM,aAAa,MAAM,MAAW,MAAU,GAAE;AAAA,IAChD,MAAM,KAAK,KAAK,OAAO,KAAI,IAAG;AAAA,IAC9B,OAAO,oBAAoB,MAAM,IAAG;AAAA;AAAA,OAGhC,MAAK,GAAe;AAAA,IACxB,QAAQ,MAAM,MAAM,MAAM,MAAM,IAAI,EAAE,KAAK,GAAG;AAAA;AAAA,OAG1C,KAAI,GAAe;AAAA,IACvB,QAAQ,MAAM,KAAK,MAAM,MAAM,IAAI,EAAE,KAAK,GAAG;AAAA;AAAA,EAG/C,MAAM,CAAC,MAAuC;AAAA,IAC5C,OAAO,KAAK,YAAY,MAAK,KAAK,QAAQ,MAAK,GAAG;AAAA;AAAA,EAGpD,QAAQ,CAAC,MAAuC;AAAA,IAC9C,OAAO,KAAK,WAAW,MAAK,KAAK,QAAQ,MAAK,GAAG;AAAA;AAAA,EAGnD,MAAM,GAA2B;AAAA,IAC/B,IAAI,KAAK,KAAK;AAAA,MACZ,OAAO,KAAK,OAAO,OAAc;AAAA,IACnC,EAAO;AAAA,aAAO,KAAK,MAAM;AAAA;AAAA,EAG3B,MAAM,GAA2B;AAAA,IAC/B,IAAI,KAAK,KAAK;AAAA,MACZ,OAAO,KAAK,SAAS,OAAc;AAAA,IACrC,EAAO;AAAA,aAAO,KAAK,KAAK;AAAA;AAAA,OAGpB,SAAQ,CAAC,KAAuC;AAAA,IACpD,MAAM,WAAW,KAAK,UAAU,KAAK;AAAA,IACrC,IAAI,UAAU,SAAS;AAAA,MACrB,MAAK,SAAS,QAAQ,GAAE;AAAA,IAC1B;AAAA,IACA,MAAM,QAAQ,KAAK,QAAQ,KAAK;AAAA,IAChC,KAAK,OAAO;AAAA,MACV,MAAM,IAAI,MAAM,aAAa,KAAK,cAAc;AAAA,IAClD;AAAA,IACA,MAAM,SAAS,MAAM,KAAK,KAAK,IAAI,MAAM,UAAU,GAAE,CAAC;AAAA,IACtD,OAAO,oBAAoB,MAAM,MAAM;AAAA;AAAA,OAGnC,OAAM,CAAC,MAAe,KAAkC;AAAA,IAC5D,IAAI,KAAK,UAAU,eAAe,IAAG,GAAG;AAAA,MACtC,MAAM,WAAW,KAAK,UAAU;AAAA,MAIhC,MAAM,sBAAsB,SAAS,QAAQ,SAAS,KAAK,SAAS;AAAA,MAC5D,IAAI,UAAU,YAAY,kBAAkB;AAAA,QAClD,MAAK,SAAS,QAAQ,GAAE;AAAA,MAC1B;AAAA,MAEA,MAAM,SAAS,CAAC;AAAA,MAChB,IAAI,KAAK,UAAU,eAAe,IAAG,GAAG;AAAA,QACtC,OAAO,KAAK,GAAI,MAAM,kBAAkB,MAAM,MAAK,GAAE,CAAE;AAAA,MACzD;AAAA,MACA,OAAO,qBAAqB,MAAM,MAAM;AAAA,IAC1C,EAAO;AAAA,MACL,MAAM,IAAI,MAAM,aAAa,gBAAe;AAAA;AAAA;AAAA,OAI1C,YAAW,CAAC,MAAe,KAAuC;AAAA,IACtE,IAAI,KAAK,UAAU,eAAe,IAAG,GAAG;AAAA,MACtC,MAAM,WAAW,KAAK,UAAU;AAAA,MAGhC,MAAM,sBAAsB,SAAS,QAAQ,SAAS,KAAK,SAAS;AAAA,MACpE,IAAI,UAAU,YAAY,kBAAkB;AAAA,QAC1C,MAAK,SAAS,QAAQ,GAAE;AAAA,MAC1B;AAAA,MAEA,IAAI,KAAK,UAAU,eAAe,IAAG,GAAG;AAAA,QACtC,MAAM,SAAS,MAAM,wBAAwB,MAAM,MAAK,GAAE;AAAA,QAC1D,OAAO,oBAAoB,MAAM,MAAM;AAAA,MACzC;AAAA,IACF;AAAA,IACA,MAAM,IAAI,MAAM,aAAa,gBAAe;AAAA;AAAA,OAGxC,WAAU,CAAC,MAAe,KAAuC;AAAA,IACrE,IAAI,KAAK,UAAU,eAAe,IAAG,GAAG;AAAA,MACtC,MAAM,WAAW,KAAK,UAAU;AAAA,MAGhC,MAAM,sBAAsB,SAAS,QAAQ,SAAS,KAAK,SAAS;AAAA,MACpE,IAAI,UAAU,YAAY,kBAAkB;AAAA,QAC1C,MAAK,SAAS,QAAQ,GAAE;AAAA,MAC1B;AAAA,MAEA,IAAI,KAAK,UAAU,eAAe,IAAG,GAAG;AAAA,QACtC,MAAM,SAAS,MAAM,uBAAuB,MAAM,MAAK,GAAE;AAAA,QACzD,OAAO,oBAAoB,MAAM,MAAM;AAAA,MACzC;AAAA,IACF;AAAA,IACA,MAAM,IAAI,MAAM,aAAa,gBAAe;AAAA;AAAA,OAGxC,KAAI,CAAC,WAAoD;AAAA,IAC7D,MAAM,SAAmB,CAAC;AAAA,IAC1B,iBAAiB,QAAQ,IAAI,MAAM,SAAS,GAAG;AAAA,MAC7C,OAAO,KAAK,IAAI;AAAA,IAClB;AAAA,IACA,OAAO,qBAAqB,MAAM,MAAM;AAAA;AAAA,OAGpC,UAAS,CAAC,WAAyD;AAAA,IACvE,MAAM,SAAY,OAAO,MAAM,MAAM,MAAM,SAAS,EAAE,KAAK,GAAG;AAAA,IAC9D,OAAO,oBAAoB,MAAM,MAAM;AAAA;AAAA,OAGnC,SAAQ,CAAC,WAAyD;AAAA,IACtE,MAAM,SAAY,OAAO,MAAM,KAAK,MAAM,SAAS,EAAE,KAAK,GAAG;AAAA,IAC7D,OAAO,oBAAoB,MAAM,MAAM;AAAA;AAAA,OAGnC,OAAM,CACV,WACA,QACA,SAAiB,MACE;AAAA,IACnB,MAAM,SAAmB,CAAC;AAAA,IAC1B,iBAAiB,QAAQ,IAAI,MAAM,SAAS,GAAG;AAAA,MAC7C,MAAM,OAAM,SAAU,SAAM,CAAC,GAAG,MAAM,MAAM,IAAM,UAAO,CAAC,GAAG,MAAM,MAAM;AAAA,MACzE,MAAM,aAAa,MAAM,MAAM,MAAU,KAAK,KAAK,GAAG;AAAA,MACtD,MAAM,KAAK,KAAK,OAAO,KAAK,KAAK,KAAK,IAAG;AAAA,MACzC,OAAO,KAAK,IAAG;AAAA,IACjB;AAAA,IACA,OAAO,qBAAwB,MAAM,MAAM;AAAA;AAAA,OAGvC,YAAW,CACf,WACA,QACA,SAAiB,MACO;AAAA,IACxB,MAAM,OAAU,OAAO,MAAM,MAAM,MAAM,SAAS,EAAE,KAAK,GAAG;AAAA,IAC5D,MAAM,OAAM,SAAU,SAAM,CAAC,GAAG,MAAM,MAAM,IAAM,UAAO,CAAC,GAAG,MAAM,MAAM;AAAA,IACzE,MAAM,aAAa,MAAM,MAAM,MAAU,KAAK,KAAK,GAAG;AAAA,IACtD,MAAM,KAAK,KAAK,OAAO,KAAK,KAAK,KAAK,IAAG;AAAA,IACzC,OAAO,oBAAoB,MAAM,IAAQ;AAAA;AAAA,OAGrC,WAAU,CACd,WACA,QACA,SAAiB,MACO;AAAA,IACxB,MAAM,OAAU,OAAO,MAAM,KAAK,MAAM,SAAS,EAAE,KAAK,GAAG;AAAA,IAC3D,MAAM,OAAM,SAAU,SAAM,CAAC,GAAG,MAAM,MAAM,IAAM,UAAO,CAAC,GAAG,MAAM,MAAM;AAAA,IACzE,MAAM,aAAa,MAAM,MAAM,MAAU,KAAK,KAAK,GAAG;AAAA,IACtD,MAAM,KAAK,KAAK,OAAO,KAAK,KAAK,KAAK,IAAG;AAAA,IAEzC,OAAO,oBAAoB,MAAM,IAAQ;AAAA;AAAA,OAGrC,aAAY,CAChB,KACA,QACA,SAAiB,MACO;AAAA,IACxB,MAAM,OAAO,MAAM,KAAK,SAAS,GAAE;AAAA,IACnC,MAAM,OAAM,SAAU,SAAM,CAAC,GAAG,MAAM,MAAM,IAAM,UAAO,CAAC,GAAG,MAAM,MAAM;AAAA,IACzE,MAAM,aAAa,MAAM,MAAW,MAAU,GAAE;AAAA,IAChD,MAAM,KAAK,KAAK,OAAO,KAAI,IAAG;AAAA,IAC9B,OAAO,oBAAoB,MAAM,IAAQ;AAAA;AAAA,OAGrC,aAAY,CAAC,KAAuC;AAAA,IACxD,MAAM,WAAW,KAAK,UAAU,KAAK;AAAA,IACrC,IAAI,UAAU,SAAS;AAAA,MACrB,MAAK,SAAS,QAAQ,GAAE;AAAA,IAC1B;AAAA,IACA,MAAM,QAAQ,KAAK,QAAQ,KAAK;AAAA,IAChC,KAAK,OAAO;AAAA,MACV,MAAM,IAAI,MAAM,aAAa,KAAK,cAAc;AAAA,IAClD;AAAA,IACA,MAAM,IAAI,MAAM,UAAU,GAAE;AAAA,IAC5B,MAAM,MAAM,MAAM,KAAK,KAAK,IAAI,CAAC;AAAA,IACjC,IAAI,MAAM,aAAa,KAAK;AAAA,MAC1B,aAAa,MAAM,GAAG;AAAA,MACtB,MAAM,SAAS,MAAM,KAAK,KAAK,OAAO,GAAE;AAAA,MACxC,OAAO,oBAAoB,MAAM,MAAM;AAAA,IACzC;AAAA;AAAA,OAGI,OAAM,CAAC,WAAgE;AAAA,IAC3E,MAAM,SAAmB,CAAC;AAAA,IAC1B,iBAAiB,OAAO,IAAI,MAAM,SAAS,GAAG;AAAA,MAC5C,aAAa,MAAM,GAAG;AAAA,MACtB,MAAM,OAAM,MAAM,KAAK,KAAK,OAAO,IAAI,KAAK,GAAG;AAAA,MAC/C,OAAO,KAAK,IAAG;AAAA,IACjB;AAAA,IACA,OAAO,qBAAwB,MAAM,MAAM;AAAA;AAAA,OAGvC,YAAW,CAAC,WAAyD;AAAA,IACzE,MAAM,OAAU,OAAO,MAAM,MAAM,MAAM,SAAS,EAAE,KAAK,GAAG;AAAA,IAC5D,aAAa,MAAM,IAAI;AAAA,IACvB,MAAM,KAAK,KAAK,OAAO,KAAK,KAAK,GAAG;AAAA,IACpC,OAAO,oBAAoB,MAAM,IAAI;AAAA;AAAA,OAEjC,WAAU,CAAC,WAAyD;AAAA,IACxE,MAAM,OAAU,OAAO,MAAM,KAAK,MAAM,SAAS,EAAE,KAAK,GAAG;AAAA,IAC3D,aAAa,MAAM,IAAI;AAAA,IACvB,MAAM,KAAK,KAAK,OAAO,KAAK,KAAK,GAAG;AAAA,IACpC,OAAO,oBAAoB,MAAM,IAAI;AAAA;AAEzC;AAEO,SAAS,cAA8B,CAC5C,MACoB;AAAA,EACpB,OAAO;AAAA,IACL,KAAK,KAAI;AAAA,IACT,MAAM,KAAI;AAAA,IACV,OAAO,KAAI;AAAA,IACX,WAAW,KAAI;AAAA,IACf,MAAM,KAAI,OAAO,OAAO;AAAA,IACxB,QAAQ,KAAI,SAAS,OAAO;AAAA,IAC5B,QAAQ,KAAI,SAAS,OAAO;AAAA,IAC5B,YAAY,KAAI,aAAa,OAAO;AAAA,IACpC,UAAU,KAAI,WAAW,OAAO;AAAA,IAChC,KAAK,KAAI,KAAK,QAAQ;AAAA,IACtB,SAAS,KAAI,SAAS,SAAS,KAAK;AAAA,EACtC;AAAA;AAGK,SAAS,gBAAgC,CAC9C,KACa;AAAA,EACb,OAAO;AAAA,IACL,KAAK,IAAI;AAAA,IACT,MAAM,IAAI;AAAA,IACV,OAAO,IAAI;AAAA,IACX,WAAW,IAAI;AAAA,IACf,MAAM,IAAI,OAAO,OAAO;AAAA,IACxB,QAAQ,IAAI,SAAS,OAAO;AAAA,IAC5B,QAAQ,IAAI,SAAS,OAAO;AAAA,IAC5B,YAAY,IAAI,aAAa,OAAO;AAAA,IACpC,UAAU,IAAI,WAAW,OAAO;AAAA,IAChC,KAAK,IAAI,MAAM,WAAW,SAAS,IAAI,OAAO;AAAA,IAC9C,SAAS,IAAI,UAAU,KAAK,IAAI,OAAO,IAAI;AAAA,EAC7C;AAAA;;;A0D5oBmC,IAArC;AAGe,IAAf;AACoB,IAApB;AAQ0B,IAA1B;AAC6B,IAA7B;AAGO,MAAM,YAEb;AAAA,MACM,IAAI,GAAG;AAAA,IACT,OAAO;AAAA;AAAA,EAET,aAAsB;AAAA,EAMtB,OAAqC,IAAI,4BAAU,IAAI,IAAI;AAAA,MACvD,MAAM,GAAW;AAAA,IACnB,OAAO,qBAAQ,KAAK,KAAK,WAAW,MAAM,KAAK,WAAW,IAAI;AAAA;AAAA,EAExD;AAAA,EACR,WAAW,CAAC,UAAmB;AAAA,IAC7B,KAAK,WAAW;AAAA;AAAA,EAElB;AAAA,EACA;AAAA,EACA,SAAS,GAAG;AAAA,IACV,OAAO,IAAI;AAAA;AAAA,EAGb,IAAI,CAAC,aAAqC;AAAA,IACxC,KAAK,aAAa;AAAA,IAClB,IAAI,KAAK,aAAa,KAAK,WAAW,UAAU,KAAK,UAAU,QAAQ;AAAA,MACrE,MAAM,IAAI,MAAM,aAAa,KAAK,wBAAwB;AAAA,IAC5D;AAAA,IACA,KAAK,SAAS,yBACX,UAAU,KAAK,MAAM,EACrB,KAAK,CAAC,OAAM,IAAI,EAChB,MAAM,CAAC,OAAM,KAAK;AAAA,IACrB,OAAO;AAAA;AAAA,OAEH,MAAK,GAAsB;AAAA,IAC/B,IAAI,MAAM,KAAK,QAAQ;AAAA,MACrB,MAAM,OAAM,IAAI;AAAA,MAChB,KAAI,OAAO,eAAe,KAAK,IAAI;AAAA,MACnC,OAAO;AAAA,IACT;AAAA,IACA,MAAM,IAAI,MAAM,kBAAkB;AAAA;AAAA,EAEpC,OAAO,GAAgB;AAAA,IACrB,OAAO;AAAA,MACL,UAAU,KAAK;AAAA,MACf,SAAS,KAAK;AAAA,MACd,MAAM,mBAAmB,KAAK,IAAI;AAAA,IACpC;AAAA;AAAA,EAGF,IAAI,CAAC,KAA4B;AAAA,IAC/B,KAAK,WAAW,IAAI;AAAA,IAEpB,KAAK,YAAY,IAAI,WACjB,KAAK,WACL,KAAK,WACL,KAAK,WACL,IAAI;AAAA,IACR,KAAK,OAAO,qBAAqB,IAAI,IAAI;AAAA,IACzC,OAAO;AAAA;AAAA,MAGL,OAAO,GAAG;AAAA,IACZ,OAAO;AAAA,OACJ,OAAO,gBAAgB,MAAM,KAAK,QAAQ;AAAA,IAC7C;AAAA;AAAA,MAGE,QAAQ,GAAG;AAAA,IACb,OAAO;AAAA,OACJ,OAAO,gBAAgB,MAAM,KAAK,eAAe;AAAA,IACpD;AAAA;AAAA,SAGK,OAAO,GAAG;AAAA,IACf,MAAM,OAAM,MAAM,KAAK;AAAA,IACvB,IAAI,MAAK;AAAA,MACP,MAAM,KAAK,KAAK,KAAK,KAAK,EAAE,KAAK,IAAI;AAAA,MACrC,IAAI,SAAS,GAAG,KAAK;AAAA,MACrB,QAAQ,OAAO,QAAQ,OAAO,OAAO;AAAA,QACnC,MAAM,MAAM,yBAAG,SAAS,KAAK,SAAS,OAAO,MAAM,KAAK,CAAC;AAAA,QACzD,SAAS,GAAG,KAAK;AAAA,MACnB;AAAA,IACF,EAAO;AAAA,YAAM,IAAI,MAAM,kBAAkB;AAAA;AAAA,SAGpC,cAAc,GAAG;AAAA,IACtB,IAAI,MAAM,KAAK,QAAQ;AAAA,MACrB,MAAM,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE,KAAK,IAAI;AAAA,MAC1C,IAAI,SAAS,GAAG,KAAK;AAAA,MACrB,QAAQ,OAAO,QAAQ,OAAO,OAAO;AAAA,QACnC,MAAM,MAAM,yBAAG,SAAS,KAAK,SAAS,OAAO,MAAM,KAAK,CAAC;AAAA,QACzD,SAAS,GAAG,KAAK;AAAA,MACnB;AAAA,IACF,EAAO;AAAA,YAAM,IAAI,MAAM,kBAAkB;AAAA;AAAA,EAGnC,YAAY,CAAC,MAAgB;AAAA,IACnC,OAAO,GAAG,MAAK,SAAS,KAAK;AAAA;AAAA,EAGvB,QAAQ,CAAC,MAAgB;AAAA,IAC/B,OAAO,qBAAQ,KAAK,KAAK,QAAQ,KAAK,aAAa,IAAG,CAAC;AAAA;AAAA,EAGjD,QAAQ,CAAC,OAAe;AAAA,IAC9B,OAAO,qBAAQ,KAAK,KAAK,QAAQ,KAAK;AAAA;AAAA,OAGlC,MAAK,GAAkB;AAAA,IAC3B,IAAI,MAAM,KAAK,QAAQ;AAAA,MACrB,MAAM,yBAAG,OAAO,KAAK,MAAM;AAAA,MAC3B,KAAK,KAAK,MAAM;AAAA,MAChB,KAAK,SAAS,yBACX,UAAU,KAAK,MAAM,EACrB,KAAK,CAAC,OAAM,IAAI,EAChB,MAAM,CAAC,OAAM,KAAK;AAAA,IACvB,EAAO;AAAA,YAAM,IAAI,MAAM,kBAAkB;AAAA;AAAA,OAGrC,IAAG,CAAC,MAAwC;AAAA,IAChD,IAAI,MAAM,KAAK,QAAQ;AAAA,MACrB,MAAM,QAAQ,KAAK,KAAK,UAAU,IAAG;AAAA,MACrC,IAAI,OAAO;AAAA,QACT,MAAM,WAAW,KAAK,SAAS,KAAK;AAAA,QACpC,MAAM,SAA+B,MAAM,yBAAG,SAAS,QAAQ;AAAA,QAC/D,IAAI,iBAAiB,MAAM,GAAG;AAAA,UAC5B,KAAK,KAAK,WAAW,OAAO;AAAA,YAC1B,MAAM,yBAAG,UAAU,UAAU,MAAM;AAAA,UACrC;AAAA,UACA,OAAO,OAAO;AAAA,QAChB,EAAO;AAAA,UACL,OAAO;AAAA;AAAA,MAEX;AAAA,IACF;AAAA,IACA,MAAM,IAAI,MAAM,kBAAkB;AAAA;AAAA,OAG9B,IAAG,CAAC,MAAgB,MAAqB;AAAA,IAC7C,IAAI,MAAM,KAAK,QAAQ;AAAA,MACrB,IAAI,YAAY,KAAK,WAAW,UAAU,IAAI;AAAA,MAC9C,IAAI,UAAU,SAAS;AAAA,QACrB,KAAK;AAAA,QAGL,MAAM,MAAM,KAAK,WACb,KAAK,KAAK,YACR,KAAK,KAAK,YACV,OACF;AAAA,QAIJ,IAAI;AAAA,QACJ,IAAI,KAAK,WAAW,OAAO;AAAA,UACzB,SAAS,cACP,KAAK,KAAK,WAAW,KACrB,4BAAU,IAAI,GACd,KAAK,WAAW,UAClB;AAAA,QACF,EAAO;AAAA,UACL,SAAS,4BAAU,IAAI;AAAA;AAAA,QAGzB,MAAM,yBAAG,UAAU,KAAK,SAAS,GAAG,GAAG,MAAM;AAAA,QAE7C,KAAK,KAAK,OAAO,MAAK,KAAK,aAAa,GAAG,CAAC;AAAA,QAC5C,OAAO,KAAK,WAAW,QAAS,OAA4B,OAAQ;AAAA,MACtE,EAAO;AAAA,QACL,QAAQ,IAAI,yCAAc,UAAkB,MAAM,CAAC;AAAA,QACnD,MAAM,IAAI,MAAM,kBAAkB;AAAA;AAAA,IAEtC;AAAA,IACA,MAAM,IAAI,MAAM,kBAAkB;AAAA;AAAA,OAG9B,OAAM,CAAC,MAAgB,MAAqB;AAAA,IAEhD,IAAI,MAAM,KAAK,QAAQ;AAAA,MACrB,IAAI,YAAY,KAAK,WAAW,UAAU,IAAI;AAAA,MAC9C,IAAI,UAAU,SAAS;AAAA,QAErB,MAAM,WAAW,KAAK,SAAS,KAAK,KAAK,UAAU,IAAG,CAAC;AAAA,QACvD,IAAI,SAAY;AAAA,QAEhB,MAAM,SAAU,MAAM,yBAAG,SAAS,QAAQ;AAAA,QAC1C,IAAI,KAAK,WAAW,OAAO;AAAA,UACzB,IAAI;AAAA,UACJ,KAAK,iBAAiB,MAAM,GAAG;AAAA,YAC7B,OAAM,cACJ,KAAK,KAAK,WAAW,KACrB,4BAAU,IAAI,GACd,KAAK,WAAW,UAClB;AAAA,UACF,EAAO;AAAA,YACL,OAAM,cAAiB,QAAQ,4BAAU,IAAI,CAAC;AAAA;AAAA,UAEhD,SAAS,KAAI;AAAA,UACb,MAAM,yBAAG,UAAU,UAAU,IAAG;AAAA,QAClC,EAAO;AAAA,UAEL,MAAM,yBAAG,UAAU,UAAU,MAAM;AAAA;AAAA,QAErC,OAAO;AAAA,MACT,EAAO;AAAA,QACL,QAAQ,IAAI,yCAAc,UAAkB,MAAM,CAAC;AAAA,QACnD,MAAM,IAAI,MAAM,kBAAkB;AAAA;AAAA,IAEtC;AAAA,IACA,MAAM,IAAI,MAAM,kBAAkB;AAAA;AAAA,OAG9B,OAAM,CAAC,MAA4B;AAAA,IACvC,IAAI,MAAM,KAAK,QAAQ;AAAA,MACrB,MAAM,QAAQ,KAAK,KAAK,UAAU,IAAG;AAAA,MACrC,IAAI,OAAO;AAAA,QACT,MAAM,WAAW,KAAK,SAAS,KAAK;AAAA,QACpC,MAAM,OAAO,MAAM,yBAAG,SAAS,QAAQ;AAAA,QACvC,IAAI;AAAA,QACJ,IAAI,iBAAoB,IAAI,GAAG;AAAA,UAC7B,SAAS,KAAK;AAAA,UACd,MAAM,OAAM,cAAc,IAAI;AAAA,UAC9B,MAAM,yBAAG,UAAU,UAAU,IAAG;AAAA,QAClC,EAAO;AAAA,UACL,SAAS;AAAA,UACT,MAAM,yBAAG,OAAO,QAAQ;AAAA;AAAA,QAE1B,KAAK,KAAK,OAAO,IAAG;AAAA,QACpB,OAAO;AAAA,MACT;AAAA,IACF;AAAA,IACA,MAAM,IAAI,MAAM,kBAAkB;AAAA;AAAA,EAGpC,WAAmB;AAAA,MACf,OAAO,GAAW;AAAA,IACpB,OAAO,KAAK;AAAA;AAAA,MAEV,MAAM,GAAW;AAAA,IACnB,OAAO,KAAK,KAAK;AAAA;AAErB;;;ACrQe,IAAf;AACiB,IAAjB;AACgB,IAAhB;;;ACSO,SAAS,6BAA6C,CAC3D,SACA;AAAA,EACA,MAAM,OAAM,CAAC;AAAA,EACb,KAAI,OAAO,QAAO;AAAA,EAClB,KAAI,OAAO,QAAO;AAAA,EAClB,KAAI,SAAS,QAAO;AAAA,EACpB,KAAI,MAAM,QAAO;AAAA,EACjB,KAAI,QAAQ,SAAQ,SAAS;AAAA,EAC7B,KAAI,KAAK,QAAO,MAAM;AAAA,EACtB,KAAI,OAAO,QAAO;AAAA,EAClB,KAAI,YAAY,QAAO,UAAU,IAAI,CAAC,UAAU,iBAAoB,KAAK,CAAC;AAAA,EAC1E,KAAI,UACF,QAAO,YAAY,kBAAkB,IAAI,gBAAkB,IAAI;AAAA,EACjE,KAAI,OACF,QAAO,SAAS,SAAS,IAAI,OAAY,IAAI;AAAA,EAC/C,OAAO;AAAA;;;ADFF,MAAM,WAAoC;AAAA,EACvC;AAAA,EACA;AAAA,EACA,gBAAgB;AAAA,EAChB;AAAA,EAER,WAAW,CAAC,OAAc,OAAe;AAAA,IACvC,KAAK,OAAO;AAAA,IACZ,KAAK,OAAO,SAAQ;AAAA,IACpB,KAAK,cAAc,IAAI;AAAA;AAAA,OAGX,YAAW,GAAG;AAAA,IAC1B,MAAM,SAAS,CAAC;AAAA,IAChB,KAAK,YAAY,QAAQ,CAAC,aAAY,UAAS;AAAA,MAC7C,OAAO,SAAQ,4BAA4B,WAAU;AAAA,KACtD;AAAA,IACD,MAAM,yBAAI,UAAU,KAAK,IAAI;AAAA,IAC7B,kBAAG,cAAc,qBAAK,KAAK,KAAK,MAAM,GAAG,KAAK,WAAW,GAAG,KAAK,UAAU,QAAQ,MAAM,CAAC,CAAC;AAAA;AAAA,OAGvF,QAAO,GAAG;AAAA,IACd,MAAM,KAAK,KAAK;AAAA;AAAA,OAGZ,KAAI,GAAG;AAAA,IACX,MAAM,SAAS,kBAAG,WAAW,qBAAK,KAAK,KAAK,MAAM,GAAG,KAAK,WAAW,CAAC;AAAA,IACtE,KAAK,QAAQ;AAAA,MACX,yBAAI,cAAc,KAAK,IAAI;AAAA,IAC7B,EAAO;AAAA,MACL,MAAM,SAAS,yBAAI,aAAa,qBAAK,KAAK,KAAK,MAAM,GAAG,KAAK,WAAW,CAAC;AAAA,MAKzE,KAAK,YAAY,MAAM;AAAA,MACvB,WAAW,SAAQ,QAAQ;AAAA,QACzB,MAAM,UAAS,OAAO;AAAA,QACtB,MAAM,cAAa,WAAW,OAAO,8BAA8B,OAAM,CAAC;AAAA,QAC1E,MAAM,YAAW,KAAK;AAAA,QACtB,KAAK,mBAAmB,WAAU;AAAA,MACpC;AAAA;AAAA;AAAA,OAIE,MAAK,GAAG;AAAA,EAEd,iBAAsD,IAAI;AAAA,EAElD,kBAAkB,CAAC,aAA6B;AAAA,IACtD,KAAK,KAAK,YAAY,IAAI,YAAW,IAAI,GAAG;AAAA,MAC1C,KAAK,YAAY,IAAI,YAAW,MAAM,WAAU;AAAA,MAChD;AAAA,IACF;AAAA,IACA,MAAM,IAAI,MAAM,cAAc,YAAW,qBAAqB;AAAA;AAAA,OAG1D,iBAAgC,CAAC,OAA2C;AAAA,IAChF,SAAS,iBAAiB,UAAU,MAAK,MAAM,GAAG;AAAA,IAClD,MAAM,cAAa,WAAW,OAAO;AAAA,MACnC;AAAA,MACA,MAAM,mBAAmB,SAAS,IAAI,OAAY,IAAI;AAAA,MACtD,SAAS,IAAI;AAAA,MACb,MAAM,qBAAK,KAAK,KAAK,MAAM,KAAK,IAAI;AAAA,IACtC,CAAC;AAAA,IAED,KAAK,mBAAmB,WAAU;AAAA,IAClC,MAAM,KAAK,YAAY;AAAA,IACvB,OAAO;AAAA;AAAA,EAGT,eAAe,GAAgC;AAAA,IAC7C,MAAM,SAAsC,CAAC;AAAA,IAC7C,KAAK,YAAY,QAAQ,CAAC,gBAAe;AAAA,MACvC,OAAO,KAAK,WAAU;AAAA,KACvB;AAAA,IACD,OAAO;AAAA;AAAA,OAGH,eAAc,CAAC,OAAgC;AAAA,IACnD,IAAI,SAAS;AAAA,IACb,IAAI,KAAK,YAAY,IAAI,KAAI,GAAG;AAAA,MAC9B,MAAM,cAAa,KAAK,YAAY,IAAI,KAAI;AAAA,MAC5C,MAAM,YAAW,MAAM;AAAA,MACvB,SAAS,KAAK,YAAY,OAAO,KAAI;AAAA,MACrC,MAAM,KAAK,YAAY;AAAA,IACzB;AAAA,IACA,OAAO;AAAA;AAAA,EAGT,UAA0B,CAAC,OAA8C;AAAA,IACvE,IAAI,KAAK,YAAY,IAAI,KAAI,GAAG;AAAA,MAC9B,OAAO,KAAK,YAAY,IAAI,KAAI;AAAA,IAClC;AAAA,IACA,MAAM,IAAI,MAAM,cAAc,iBAAgB;AAAA;AAAA,OAG1C,YAAW,CAAC,aAAoB,OAAc,KAAoB;AAAA,IACtE,IAAI,KAAK,YAAY,IAAI,WAAU,GAAG;AAAA,MACpC,MAAM,MAAM,KAAK,YAAY,IAAI,WAAU;AAAA,MAC3C,IAAI,IAAI,YAAY,KAAI,GAAG;AAAA,QACzB,IAAI,UAAU,KAAI;AAAA,QAClB,MAAM,IAAI,YAAY,OAAM,GAAG;AAAA,MACjC;AAAA,MACA,MAAM,KAAK,YAAY;AAAA,MACvB;AAAA,IACF;AAAA,IACA,MAAM,IAAI,MAAM,cAAc,uBAAsB;AAAA;AAAA,OAGhD,UAAS,CAAC,aAAoB,OAAc;AAAA,IAChD,IAAI,KAAK,YAAY,IAAI,WAAU,GAAG;AAAA,MACpC,KAAK,YAAY,IAAI,WAAU,GAAG,UAAU,KAAI;AAAA,MAChD,MAAM,KAAK,YAAY;AAAA,MACvB;AAAA,IACF;AAAA,IACA,MAAM,IAAI,MAAM,cAAc,uBAAsB;AAAA;AAAA,OAGhD,QAAO,GAAG;AAAA,IACd,MAAM,OAA4B,CAAC;AAAA,IACnC,KAAK,YAAY,QAAQ,CAAC,gBAAe;AAAA,MACvC,KAAI,KAAK,YAAW,QAAQ,CAAC;AAAA,KAC9B;AAAA,IACD,OAAO,QAAQ,IAAI,IAAG;AAAA;AAAA,OAGlB,aAAY,GAA2B;AAAA,IAC3C,KAAK,KAAK,eAAe;AAAA,MACvB,MAAM,KAAK,QAAQ;AAAA,IACrB;AAAA,IACA,OAAO;AAAA;AAAA,OAGH,WAAU,GAAkB;AAAA,IAChC,KAAK,gBAAgB;AAAA;AAAA,OAEjB,iBAAgB,CAAC,SAA4C;AAAA,IACjE,KAAK,gBAAgB;AAAA;AAAA,OAEjB,iBAAgB,GAAkB;AAAA,IACtC,KAAK,gBAAgB;AAAA;AAAA,OAEjB,kBAAiB,GAAkB;AAAA,IAEvC,MAAM,KAAK,QAAQ;AAAA,IACnB,KAAK,gBAAgB;AAAA;AAAA,OAIjB,MAAK,CAAC,aAAkC;AAAA,IAC5C,OAAO,KAAK,YAAY,IAAI,WAAU,EAAG,MAAM;AAAA;AAAA,OAE3C,KAAI,CAAC,aAAkC;AAAA,IAC3C,OAAO,KAAK,YAAY,IAAI,WAAU,EAAG,KAAK;AAAA;AAAA,OAE1C,OAAM,CAAC,aAAoB,MAA2B;AAAA,IAC1D,OAAO,KAAK,YAAY,IAAI,WAAU,EAAG,OAAO,IAAG;AAAA;AAAA,OAE/C,SAAQ,CAAC,aAAoB,MAA2B;AAAA,IAC5D,OAAO,KAAK,YAAY,IAAI,WAAU,EAAG,SAAS,IAAG;AAAA;AAAA,OAEjD,OAAM,CAAC,aAAkC;AAAA,IAC7C,OAAO,KAAK,YAAY,IAAI,WAAU,EAAG,OAAO;AAAA;AAAA,OAE5C,OAAM,CAAC,aAAkC;AAAA,IAC7C,OAAO,KAAK,YAAY,IAAI,WAAU,EAAG,OAAO;AAAA;AAAA,OAE5C,SAAQ,CAAC,aAAoB,KAAS;AAAA,IAC1C,OAAO,KAAK,YAAY,IAAI,WAAU,EAAG,SAAS,GAAE;AAAA;AAAA,OAEhD,OAAM,CAAC,aAAoB,MAAa,KAAS;AAAA,IACrD,OAAO,KAAK,YAAY,IAAI,WAAU,EAAG,OAAO,MAAK,GAAE;AAAA;AAAA,OAEnD,YAAW,CAAC,aAAoB,MAAa,KAAS;AAAA,IAC1D,OAAO,KAAK,YAAY,IAAI,WAAU,EAAG,YAAY,MAAK,GAAE;AAAA;AAAA,OAExD,WAAU,CAAC,aAAoB,MAAa,KAAS;AAAA,IACzD,OAAO,KAAK,YAAY,IAAI,WAAU,EAAG,WAAW,MAAK,GAAE;AAAA;AAE/D;",
  "debugId": "EB3B7A12DD67919364756E2164756E21",
  "names": []
}