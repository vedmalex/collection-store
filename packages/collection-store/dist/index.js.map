{
  "version": 3,
  "sources": ["../src/AdapterFile.ts", "../src/timeparse.ts", "../src/collection.ts", "../src/utils/autoIncIdGen.ts", "../src/utils/autoTimestamp.ts", "../src/types/Item.ts", "../src/query/$and.ts", "../src/utils/get_value_of.ts", "../src/query/$eq.ts", "../src/query/$every.ts", "../src/query/$exists.ts", "../src/query/$gt.ts", "../src/query/$gte.ts", "../src/query/$in.ts", "../src/query/$lt.ts", "../src/query/$lte.ts", "../src/query/$match.ts", "../src/query/$ne.ts", "../src/query/$nin.ts", "../src/query/$or.ts", "../src/query/$size.ts", "../src/query/$some.ts", "../src/query/build_query.ts", "../src/query/query.ts", "../src/iterators/last.ts", "../src/iterators/first.ts", "../src/iterators/all.ts", "../src/collection/prepare_index_insert.ts", "../src/collection/update_index.ts", "../src/collection/ensure_ttl.ts", "../src/collection/remove_index.ts", "../src/collection/create_index.ts", "../src/collection/ensure_indexed_value.ts", "../src/collection/get_value.ts", "../src/collection/validate_indexed_value_for_insert.ts", "../src/collection/validate_indexed_value_for_update.ts", "../src/collection/ensure_indexes.ts", "../src/utils/CompositeKeyUtils.ts", "../src/utils/SingleKeyUtils.ts", "../src/collection/build_indexes.ts", "../src/collection/is_valid_ttl.ts", "../src/collection/return_list_if_valid.ts", "../src/collection/get_indexed_value.ts", "../src/collection/return_one_if_valid.ts", "../src/collection/restore_index.ts", "../src/collection/restore_index_def.ts", "../src/utils/btree-serialization.ts", "../src/collection/deserialize_indexes.ts", "../src/collection/serialize_indexes.ts", "../src/collection/store_index.ts", "../src/collection/store_index_def.ts", "../src/collection/copy_collection.ts", "../src/collection/do_rotate_log.ts", "../src/collection/get_first_indexed_value.ts", "../src/collection/get_last_indexed_value.ts", "../src/collection/rebuild_indexes.ts", "../src/storage/List.ts", "../src/utils/entity_create.ts", "../src/utils/version_create.ts", "../src/utils/entity_update.ts", "../src/utils/entity_delete.ts", "../src/utils/is_stored_record.ts", "../src/AdapterMemory.ts", "../src/collection/serialize_collection_config.ts", "../src/storage/FileStorage.ts", "../src/CSDatabase.ts", "../src/collection/deserialize_collection_config.ts"],
  "sourcesContent": [
    "import pathLib from 'path'\nimport fs from 'fs-extra'\nimport { Item } from './types/Item'\nimport { IStorageAdapter } from './IStorageAdapter'\nimport Collection from './collection'\n\nexport default class AdapterFile<T extends Item> implements IStorageAdapter<T> {\n  get name() {\n    return 'AdapterFile' as const\n  }\n  get file(): string {\n    if (this.collection.list.singlefile) {\n      return pathLib.join(this.collection.root, `${this.collection.name}.json`)\n    }\n    return pathLib.join(this.collection.root, this.collection.name, 'metadata.json')\n  }\n  collection!: Collection<T>\n  clone() {\n    return new AdapterFile<T>()\n  }\n\n  init(collection: Collection<T>) {\n    this.collection = collection\n    return this\n  }\n\n  async restore(name?: string) {\n    let path = this.file\n    if (name) {\n      const p = { ...pathLib.parse(this.file) } as Partial<pathLib.ParsedPath>\n      p.name = name\n      delete p.base\n      path = pathLib.format(p)\n    }\n    if (fs.pathExistsSync(path)) {\n      return fs.readJSON(path)\n    }\n    return false\n  }\n\n  async store(name: string) {\n    let path = this.file\n    if (name) {\n      const p = { ...pathLib.parse(this.file) } as Partial<pathLib.ParsedPath>\n      p.name = name\n      delete p.base\n      path = pathLib.format(p)\n    }\n    await fs.ensureFile(path)\n\n    await fs.writeJSON(path, this.collection.store(), {\n      spaces: 2,\n    })\n  }\n}\n",
    "const units = {\n  Î¼s: 1,\n  ms: 1000,\n  s: 1000 * 1000,\n  m: 1000 * 1000 * 60,\n  h: 1000 * 1000 * 60 * 60,\n  d: 1000 * 1000 * 60 * 60 * 24,\n  w: 1000 * 1000 * 60 * 60 * 24 * 7,\n} as const\n\nexport default function parse(str: string, returnUnit: keyof typeof units = 'ms') {\n  let totalMicroseconds = 0\n\n  const groups = str.toLowerCase().match(/[-+]?[0-9\\.]+[a-z]+/g)\n\n  if (groups !== null) {\n    for (const g of groups) {\n      const value = parseFloat(g.match(/[0-9\\.]+/g)![0])\n      const unit = g.match(/[a-z]+/g)![0] as keyof typeof units\n\n      totalMicroseconds += getMicroseconds(value, unit)\n    }\n  }\n\n  return totalMicroseconds / units[returnUnit]\n}\n\nfunction getMicroseconds(value: number, unit: keyof typeof units) {\n  const result = units[unit]\n\n  if (result) {\n    return value * result\n  }\n\n  throw new Error(`The unit \"${unit}\" could not be recognized`)\n}\n",
    "// import fs from 'fs-extra';\nimport tp from './timeparse'\nimport * as _ from 'lodash-es'\nimport { autoIncIdGen } from './utils/autoIncIdGen'\nimport { autoTimestamp } from './utils/autoTimestamp'\nimport { IStorageAdapter } from './IStorageAdapter'\nimport { IList } from './IList'\nimport { IndexDef, SerializedIndexDef } from './types/IndexDef'\nimport { IndexStored } from './types/IndexStored'\nimport { Paths } from './types/Paths'\nimport { Item, ItemSchema } from './types/Item'\nimport { IdGeneratorFunction } from './types/IdGeneratorFunction'\nimport { IdType } from './types/IdType'\nimport {\n  ICollectionConfig,\n  ISerializedCollectionConfig,\n} from './ICollectionConfig'\nimport { CronJob } from 'cron'\nimport { Dictionary } from './types/Dictionary'\nimport { BPlusTree, ValueType } from 'b-pl-tree'\nimport { last } from './iterators/last'\nimport { first } from './iterators/first'\nimport { all } from './iterators/all'\nimport { TraverseCondition } from './types/TraverseCondition'\nimport { prepare_index_insert } from './collection/prepare_index_insert'\nimport { update_index } from './collection/update_index'\nimport { ensure_ttl } from './collection/ensure_ttl'\nimport { remove_index } from './collection/remove_index'\nimport { build_indexes } from './collection/build_indexes'\nimport { ensure_indexes } from './collection/ensure_indexes'\nimport { get_indexed_value } from './collection/get_indexed_value'\nimport { return_list_if_valid } from './collection/return_list_if_valid'\nimport { return_one_if_valid } from './collection/return_one_if_valid'\nimport { restore_index } from './collection/restore_index'\nimport { deserialize_indexes } from './collection/deserialize_indexes'\nimport { serialize_indexes } from './collection/serialize_indexes'\nimport { store_index } from './collection/store_index'\nimport { do_rotate_log } from './collection/do_rotate_log'\nimport { StoredIList } from './types/StoredIList'\nimport { get_first_indexed_value } from './collection/get_first_indexed_value'\nimport { get_last_indexed_value } from './collection/get_last_indexed_value'\nimport { rebuild_indexes } from './collection/rebuild_indexes'\nimport { List } from './storage/List'\nimport AdapterMemory from './AdapterMemory'\nimport { IDataCollection } from './IDataCollection'\nimport { ProcessInsert } from './ProcessInsert'\nimport { ProcessUpdates } from './ProcessUpdates'\nimport { ProcessRemoves } from './ProcessRemoves'\nimport { ProcessEnsure } from './ProcessEnsure'\nimport { ProcessRebuild } from './ProcessRebuild'\nimport { create_index } from './collection/create_index'\nimport { ZodError, ZodSchema, ZodType } from 'zod'\nimport { serialize_collection_config } from './collection/serialize_collection_config'\nimport { CompositeKeyUtils } from './utils/CompositeKeyUtils'\n\nexport const ttl_key = '__ttltime'\n\nexport default class Collection<T extends Item> implements IDataCollection<T> {\n  get config(): ISerializedCollectionConfig {\n    return serialize_collection_config(this)\n  }\n\n  /** unique generators */\n  static genCache: Dictionary<IdGeneratorFunction<any>> = {\n    autoIncIdGen: autoIncIdGen as IdGeneratorFunction<any>,\n    autoTimestamp: autoTimestamp as IdGeneratorFunction<any>,\n  }\n\n  root!: string\n  cronJob?: CronJob\n  async createIndex(name: string, config: IndexDef<T>): Promise<void> {\n    create_index(this, name, config)\n    await ensure_indexes(this)\n    //ensure\n    //rebuild\n  }\n\n  listIndexes(name: string) {\n    if (!name) {\n      return Object.keys(this.indexes).map((name) => ({\n        name,\n        key: { name: this.indexes[name] },\n      }))\n    } else {\n      if (this.indexes[name]) {\n        return [{ name, keys: { name: this.indexes[name] } }]\n      } else {\n        return [] as any\n      }\n    }\n  }\n\n  dropIndex(name: string) {\n    delete this.indexes[name]\n  }\n\n  storage!: IStorageAdapter<T>\n  /** ttl for collection in ms */\n  ttl?: number\n  /** cron tab time */\n  rotate?: string\n  /** model name */\n  name!: string\n  /** field that is used for identity */\n  id!: string\n  /** is autioincrement */\n  auto?: boolean\n  /** audit */\n  audit!: boolean\n  /** zod validator */\n  validation: ZodType<T> = ItemSchema as ZodSchema<T>\n  validator(item: T):\n    | { success: true; data: T }\n    | {\n      success: false\n      errors: ZodError<T>\n    } {\n    if (this.validation) {\n      return this.validation.safeParse(item) as any\n    } else {\n      return { success: true, data: item as T }\n    }\n  }\n  /**indexes */\n  indexes!: { [index: string]: BPlusTree<any, any> }\n  /** main storage */\n  list!: IList<T>\n  /** actions in insert */\n  inserts!: Array<ProcessInsert<T>>\n  /** actions in update */\n  updates!: Array<ProcessUpdates<T>>\n  /** actions in remove */\n  removes!: Array<ProcessRemoves<T>>\n  /** actions in ensure */\n  ensures!: Array<ProcessEnsure>\n  rebuilds!: Array<ProcessRebuild>\n  /** index definition */\n  indexDefs!: Dictionary<IndexDef<T>>\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  private constructor() { }\n\n  static create<T extends Item>(config?: ICollectionConfig<T>) {\n    const collection: Collection<T> = new Collection<T>()\n    const {\n      ttl,\n      rotate,\n      name,\n      id = {\n        name: 'id',\n        auto: true,\n        gen: 'autoIncIdGen',\n      },\n      auto = true,\n      indexList,\n      list = new List<T>() as IList<T>,\n      adapter = new AdapterMemory<T>(),\n      validation,\n      audit,\n      root,\n    } = config ?? {}\n\n    collection.audit = !!audit\n    if (validation) {\n      collection.validation = validation\n    }\n    collection.root = root ?? './data/'\n\n    let { idGen = 'autoIncIdGen' } = config ?? {}\n\n    if (typeof idGen == 'function') {\n      idGen = idGen.toString()\n    }\n\n    if (rotate) {\n      collection.cronJob = new CronJob(rotate, () => {\n        do_rotate_log(collection)\n      })\n      collection.cronJob.start()\n    }\n\n    let Id: Partial<IdType<T>> = typeof id == 'string' ? { name: id } : id\n\n    if ('string' == typeof id) {\n      Id = {\n        name: id,\n        auto: auto != null ? auto : true,\n        gen: idGen,\n      }\n    }\n\n    if (!Id.name) {\n      Id.name = 'id'\n    }\n\n    if (Id.gen == null) {\n      Id.gen = idGen\n    }\n\n    if (!name) {\n      throw new Error('must Have Model Name as \"name\" prop in config')\n    }\n\n    collection.ttl = (typeof ttl == 'string' ? tp(ttl) : ttl) || undefined\n\n    collection.rotate = rotate\n    collection.name = name\n    collection.storage = adapter.init(collection)\n    collection.id = Id.name\n    collection.auto = Id.auto\n    collection.indexes = {}\n    collection.list = list\n    collection.indexDefs = {}\n    collection.inserts = []\n    collection.removes = []\n    collection.updates = []\n    collection.ensures = []\n    collection.rebuilds = []\n\n    const defIndex: Array<IndexDef<T>> = [\n      {\n        key: collection.id,\n        // type: 'number',\n        auto: collection.auto,\n        gen:\n          typeof Id.gen == 'function'\n            ? Id.gen\n            : Id.gen && Collection.genCache[Id.gen]\n              ? Collection.genCache[Id.gen]\n              : Id.gen ? eval(Id.gen) : undefined,\n        unique: true,\n        sparse: false,\n        required: true,\n      },\n    ]\n\n    if (collection.ttl) {\n      defIndex.push({\n        key: ttl_key,\n        auto: true,\n        gen: Collection.genCache['autoTimestamp'],\n        unique: false,\n        sparse: false,\n        required: true,\n      })\n    }\n\n    if (collection.rotate) {\n      defIndex.push({\n        key: ttl_key,\n        auto: true,\n        gen: Collection.genCache['autoTimestamp'],\n        unique: false,\n        sparse: false,\n        required: true,\n      })\n    }\n\n    build_indexes(\n      collection,\n      defIndex.concat(indexList || []).reduce((prev, curr) => {\n        if (curr.key == '*') {\n          prev[curr.key as string] = {\n            key: '*',\n            auto: false,\n            unique: false,\n            gen: undefined,\n            sparse: false,\n            required: false,\n            ignoreCase: true,\n          }\n        } else {\n          // Determine if this is a composite index\n          const isCompositeIndex = !!(curr.keys || curr.composite)\n          let indexKey: string\n\n          if (isCompositeIndex) {\n            // Generate key from composite key paths\n            const keyPaths = curr.keys || curr.composite?.keys\n            if (keyPaths && CompositeKeyUtils.validateKeyPaths(keyPaths)) {\n              indexKey = CompositeKeyUtils.generateIndexName(keyPaths)\n            } else {\n              throw new Error(`Invalid composite key paths for index`)\n            }\n          } else {\n            // Use single key\n            indexKey = curr.key as string\n          }\n\n          prev[indexKey] = {\n            key: isCompositeIndex ? undefined : curr.key,\n            keys: isCompositeIndex ? (curr.keys || curr.composite?.keys) as any : undefined,\n            composite: isCompositeIndex ? (curr.composite || { keys: curr.keys }) : undefined,\n            order: !isCompositeIndex ? curr.order : undefined, // Sort order for single keys only\n            auto: curr.auto || false,\n            unique: curr.unique || false,\n            gen:\n              curr.gen ||\n              (curr.auto ? Collection.genCache['autoIncIdGen'] : undefined),\n            sparse: curr.sparse || false,\n            required: curr.required || false,\n            ignoreCase: curr.ignoreCase,\n            process: curr.process,\n          }\n        }\n        return prev\n      }, {} as Dictionary<IndexDef<T>>),\n    )\n    collection.list.init(collection)\n    // Ð¿ÑÐ¸Ð´ÑÐ¼Ð°ÑÑ Ð·Ð°Ð³ÑÑÐ·ÐºÑ\n    ensure_indexes(collection) ///??\n\n    return collection\n  }\n\n  static async fromList<T extends Item>(\n    array: Array<T>,\n    id: string,\n    root: string,\n  ) {\n    const list = Collection.create({\n      root,\n      name: 'default',\n      indexList: [{ key: '*' }, { key: id, unique: true, required: true }],\n      id: { name: '$order', auto: true },\n      list: new List<T>(),\n      adapter: new AdapterMemory<T>(),\n    })\n    await Promise.all(array.map((item) => list.create(item)))\n    return list\n  }\n\n  async reset(): Promise<void> {\n    await this.list.reset()\n    this.indexes = {}\n    ensure_indexes(this)\n  }\n\n  async load(name?: string): Promise<void> {\n    try {\n      const stored = await this.storage.restore(name)\n      if (stored) {\n        const { indexes, list, indexDefs, id, ttl } = stored\n        this.list.load(list)\n        this.indexDefs = restore_index(this, indexDefs)\n        this.id = id\n        this.ttl = ttl\n\n        this.inserts = []\n        this.removes = []\n        this.updates = []\n        this.ensures = []\n\n        this.indexes = {}\n        build_indexes(this, this.indexDefs)\n\n        this.indexes = deserialize_indexes(indexes)\n        await rebuild_indexes(this)\n      }\n    } catch (e) {\n      // throw e\n    }\n    await ensure_ttl(this)\n  }\n\n  store(): {\n    list: StoredIList\n    indexes: { [key: string]: unknown }\n    indexDefs: Dictionary<IndexStored<T>>\n    id: string\n    ttl?: number\n    rotate?: number\n  } {\n    return {\n      list: this.list.persist(),\n      indexes: serialize_indexes(this.indexes),\n      indexDefs: store_index(this, this.indexDefs),\n      id: this.id,\n      ttl: this.ttl,\n      rotate: this.rotate ? parseInt(this.rotate) : undefined,\n    }\n  }\n\n  async persist(name?: string): Promise<void> {\n    await this.storage.store(name)\n  }\n\n  //\n  async push(item: T): Promise<T | undefined> {\n    // apply default once it is created\n    const insert_indexed_values = prepare_index_insert(this, item)\n    const id = item[this.id]\n    const res = await this.list.set(id, item)\n    insert_indexed_values(id)\n    return return_one_if_valid(this, res)\n  }\n\n  async create(item: T): Promise<T | undefined> {\n    const res = { ...item } as T\n    const value = await this.push(res)\n    return value\n  }\n\n  async save(res: T): Promise<T | undefined> {\n    const id = res[this.id]\n    const item = await this.findById(id)\n    await update_index(this, item as T, res as T, id)\n    await this.list.update(id, res)\n    return return_one_if_valid(this, res)\n  }\n\n  async first(): Promise<T> {\n    return (await first(this, () => true).next()).value\n  }\n\n  async last(): Promise<T> {\n    return (await last(this, () => true).next()).value\n  }\n\n  lowest(key: Paths<T>): Promise<T | undefined> {\n    return this.findFirstBy(key, this.indexes[key].min)\n  }\n\n  greatest(key: Paths<T>): Promise<T | undefined> {\n    return this.findLastBy(key, this.indexes[key].max)\n  }\n\n  oldest(): Promise<T | undefined> {\n    if (this.ttl) {\n      return this.lowest(ttl_key as any)\n    } else return this.first()\n  }\n\n  latest(): Promise<T | undefined> {\n    if (this.ttl) {\n      return this.greatest(ttl_key as any)\n    } else return this.last()\n  }\n\n  async findById(id: ValueType): Promise<T | undefined> {\n    const indexDef = this.indexDefs[this.id]\n    if (indexDef?.process) {\n      id = indexDef.process(id)\n    }\n    const index = this.indexes[this.id]\n    if (!index) {\n      throw new Error(`Index for ${this.id} not found`)\n    }\n    const result = await this.list.get(index.findFirst(id))\n    return return_one_if_valid(this, result)\n  }\n\n  async findBy(key: Paths<T>, id: ValueType): Promise<Array<T>> {\n    if (this.indexDefs.hasOwnProperty(key)) {\n      const indexDef = this.indexDefs[key as string]\n\n      // For composite indexes, don't apply process function when searching\n      // because we expect the caller to pass an already serialized composite key\n      const isCompositeIndex = !!(indexDef.keys || indexDef.composite)\n              if (indexDef?.process && !isCompositeIndex) {\n        id = indexDef.process(id)\n      }\n\n      const result = []\n      if (this.indexDefs.hasOwnProperty(key)) {\n        result.push(...(await get_indexed_value(this, key, id)))\n      }\n      return return_list_if_valid(this, result)\n    } else {\n      throw new Error(`Index for ${key} not found`)\n    }\n  }\n\n  async findFirstBy(key: Paths<T>, id: ValueType): Promise<T | undefined> {\n    if (this.indexDefs.hasOwnProperty(key)) {\n      const indexDef = this.indexDefs[key as string]\n\n      // For composite indexes, don't apply process function when searching\n      const isCompositeIndex = !!(indexDef.keys || indexDef.composite)\n      if (indexDef?.process && !isCompositeIndex) {\n        id = indexDef.process(id)\n      }\n\n      if (this.indexDefs.hasOwnProperty(key)) {\n        const result = await get_first_indexed_value(this, key, id)\n        return return_one_if_valid(this, result)\n      }\n    }\n    throw new Error(`Index for ${key} not found`)\n  }\n\n  async findLastBy(key: Paths<T>, id: ValueType): Promise<T | undefined> {\n    if (this.indexDefs.hasOwnProperty(key)) {\n      const indexDef = this.indexDefs[key as string]\n\n      // For composite indexes, don't apply process function when searching\n      const isCompositeIndex = !!(indexDef.keys || indexDef.composite)\n      if (indexDef?.process && !isCompositeIndex) {\n        id = indexDef.process(id)\n      }\n\n      if (this.indexDefs.hasOwnProperty(key)) {\n        const result = await get_last_indexed_value(this, key, id)\n        return return_one_if_valid(this, result)\n      }\n    }\n    throw new Error(`Index for ${key} not found`)\n  }\n\n  async find(condition: TraverseCondition<T>): Promise<Array<T>> {\n    const result: Array<T> = []\n    for await (const item of all(this, condition)) {\n      result.push(item)\n    }\n    return return_list_if_valid(this, result)\n  }\n\n  async findFirst(condition: TraverseCondition<T>): Promise<T | undefined> {\n    const result: T = await (await first(this, condition).next()).value\n    return return_one_if_valid(this, result)\n  }\n\n  async findLast(condition: TraverseCondition<T>): Promise<T | undefined> {\n    const result: T = await (await last(this, condition).next()).value\n    return return_one_if_valid(this, result)\n  }\n\n  async update(\n    condition: TraverseCondition<T>,\n    update: Partial<T>,\n    merge: boolean = true,\n  ): Promise<Array<T>> {\n    const result: Array<T> = []\n    for await (const item of all(this, condition)) {\n      const res = merge ? _.merge({}, item, update) : _.assign({}, item, update)\n      await update_index(this, item, res as T, item[this.id])\n      await this.list.update(item[this.id], res)\n      result.push(res)\n    }\n    return return_list_if_valid<T>(this, result)\n  }\n\n  async updateFirst(\n    condition: TraverseCondition<T>,\n    update: Partial<T>,\n    merge: boolean = true,\n  ): Promise<T | undefined> {\n    const item: T = await (await first(this, condition).next()).value\n    const res = merge ? _.merge({}, item, update) : _.assign({}, item, update)\n    await update_index(this, item, res as T, item[this.id])\n    await this.list.update(item[this.id], res)\n    return return_one_if_valid(this, res as T)\n  }\n\n  async updateLast(\n    condition: TraverseCondition<T>,\n    update: Partial<T>,\n    merge: boolean = true,\n  ): Promise<T | undefined> {\n    const item: T = await (await last(this, condition).next()).value\n    const res = merge ? _.merge({}, item, update) : _.assign({}, item, update)\n    await update_index(this, item, res as T, item[this.id])\n    await this.list.update(item[this.id], res)\n\n    return return_one_if_valid(this, res as T)\n  }\n\n  async updateWithId(\n    id: ValueType,\n    update: Partial<T>,\n    merge: boolean = true,\n  ): Promise<T | undefined> {\n    const item = await this.findById(id)\n    const res = merge ? _.merge({}, item, update) : _.assign({}, item, update)\n    await update_index(this, item as T, res as T, id)\n    await this.list.update(id, res)\n    return return_one_if_valid(this, res as T)\n  }\n\n  async removeWithId(id: ValueType): Promise<T | undefined> {\n    const indexDef = this.indexDefs[this.id]\n    if (indexDef?.process) {\n      id = indexDef.process(id)\n    }\n    const index = this.indexes[this.id]\n    if (!index) {\n      throw new Error(`Index for ${this.id} not found`)\n    }\n    const i = index.findFirst(id)\n    const cur = await this.list.get(i)\n    if (i !== undefined && cur) {\n      remove_index(this, cur)\n      const result = await this.list.delete(id) // Use the actual ID, not the index position\n      return return_one_if_valid(this, result)\n    }\n  }\n\n  async remove(condition: TraverseCondition<T>): Promise<Array<T | undefined>> {\n    const result: Array<T> = []\n    for await (const cur of all(this, condition)) {\n      remove_index(this, cur)\n      const res = await this.list.delete(cur[this.id])\n      result.push(res)\n    }\n    return return_list_if_valid<T>(this, result)\n  }\n\n  async removeFirst(condition: TraverseCondition<T>): Promise<T | undefined> {\n    const item: T = await (await first(this, condition).next()).value\n    remove_index(this, item)\n    await this.list.delete(item[this.id])\n    return return_one_if_valid(this, item)\n  }\n  async removeLast(condition: TraverseCondition<T>): Promise<T | undefined> {\n    const item: T = await (await last(this, condition).next()).value\n    remove_index(this, item)\n    await this.list.delete(item[this.id])\n    return return_one_if_valid(this, item)\n  }\n}\n\nexport function serializeIndex<T extends Item>(\n  res: IndexDef<T>,\n): SerializedIndexDef {\n  return {\n    key: res.key as string,\n    keys: res.keys as any,\n    composite: res.composite as any,\n    order: res.order,\n    auto: res.auto ? true : undefined,\n    unique: res.unique ? true : undefined,\n    sparse: res.sparse ? true : undefined,\n    ignoreCase: res.ignoreCase ? true : undefined,\n    required: res.required ? true : undefined,\n    gen: res.gen?.name ?? undefined,\n    process: res.process?.toString() ?? undefined,\n  }\n}\n\nexport function deserializeIndex<T extends Item>(\n  res: SerializedIndexDef,\n): IndexDef<T> {\n  return {\n    key: res.key,\n    keys: res.keys as any,\n    composite: res.composite as any,\n    order: res.order,\n    auto: res.auto ? true : undefined,\n    unique: res.unique ? true : undefined,\n    sparse: res.sparse ? true : undefined,\n    ignoreCase: res.ignoreCase ? true : undefined,\n    required: res.required ? true : undefined,\n    gen: res.gen ? Collection.genCache[res.gen] : undefined,\n    process: res.process ? eval(res.process) : undefined,\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport { IList } from '../IList'\n\nexport function autoIncIdGen<T extends Item>(\n  item: T,\n  model: string,\n  list: IList<T>,\n) {\n  return list.counter\n}\n",
    "import { Item } from '../types/Item'\nimport { IList } from '../IList'\n\nexport function autoTimestamp<T extends Item>(\n  item: T,\n  model: string,\n  list: IList<T>,\n) {\n  return Date.now()\n}\n",
    "import { z } from 'zod'\n\nexport interface Item {\n  __ttltime?: number\n  id?: number | string\n  [key: string]: any\n}\n\nexport const ItemSchema = z\n  .object({\n    __ttltime: z.number().optional(),\n    id: z.union([z.number(), z.string()]).optional(),\n  })\n  .passthrough()\n",
    "import { UnaryCondition } from './UnaryCondition'\n\nexport function $and(value: Array<{ [key: string]: UnaryCondition }>) {\n  return (val: { [key: string]: unknown }) => {\n    for (const condition of value) {\n      for (const prop of Object.keys(condition))\n        if (!condition[prop](val[prop])) {\n          return false\n        }\n    }\n    return true\n  }\n}\n",
    "import { ValueType } from 'b-pl-tree'\n\nexport function get_value_of(v: ValueType) {\n  if (typeof v === 'object' && v !== null && 'valueOf' in v && typeof v.valueOf === 'function') {\n    return v.valueOf()\n  } else {\n    return v\n  }\n}",
    "import { ValueType } from 'b-pl-tree'\nimport { UnaryCondition } from './UnaryCondition'\nimport { get_value_of } from '../utils/get_value_of'\n\nexport function $eq(value: ValueType): UnaryCondition {\n  const val = get_value_of(value)\n  if (val === undefined) return (v: ValueType) => false\n  return (v: ValueType) => val === get_value_of(v)\n}\n",
    "import { ValueType } from 'b-pl-tree'\nimport { UnaryCondition } from './UnaryCondition'\nimport { get_value_of } from '../utils/get_value_of'\n\nexport function $every(value: (v: any) => true): UnaryCondition {\n  if (value === undefined) return (_: ValueType) => false\n  return (v: Array<ValueType>) => v.map(get_value_of).every(value)\n}\n",
    "import { UnaryCondition } from './UnaryCondition'\n\nexport function $exists(value: boolean): UnaryCondition {\n  return (val) => {\n    const res = val !== undefined && val !== null && val !== ''\n    return value ? res : !res\n  }\n}\n",
    "import { ValueType } from 'b-pl-tree'\nimport { UnaryCondition } from './UnaryCondition'\nimport { get_value_of } from '../utils/get_value_of'\n\nexport function $gt(value: ValueType): UnaryCondition {\n  const val = get_value_of(value)\n  if (val === undefined) return (_: ValueType) => false\n  return (v: ValueType) => get_value_of(v) > val\n}\n",
    "import { ValueType } from 'b-pl-tree'\nimport { UnaryCondition } from './UnaryCondition'\nimport { get_value_of } from '../utils/get_value_of'\n\nexport function $gte(value: ValueType): UnaryCondition {\n  const val = get_value_of(value)\n  if (val === undefined) return (_: ValueType) => false\n  return (v: ValueType) => get_value_of(v) >= (value ?? 0)\n}\n",
    "import { ValueType } from 'b-pl-tree'\nimport { UnaryCondition } from './UnaryCondition'\nimport { get_value_of } from '../utils/get_value_of'\n\nexport function $in(value: Array<ValueType>): UnaryCondition {\n  if (value === undefined) return (_: ValueType) => false\n  const val = value.map(get_value_of)\n  return (v: ValueType) => val.includes((get_value_of(v)))\n}\n",
    "import { ValueType } from 'b-pl-tree'\nimport { UnaryCondition } from './UnaryCondition'\nimport { get_value_of } from '../utils/get_value_of'\n\nexport function $lt(value: ValueType): UnaryCondition {\n  const val = get_value_of(value)\n  if (val === undefined) return (_: ValueType) => false\n  return (v: ValueType) => get_value_of(v) < (value ?? 0)\n}\n",
    "import { ValueType } from 'b-pl-tree'\nimport { UnaryCondition } from './UnaryCondition'\nimport { get_value_of } from '../utils/get_value_of'\n\nexport function $lte(value: ValueType): UnaryCondition {\n  const val = get_value_of(value)\n  if (val === undefined) return (_: ValueType) => false\n  return (v: ValueType) => get_value_of(v) <= (value ?? 0)\n}\n",
    "import { UnaryCondition } from './UnaryCondition'\n\nexport function $match(value: RegExp | string, flags?: string): UnaryCondition {\n  if (typeof value === 'object') {\n    return (val: string) => value.test(val)\n  }\n  const reg = new RegExp(value, flags)\n  return (val: string) => reg.test(val)\n}\n",
    "import { ValueType } from 'b-pl-tree'\nimport { UnaryCondition } from './UnaryCondition'\nimport { get_value_of } from '../utils/get_value_of'\n\nexport function $ne(value: ValueType): UnaryCondition {\n  const val = get_value_of(value)\n  if (val === undefined) return (_: ValueType) => false\n  return (v: ValueType) => get_value_of(v) !== val\n}\n",
    "import { ValueType } from 'b-pl-tree'\nimport { UnaryCondition } from './UnaryCondition'\nimport { get_value_of } from '../utils/get_value_of'\n\nexport function $nin(value: Array<ValueType>): UnaryCondition {\n  if (value === undefined) return (_: ValueType) => false\n  const val = value.map(get_value_of)\n  return (v: ValueType) => !val.includes(get_value_of(v))\n}\n",
    "import { UnaryCondition } from './UnaryCondition'\n\nexport function $or(value: Array<{ [key: string]: UnaryCondition }>) {\n  return (val: { [key: string]: unknown }) => {\n    for (const condition of value) {\n      for (const prop of Object.keys(condition)) {\n        if (condition[prop](val[prop])) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n}\n",
    "import { UnaryCondition } from './UnaryCondition'\n\nexport function $size(value: number): UnaryCondition {\n  return (val: string | Array<any>) => val.length === value\n}\n",
    "import { ValueType } from 'b-pl-tree'\nimport { UnaryCondition } from './UnaryCondition'\nimport { get_value_of } from '../utils/get_value_of'\n\nexport function $some(value: (v: any) => true): UnaryCondition {\n  if (value === undefined) return (_: ValueType) => false\n  return (v: Array<ValueType>) => v.map(get_value_of).some(value)\n}\n",
    "import { $and } from './$and'\nimport { $eq } from './$eq'\nimport { $every } from './$every'\nimport { $exists } from './$exists'\nimport { $gt } from './$gt'\nimport { $gte } from './$gte'\nimport { $in } from './$in'\nimport { $lt } from './$lt'\nimport { $lte } from './$lte'\nimport { $match } from './$match'\nimport { $ne } from './$ne'\nimport { $nin } from './$nin'\nimport { $or } from './$or'\nimport { $size } from './$size'\nimport { $some } from './$some'\nimport { UnaryCondition, UnaryConditionOperation } from './UnaryCondition'\n\nexport function build_query(\n  _obj: unknown,\n  options?: { [op: string]: (...args: Array<any>) => UnaryCondition },\n): UnaryCondition | UnaryConditionOperation {\n  const res: Array<UnaryCondition | UnaryConditionOperation> = []\n  if (typeof _obj === 'object' && !(_obj instanceof Date) && _obj) {\n    const obj = _obj as Record<string, any>\n    const keys = Object.keys(obj)\n    for (const prop of keys) {\n      if (options?.[prop]) {\n        res.push(options[prop](obj[prop]))\n      } else {\n        switch (prop) {\n          case '$eq':\n            res.push($eq(obj.$eq))\n            break\n          case '$gt':\n            res.push($gt(obj.$gt))\n            break\n          case '$gte':\n            res.push($gte(obj.$gte))\n            break\n          case '$lt':\n            res.push($lt(obj.$lt))\n            break\n          case '$lte':\n            res.push($lte(obj.$lte))\n            break\n          case '$ne':\n            res.push($ne(obj.$ne))\n            break\n          case '$in':\n            res.push($in(obj.$in))\n            break\n          case '$nin':\n            res.push($nin(obj.$nin))\n            break\n          case '$some':\n            res.push($some(obj.$some))\n            break\n          case '$every':\n            res.push($every(obj.$every))\n            break\n          case '$exists':\n            res.push($exists(obj.$exists))\n            break\n          case '$match':\n            res.push($match(obj.$match, 'g'))\n            break\n          case '$imatch':\n            res.push($match(obj.$imatch, 'ig'))\n            break\n          case '$size':\n            res.push($size(obj.$size))\n            break\n          case '$and':\n            res.push($and(obj.$and))\n            break\n          case '$or':\n            res.push($or(obj.$or))\n            break\n          default:\n            res.push({ [prop]: build_query(obj[prop], options) })\n        }\n      }\n    }\n    if (res.length === 1) {\n      return res[0]\n    }\n    return options?.$and(res) ?? $and(res as any)\n  }\n  if (typeof _obj === 'number' || typeof _obj === 'bigint' || typeof _obj === 'string' || _obj instanceof Date) {\n    return $eq(_obj)\n  }\n  throw new Error('unknown type')\n}\n",
    "import { $and } from './$and'\nimport { UnaryCondition, UnaryConditionOperation } from './UnaryCondition'\nimport { build_query } from './build_query'\n\nexport function query(\n  obj: unknown,\n  options?: { [op: string]: (...args: Array<any>) => UnaryCondition },\n): UnaryCondition {\n  const q = build_query(obj, options)\n  if (typeof q === 'object') {\n    return $and(\n      Object.keys(q).reduce(\n        (res, key) => {\n          res.push({ [key]: q[key] } as UnaryConditionOperation)\n          return res\n        },\n        [] as Array<any>,\n      ),\n    )\n  }\n  if (typeof q === 'function') {\n    return q\n  }\n  throw new Error('nonsense')\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { query } from '../query/query'\nimport { TraverseCondition } from '../types/TraverseCondition'\n\nexport async function* last<T extends Item>(\n  collection: Collection<T>,\n  condition: TraverseCondition<T>,\n): AsyncGenerator<T> {\n  if (typeof condition == 'object') condition = query(condition)\n  for await (const current of collection.list.backward) {\n    if (condition(current)) {\n      yield current\n      return\n    }\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { query } from '../query/query'\nimport { TraverseCondition } from '../types/TraverseCondition'\n\nexport async function* first<T extends Item>(\n  collection: Collection<T>,\n  condition: TraverseCondition<T>,\n): AsyncGenerator<T> {\n  if (typeof condition == 'object') condition = query(condition)\n  for await (const current of collection.list.forward) {\n    if (condition(current)) {\n      yield current\n      return\n    }\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { query } from '../query/query'\nimport { TraverseCondition } from '../types/TraverseCondition'\n\n// Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ð½Ðµ ÑÐ°Ð±Ð¾ÑÐ°ÐµÑ TTL Ð½Ðµ ÑÐ´Ð°Ð»ÑÑÑÑÑ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ Ð¸Ð½Ð´ÐµÐºÑÐ°.\n\nexport async function* all<T extends Item>(\n  collection: Collection<T>,\n  condition: TraverseCondition<T>,\n): AsyncGenerator<T> {\n  if (typeof condition == 'object') condition = query(condition)\n  for await (const current of collection.list.forward) {\n    if (condition(current)) {\n      yield current\n    }\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\n\n/**\n * ensures values for indexing and return final index insert routines\n * @param collection source collection\n * @param val inserting value\n */\nexport function prepare_index_insert<T extends Item>(\n  collection: Collection<T>,\n  val: T,\n) {\n  const result: Array<any> = []\n  // for is used to provide dynamic indexes add on create\n  for (let i = 0; i < collection.inserts?.length; i += 1) {\n    result.push(collection.inserts[i](val))\n  }\n\n  return (i: any) => {\n    result.forEach((f) => f?.(i))\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { ValueType } from 'b-pl-tree'\n\nexport async function update_index<T extends Item>(\n  collection: Collection<T>,\n  ov: T | Partial<T>,\n  nv: T | Partial<T>,\n  i: ValueType,\n) {\n  await Promise.all(collection.updates.map((item) => item(ov, nv, i)))\n}\n",
    "import { Item } from '../types/Item'\nimport { ValueType } from 'b-pl-tree'\nimport Collection, { ttl_key } from '../collection'\n\nexport async function ensure_ttl<T extends Item>(collection: Collection<T>) {\n  if (collection.ttl) {\n    // collection.indexes\n    // ensure that all object are actuated with time\n    const now = Date.now()\n    const cutoffTime = now - collection.ttl\n\n    // Get TTL index\n    const ttlIndex = collection.indexes[ttl_key]\n    if (!ttlIndex) return\n\n    // Find all items with TTL less than cutoff time using the lt() method\n    const expiredItems: ValueType[] = []\n\n    // Use the lt() method to get a generator for items with TTL < cutoffTime\n    const expiredGenerator = ttlIndex.lt(cutoffTime)(ttlIndex)\n\n    let cursor = expiredGenerator.next()\n    while (!cursor.done && cursor.value) {\n      if (cursor.value.value !== undefined) {\n        expiredItems.push(cursor.value.value)\n      }\n      cursor = expiredGenerator.next()\n    }\n\n    // Remove expired items using removeWithId now that the index/list issue is fixed\n    for (const itemId of expiredItems) {\n      await collection.removeWithId(itemId)\n    }\n\n    if (expiredItems.length > 0) {\n      await collection.persist()\n    }\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\n\nexport function remove_index<T extends Item>(\n  collection: Collection<T>,\n  val: any,\n) {\n  collection.removes.forEach((item) => item(val))\n}\n",
    "import { get } from 'lodash-es'\nimport { IndexDef } from '../types/IndexDef'\nimport { Item } from '../types/Item'\nimport { BPlusTree, ValueType } from 'b-pl-tree'\nimport Collection from '../collection'\nimport { ensure_indexed_value } from './ensure_indexed_value'\nimport { get_value } from './get_value'\nimport { validate_indexed_value_for_insert } from './validate_indexed_value_for_insert'\nimport { validate_indexed_value_for_update } from './validate_indexed_value_for_update'\nimport { ensure_indexes } from './ensure_indexes'\nimport { build_indexes } from './build_indexes'\nimport { CompositeKeyUtils } from '../utils/CompositeKeyUtils'\nimport { SingleKeyUtils } from '../utils/SingleKeyUtils'\n\nexport function create_index<T extends Item>(\n  collection: Collection<T>,\n  key: string,\n  indexDef: IndexDef<T>,\n) {\n  const {\n    auto = false,\n    unique = false,\n    sparse = false,\n    required = false,\n    ignoreCase,\n    keys,\n    composite,\n    order,\n  } = indexDef\n\n  let { gen, process } = indexDef\n\n  // Determine if this is a composite index\n  const isCompositeIndex = !!(keys || composite)\n  const keyPaths = keys || composite?.keys\n  const separator = composite?.separator || CompositeKeyUtils.DEFAULT_SEPARATOR\n  let compositeDef = composite\n\n  if (auto && !gen) {\n    gen = Collection.genCache['autoIncIdGen']\n  }\n\n  if (ignoreCase) {\n    process = (value: any) =>\n      value?.toString ? value.toString().toLowerCase() : value\n  }\n\n  // Validate index configuration\n  if (isCompositeIndex) {\n    if (!keyPaths) {\n      throw new Error(`Composite key paths are required for composite index`)\n    }\n\n    // Normalize composite keys to support sort order\n    const normalizedFields = CompositeKeyUtils.normalizeCompositeKeys(keyPaths)\n\n    // Validate normalized fields\n    if (!CompositeKeyUtils.validateCompositeKeyFields(normalizedFields)) {\n      throw new Error(`Invalid composite key fields for index`)\n    }\n\n    // Generate index name from key paths if not provided\n    if (!key) {\n      key = CompositeKeyUtils.generateIndexNameFromFields(normalizedFields)\n    }\n\n    // Override process function for composite keys with sort order support\n    process = (item: T) => {\n      return CompositeKeyUtils.createKeyWithOrder(item, normalizedFields, separator)\n    }\n\n    // Store normalized fields in composite definition\n    compositeDef = { keys: normalizedFields as any, separator }\n  } else {\n    if (!key) {\n      throw new Error(`key is required field for index`)\n    }\n  }\n\n  collection.indexDefs[key] = {\n    key: isCompositeIndex ? undefined : (indexDef.key || key),\n    keys: isCompositeIndex ? (keys || undefined) : undefined, // Use original keys for legacy support\n    composite: isCompositeIndex ? compositeDef : undefined,\n    order: !isCompositeIndex ? order : undefined, // Sort order for single keys only\n    auto,\n    unique,\n    gen,\n    sparse,\n    required,\n    ignoreCase,\n    process,\n  }\n\n  if (collection.indexes.hasOwnProperty(key)) {\n    throw new Error(`index with key ${key} already exists`)\n  }\n\n  const insert: any =\n    key !== '*'\n      ? (item: T) => {\n          const value = ensure_indexed_value(\n            item,\n            key,\n            collection,\n            gen,\n            auto,\n            process,\n          )\n          const [valid, message] = validate_indexed_value_for_insert(\n            collection,\n            value,\n            key,\n            sparse,\n            required,\n            unique,\n          )\n          if (!valid) throw new Error(message)\n          if (!(sparse && value == null)) {\n            return (record_link: ValueType) =>\n              collection.indexes[key].insert(\n                value !== undefined ? value : null,\n                record_link,\n              )\n          }\n        }\n      : (item: T) => {\n          let found = false\n          const newIndexDefs = Object.keys(item).reduce((res, pname) => {\n            if (!collection.indexDefs[pname]) {\n              found = true\n              res[pname] = {\n                ...collection.indexDefs['*'],\n                key: pname,\n              }\n            }\n            return res\n          }, {} as Record<string, IndexDef<T>>)\n\n          if (found) {\n            collection.indexDefs = {\n              ...collection.indexDefs,\n              ...newIndexDefs,\n            }\n            build_indexes(collection, newIndexDefs)\n            ensure_indexes(collection)\n          }\n          return (record_link: ValueType) => undefined\n        }\n\n  const update: any =\n    key !== '*'\n      ? async (ov: T | Partial<T>, nv: T | Partial<T>, index_payload: number) => {\n          const valueOld = ensure_indexed_value<T>(\n            ov,\n            key,\n            collection,\n            gen,\n            auto,\n            process,\n          )\n          const valueNew = get_value(nv, key, process)\n          if (valueNew != null) {\n            const [valid, message] = await validate_indexed_value_for_update(\n              collection,\n              valueNew,\n              key,\n              sparse,\n              required,\n              unique,\n              (ov as any)[collection.id],\n            )\n            if (!valid) throw new Error(message)\n            if (valueOld !== valueNew) {\n              if (unique) {\n                collection.indexes[key].remove(valueOld)\n              } else {\n                collection.indexes[key].removeSpecific(valueOld, (pointer) =>\n                  key != collection.id ? pointer == (ov as any)[collection.id] : true,\n                )\n              }\n              collection.indexes[key].insert(\n                valueNew !== undefined ? valueNew : null,\n                index_payload,\n              )\n            }\n          } else {\n            if (unique) {\n              collection.indexes[key].remove(valueOld)\n            } else {\n              collection.indexes[key].removeSpecific(valueOld, (pointer) =>\n                key != collection.id ? pointer == (ov as any)[collection.id] : true,\n              )\n            }\n          }\n        }\n      : undefined\n\n  const remove: any =\n    key !== '*'\n      ? (item: T) => {\n          let value: any\n          if (isCompositeIndex && process) {\n            // For composite indexes, pass the entire item to process function\n            value = process(item)\n          } else {\n            // For single key indexes, get the field value first\n            value = get(item, key) ?? null\n            // Then apply process to the value if it exists\n            if (process && !isCompositeIndex) {\n              value = process(value)\n            }\n          }\n          collection.indexes[key].removeSpecific(\n            value,\n            (pointer) =>\n              key != collection.id ? pointer == item[collection.id] : true,\n          )\n        }\n      : undefined\n\n  const ensure =\n    key !== '*'\n      ? () => {\n          if (!collection.indexes.hasOwnProperty(key)) {\n            // Create comparator for single keys with sort order support\n            const comparator = !isCompositeIndex && order\n              ? SingleKeyUtils.createComparator(order)\n              : undefined\n            collection.indexes[key] = new BPlusTree<any, number>(undefined, unique, comparator)\n          }\n        }\n      : undefined\n\n  const rebuild =\n    key !== '*'\n      ? async () => {\n          if (!collection.indexes.hasOwnProperty(key)) {\n            // Create comparator for single keys with sort order support\n            const comparator = !isCompositeIndex && order\n              ? SingleKeyUtils.createComparator(order)\n              : undefined\n            collection.indexes[key] = new BPlusTree<any, number>(undefined, unique, comparator)\n            if (collection.list.length > 0) {\n              for await (const item of collection.list.forward) {\n                insert?.(item)?.(item[collection.id])\n              }\n            }\n          }\n        }\n      : null\n\n  if (ensure) collection.ensures.push(ensure)\n  if (rebuild) collection.rebuilds.push(rebuild)\n  if (insert) collection.inserts.push(insert)\n  if (update) collection.updates.push(update)\n  if (remove) collection.removes.push(remove)\n}\n",
    "import { get, set } from 'lodash-es'\nimport { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { IdGeneratorFunction } from '../types/IdGeneratorFunction'\nimport { ValueType } from 'b-pl-tree'\n\nexport function ensure_indexed_value<T extends Item>(\n  item: T | Partial<T>,\n  key: unknown,\n  collection: Collection<T>,\n  gen?: IdGeneratorFunction<T> | undefined,\n  auto?: boolean,\n  process?: (value: any) => any,\n): ValueType {\n  let value: ValueType\n\n  // Check if this is a compound index by looking at the indexDef\n  const indexDef = collection.indexDefs[key as string]\n  const isCompoundIndex = !!(indexDef?.keys || indexDef?.composite)\n\n  if (process && isCompoundIndex) {\n    // For compound indexes, pass the entire item to process function\n    value = process(item)\n  } else {\n    // For single key indexes, use lodash get\n    value = get<T>(item as T, key as any) as unknown as ValueType\n    if (value == null && auto) {\n      value = gen?.(item, collection.name, collection.list) ?? value\n      set(item, key as any, value)\n    }\n    // For single key indexes, apply process to the extracted value\n    if (process && !isCompoundIndex) {\n      value = process(value)\n    }\n  }\n\n  return value\n}\n",
    "import { get } from 'lodash-es'\nimport { Item } from '../types/Item'\n\nexport function get_value<T extends Item>(\n  item: T,\n  key: string,\n  process?: (value: any) => any,\n) {\n  let value: any\n\n  // For compound indexes, use the process function directly\n  if (process) {\n    value = process(item)\n  } else {\n    // For single key indexes, use lodash get\n    value = get(item, key)\n  }\n\n  return value\n}\n",
    "import { Item } from '../types/Item'\nimport { ValueType } from 'b-pl-tree'\nimport Collection from '../collection'\n\nexport function validate_indexed_value_for_insert<T extends Item>(\n  collection: Collection<T>,\n  value: ValueType,\n  key: string,\n  sparse: boolean,\n  required: boolean,\n  unique: boolean,\n): [boolean, string?] {\n  if (!(sparse && value == null)) {\n    if (required && value == null) {\n      return [false, `value for index ${key} is required, but ${value} is met`]\n    }\n      if (\n    unique &&\n    collection.indexes.hasOwnProperty(key) &&\n    collection.indexes[key].findFirst(value) !== undefined\n  ) {\n    return [false, `unique index ${key} already contains value ${value}`]\n  }\n  }\n  return [true]\n}\n",
    "import { Item } from '../types/Item'\nimport { ValueType } from 'b-pl-tree'\nimport Collection from '../collection'\n\nexport async function validate_indexed_value_for_update<T extends Item>(\n  collection: Collection<T>,\n  value: ValueType,\n  key: string,\n  sparse: boolean,\n  required: boolean,\n  unique: boolean,\n  id: ValueType,\n): Promise<[boolean, string?]> {\n  if (!(sparse && value == null)) {\n    if (required && value == null) {\n      return [false, `value for index ${key} is required, but ${value} is met`]\n    }\n    if (\n      unique &&\n      collection.indexes.hasOwnProperty(key)\n    ) {\n      const existingPosition = collection.indexes[key].findFirst(value)\n      if (existingPosition !== undefined) {\n        // Get the item at that position to check if it's the same item we're updating\n        const existingItem = await collection.list.get(existingPosition)\n        if (existingItem && existingItem[collection.id] !== id) {\n          return [false, `unique index ${key} already contains value ${value}`]\n        }\n      }\n    }\n  }\n  return [true]\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\n\nexport async function ensure_indexes<T extends Item>(\n  collection: Collection<T>,\n) {\n  for (const ensure of collection.ensures) {\n    ensure()\n  }\n}\n",
    "import { get } from 'lodash-es'\nimport { Item } from '../types/Item'\nimport { Paths } from '../types/Paths'\nimport { CompositeKeyField } from '../types/IndexDef'\n\n/**\n * Utilities for working with composite keys in indexes\n * Provides serialization, deserialization, and comparison functions\n */\nexport class CompositeKeyUtils {\n  /**\n   * Default separator for composite key serialization\n   * Using null character to avoid conflicts with user data\n   */\n  static readonly DEFAULT_SEPARATOR = '\\u0000'\n\n    /**\n   * Serializes an array of values into a single string key\n   * @param values Array of values to serialize\n   * @param separator Separator character (default: null character)\n   * @returns Serialized composite key as string\n   */\n  static serialize(values: any[], separator: string = CompositeKeyUtils.DEFAULT_SEPARATOR): string {\n    return values.map(value => {\n      if (value === null || value === undefined) {\n        return ''\n      }\n      // Convert to string and escape separator if it exists in the value\n      const stringValue = String(value)\n      // First escape backslashes, then escape the separator\n      return stringValue\n        .replace(/\\\\/g, '\\\\\\\\')  // Escape backslashes first\n        .replace(new RegExp(separator.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'g'), `\\\\${separator}`)\n    }).join(separator)\n  }\n\n  /**\n   * Deserializes a composite key string back into array of values\n   * @param serialized Serialized composite key string\n   * @param separator Separator character used during serialization\n   * @returns Array of deserialized values\n   */\n  static deserialize(serialized: string, separator: string = CompositeKeyUtils.DEFAULT_SEPARATOR): any[] {\n    if (!serialized) {\n      return []\n    }\n\n    // More robust splitting that handles escaped separators\n    const parts: string[] = []\n    let current = ''\n    let i = 0\n\n    while (i < serialized.length) {\n      if (serialized[i] === '\\\\' && i + 1 < serialized.length) {\n        // Handle escaped character\n        current += serialized[i + 1]\n        i += 2\n      } else if (serialized[i] === separator) {\n        // Found unescaped separator\n        parts.push(current === '' ? null : current)\n        current = ''\n        i++\n      } else {\n        current += serialized[i]\n        i++\n      }\n    }\n\n    // Add the last part\n    parts.push(current === '' ? null : current)\n\n    return parts\n  }\n\n  /**\n   * Compares two composite key strings lexicographically\n   * @param a First composite key\n   * @param b Second composite key\n   * @returns Comparison result (-1, 0, 1)\n   */\n  static compare(a: string, b: string): number {\n    if (a < b) return -1\n    if (a > b) return 1\n    return 0\n  }\n\n  /**\n   * Extracts values from an item using the specified key paths\n   * @param item Item to extract values from\n   * @param keyPaths Array of paths to extract\n   * @returns Array of extracted values\n   */\n  static extractValues<T extends Item>(\n    item: T,\n    keyPaths: Array<string | Paths<T>>\n  ): any[] {\n    return keyPaths.map(path => {\n      if (typeof path === 'string') {\n        return get(item, path)\n      }\n      return get(item, path as string)\n    })\n  }\n\n  /**\n   * Creates a composite key from an item using specified paths\n   * @param item Item to create key from\n   * @param keyPaths Array of paths to use for the key\n   * @param separator Separator character\n   * @returns Serialized composite key\n   */\n  static createKey<T extends Item>(\n    item: T,\n    keyPaths: Array<string | Paths<T>>,\n    separator: string = CompositeKeyUtils.DEFAULT_SEPARATOR\n  ): string {\n    const values = CompositeKeyUtils.extractValues(item, keyPaths)\n    return CompositeKeyUtils.serialize(values, separator)\n  }\n\n  /**\n   * Validates that key paths are valid for composite key creation\n   * @param keyPaths Array of paths to validate\n   * @returns True if valid, false otherwise\n   */\n  static validateKeyPaths(keyPaths: Array<string | any>): boolean {\n    if (!Array.isArray(keyPaths) || keyPaths.length === 0) {\n      return false\n    }\n\n    return keyPaths.every(path =>\n      typeof path === 'string' && path.length > 0\n    )\n  }\n\n  /**\n   * Generates a composite index name from key paths\n   * @param keyPaths Array of paths\n   * @returns Generated index name\n   */\n  static generateIndexName(keyPaths: Array<string | any>): string {\n    return keyPaths.map(path => String(path)).join(',')\n  }\n\n  /**\n   * Checks if a value represents an empty composite key component\n   * @param value Value to check\n   * @returns True if empty, false otherwise\n   */\n  static isEmptyValue(value: any): boolean {\n    return value === null || value === undefined || value === ''\n  }\n\n  /**\n   * Creates a partial composite key for range queries\n   * @param values Array of values (can be partial)\n   * @param separator Separator character\n   * @returns Partial composite key\n   */\n  static createPartialKey(\n    values: any[],\n    separator: string = CompositeKeyUtils.DEFAULT_SEPARATOR\n  ): string {\n    // Filter out undefined values at the end for partial matching\n    const filteredValues = []\n    for (let i = 0; i < values.length; i++) {\n      if (values[i] !== undefined) {\n        filteredValues.push(values[i])\n      } else {\n        break // Stop at first undefined to maintain order\n      }\n    }\n\n    return CompositeKeyUtils.serialize(filteredValues, separator)\n  }\n\n  /**\n   * Normalizes composite key definition to array of CompositeKeyField objects\n   * @param keys Array of keys (can be strings, Paths, or CompositeKeyField objects)\n   * @returns Array of normalized CompositeKeyField objects\n   */\n  static normalizeCompositeKeys<T extends Item>(\n    keys: Array<string | Paths<T> | CompositeKeyField<T>>\n  ): Array<CompositeKeyField<T>> {\n    return keys.map(key => {\n      if (typeof key === 'string') {\n        return { key, order: 'asc' }\n      } else if (typeof key === 'object' && 'key' in key) {\n        return { key: key.key, order: key.order || 'asc' }\n      } else {\n        return { key: key as Paths<T>, order: 'asc' }\n      }\n    })\n  }\n\n  /**\n   * Extracts values from an item using normalized composite key fields\n   * @param item Item to extract values from\n   * @param fields Array of normalized composite key fields\n   * @returns Array of extracted values\n   */\n  static extractValuesWithOrder<T extends Item>(\n    item: T,\n    fields: Array<CompositeKeyField<T>>\n  ): any[] {\n    return fields.map(field => {\n      const value = get(item, field.key as string)\n      return value\n    })\n  }\n\n  /**\n   * Creates a comparator function for composite keys with mixed sort orders\n   * @param fields Array of composite key fields with sort orders\n   * @param separator Separator used for serialization\n   * @returns Comparator function for B+ Tree\n   */\n  static createComparator<T extends Item>(\n    fields: Array<CompositeKeyField<T>>,\n    separator: string = CompositeKeyUtils.DEFAULT_SEPARATOR\n  ): (a: string, b: string) => number {\n    return (a: string, b: string): number => {\n      const valuesA = CompositeKeyUtils.deserialize(a, separator)\n      const valuesB = CompositeKeyUtils.deserialize(b, separator)\n\n      for (let i = 0; i < Math.min(valuesA.length, valuesB.length, fields.length); i++) {\n        const field = fields[i]\n        const valueA = valuesA[i]\n        const valueB = valuesB[i]\n\n        // Handle null/undefined values\n        if (valueA === null && valueB === null) continue\n        if (valueA === null) return field.order === 'asc' ? -1 : 1\n        if (valueB === null) return field.order === 'asc' ? 1 : -1\n\n        // Compare values\n        let comparison = 0\n        if (typeof valueA === 'string' && typeof valueB === 'string') {\n          comparison = valueA.localeCompare(valueB)\n        } else if (typeof valueA === 'number' && typeof valueB === 'number') {\n          comparison = valueA - valueB\n        } else if (valueA instanceof Date && valueB instanceof Date) {\n          comparison = valueA.getTime() - valueB.getTime()\n        } else {\n          // Fallback to string comparison\n          comparison = String(valueA).localeCompare(String(valueB))\n        }\n\n        if (comparison !== 0) {\n          return field.order === 'desc' ? -comparison : comparison\n        }\n      }\n\n      return 0\n    }\n  }\n\n  /**\n   * Creates a composite key with sort order consideration\n   * @param item Item to create key from\n   * @param fields Array of composite key fields with sort orders\n   * @param separator Separator character\n   * @returns Serialized composite key\n   */\n  static createKeyWithOrder<T extends Item>(\n    item: T,\n    fields: Array<CompositeKeyField<T>>,\n    separator: string = CompositeKeyUtils.DEFAULT_SEPARATOR\n  ): string {\n    const values = CompositeKeyUtils.extractValuesWithOrder(item, fields)\n    return CompositeKeyUtils.serialize(values, separator)\n  }\n\n  /**\n   * Validates composite key fields configuration\n   * @param fields Array of composite key fields to validate\n   * @returns True if valid, false otherwise\n   */\n  static validateCompositeKeyFields<T extends Item>(\n    fields: Array<CompositeKeyField<T>>\n  ): boolean {\n    if (!Array.isArray(fields) || fields.length === 0) {\n      return false\n    }\n\n    return fields.every(field =>\n      field &&\n      typeof field === 'object' &&\n      'key' in field &&\n      (typeof field.key === 'string' && field.key.length > 0) &&\n      (!field.order || field.order === 'asc' || field.order === 'desc')\n    )\n  }\n\n  /**\n   * Generates index name from composite key fields\n   * @param fields Array of composite key fields\n   * @returns Generated index name\n   */\n  static generateIndexNameFromFields<T extends Item>(\n    fields: Array<CompositeKeyField<T>>\n  ): string {\n    return fields.map(field => {\n      const keyStr = String(field.key)\n      return field.order === 'desc' ? `${keyStr}:desc` : keyStr\n    }).join(',')\n  }\n}",
    "import { SortOrder } from '../types/IndexDef'\n\n/**\n * Single Key utilities for handling sort order in single key indexes\n */\nexport class SingleKeyUtils {\n  /**\n   * Creates a comparator function for single keys with specified sort order\n   * @param order - Sort order ('asc' or 'desc')\n   * @returns Comparator function for BPlusTree\n   */\n  static createComparator(order: SortOrder = 'asc'): (a: any, b: any) => number {\n    return (a: any, b: any): number => {\n      // Handle null/undefined values\n      if (a === null && b === null) return 0\n      if (a === null) return order === 'asc' ? -1 : 1\n      if (b === null) return order === 'asc' ? 1 : -1\n      if (a === undefined && b === undefined) return 0\n      if (a === undefined) return order === 'asc' ? -1 : 1\n      if (b === undefined) return order === 'asc' ? 1 : -1\n\n      // Handle different data types\n      let result = 0\n\n      if (typeof a === 'number' && typeof b === 'number') {\n        result = a - b\n      } else if (typeof a === 'string' && typeof b === 'string') {\n        result = a.localeCompare(b)\n      } else if (typeof a === 'boolean' && typeof b === 'boolean') {\n        result = a === b ? 0 : (a ? 1 : -1)\n      } else if (a instanceof Date && b instanceof Date) {\n        result = a.getTime() - b.getTime()\n      } else {\n        // Fallback to string comparison\n        result = String(a).localeCompare(String(b))\n      }\n\n      // Apply sort order\n      const finalResult = order === 'desc' ? -result : result\n      // Ensure we return 0 instead of -0\n      return finalResult === 0 ? 0 : finalResult\n    }\n  }\n\n  /**\n   * Validates sort order value\n   * @param order - Sort order to validate\n   * @returns True if valid, false otherwise\n   */\n  static validateSortOrder(order: any): order is SortOrder {\n    return order === 'asc' || order === 'desc'\n  }\n\n  /**\n   * Normalizes sort order value with default\n   * @param order - Sort order to normalize\n   * @returns Normalized sort order ('asc' if invalid)\n   */\n  static normalizeSortOrder(order?: SortOrder): SortOrder {\n    return this.validateSortOrder(order) ? order : 'asc'\n  }\n}",
    "import { IndexDef } from '../types/IndexDef'\nimport { Item } from '../types/Item'\nimport { Dictionary } from '../types/Dictionary'\nimport Collection from '../collection'\nimport { create_index } from './create_index'\n\nexport function build_indexes<T extends Item>(\n  collection: Collection<T>,\n  indexList: Dictionary<IndexDef<T>>,\n): void {\n  for (const key in indexList) {\n    create_index<T>(collection, key, indexList[key])\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport Collection, { ttl_key } from '../collection'\n\nexport function is_valid_ttl<T extends Item>(\n  collection: Collection<T>,\n  item?: T,\n) {\n  if (item) {\n    if (item[ttl_key]) {\n      const now = Date.now()\n      return now - item[ttl_key] <= collection.ttl!\n    } else {\n      return true\n    }\n  } else {\n    return false\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport { ensure_ttl } from './ensure_ttl'\nimport Collection from '../collection'\nimport { is_valid_ttl } from './is_valid_ttl'\n\nexport async function return_list_if_valid<T extends Item>(\n  collection: Collection<T>,\n  items: Array<T>,\n): Promise<Array<T>> {\n  let invalidate: boolean = false\n\n  const result = items.filter((i) => {\n    if (is_valid_ttl(collection, i)) {\n      return true\n    } else {\n      invalidate = true\n      return false\n    }\n  })\n\n  if (invalidate) {\n    if (collection.ttl && collection.list.length > 0) {\n      await ensure_ttl(collection)\n    }\n  }\n  return result\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { return_list_if_valid } from './return_list_if_valid'\nimport { ValueType } from 'b-pl-tree'\n\nexport async function get_indexed_value<T extends Item>(\n  collection: Collection<T>,\n  key: string,\n  value: ValueType,\n): Promise<Array<T>> {\n  const result: Array<T> = []\n  if (collection.indexes[key]) {\n    const keys = collection.indexes[key].find(value)\n    for (const key of keys) {\n      const res = await collection.list.get(key)\n      result.push(res!)\n    }\n  }\n  return return_list_if_valid(collection, result)\n}",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { ensure_ttl } from './ensure_ttl'\nimport { is_valid_ttl } from './is_valid_ttl'\n\nexport async function return_one_if_valid<T extends Item>(\n  collection: Collection<T>,\n  result: T | undefined,\n): Promise<T | undefined> {\n  let invalidate = false\n\n  if (result && !is_valid_ttl(collection, result)) {\n    invalidate = true\n  }\n  if (invalidate) {\n    if (collection.ttl && collection.list.length > 0) {\n      await ensure_ttl(collection)\n    }\n  }\n  return invalidate ? undefined : result\n}\n",
    "import * as _ from 'lodash-es'\nimport { IndexDef } from '../types/IndexDef'\nimport { IndexStored } from '../types/IndexStored'\nimport { Item } from '../types/Item'\nimport { Dictionary } from '../types/Dictionary'\nimport { restore_index_def } from './restore_index_def'\nimport Collection from '../collection'\n\nexport function restore_index<T extends Item>(\n  collection: Collection<T>,\n  input: Dictionary<IndexStored<T>>,\n): Dictionary<IndexDef<T>> {\n  return _.map(input, (index) => {\n    return restore_index_def(collection, index)\n  }).reduce((res, cur) => {\n    res[cur.key] = cur\n    return res\n  }, {} as Dictionary<IndexDef<T>>)\n}\n",
    "import { Item } from '../types/Item'\nimport { IndexDef } from '../types/IndexDef'\nimport { IndexStored } from '../types/IndexStored'\nimport Collection from '../collection'\n\nexport function restore_index_def<T extends Item>(\n  collection: Collection<T>,\n  input: IndexStored<T>,\n): IndexDef<T> {\n  const { key, auto, unique, sparse, required, ignoreCase } = input\n  return {\n    key,\n    auto,\n    unique,\n    sparse,\n    required,\n    ignoreCase,\n    process: ignoreCase\n      ? undefined\n      : input.process\n      ? eval(input.process)\n      : undefined,\n    gen: input.gen\n      ? Collection.genCache[input.gen]\n        ? Collection.genCache[input.gen]\n        : eval(input.gen)\n      : undefined,\n  }\n}\n",
    "import {\n  BPlusTree,\n  ValueType,\n  PortableBPlusTree,\n  serializeTree,\n  deserializeTree,\n  createTreeFrom\n} from 'b-pl-tree'\n\nexport interface SerializedBPlusTree {\n  t: number\n  unique: boolean\n  root: any\n}\n\nexport function serializeBPlusTree<T, K extends ValueType>(\n  tree: BPlusTree<T, K>\n): PortableBPlusTree<T, K> {\n  return serializeTree(tree)\n}\n\nexport function deserializeBPlusTree<T, K extends ValueType>(\n  data: PortableBPlusTree<T, K>\n): BPlusTree<T, K> {\n  return createTreeFrom<T, K>(data)\n}\n\nexport function deserializeBPlusTreeInto<T, K extends ValueType>(\n  tree: BPlusTree<T, K>,\n  data: PortableBPlusTree<T, K>\n): void {\n  deserializeTree(tree, data)\n}\n\nexport function cloneBPlusTree<T, K extends ValueType>(\n  source: BPlusTree<T, K>\n): BPlusTree<T, K> {\n  const serialized = serializeTree(source)\n  return createTreeFrom<T, K>(serialized)\n}",
    "import { Dictionary } from '../types/Dictionary'\nimport { BPlusTree, PortableBPlusTree, ValueType } from 'b-pl-tree'\nimport { deserializeBPlusTree } from '../utils/btree-serialization'\n\nexport function deserialize_indexes(\n  indexes: Dictionary<PortableBPlusTree<any, ValueType>>,\n): Dictionary<BPlusTree<any, ValueType>> {\n  return Object.keys(indexes).reduce((res, cur) => {\n    res[cur] = deserializeBPlusTree(indexes[cur])\n    return res\n  }, {} as Dictionary<BPlusTree<any, ValueType>>)\n}\n",
    "import { Dictionary } from '../types/Dictionary'\nimport { BPlusTree, ValueType, PortableBPlusTree } from 'b-pl-tree'\nimport { serializeBPlusTree } from '../utils/btree-serialization'\n\nexport function serialize_indexes(\n  indexes: Dictionary<BPlusTree<any, ValueType>>,\n): Dictionary<PortableBPlusTree<any, ValueType>> {\n  return Object.keys(indexes).reduce((res, cur) => {\n    res[cur] = serializeBPlusTree(indexes[cur])\n    return res\n  }, {} as Dictionary<PortableBPlusTree<any, ValueType>>)\n}\n",
    "import * as _ from 'lodash-es'\nimport { IndexDef } from '../types/IndexDef'\nimport { IndexStored } from '../types/IndexStored'\nimport { Item } from '../types/Item'\nimport { Dictionary } from '../types/Dictionary'\nimport { store_index_def } from './store_index_def'\nimport Collection from '../collection'\n\nexport function store_index<T extends Item>(\n  collection: Collection<T>,\n  input: Dictionary<IndexDef<T>>,\n): Dictionary<IndexStored<T>> {\n  return _.map(input, (index) => {\n    return store_index_def(collection, index)\n  }).reduce((res, cur) => {\n    res[cur.key as string] = cur\n    return res\n  }, {} as Dictionary<IndexStored<T>>)\n}\n",
    "import { IndexDef } from '../types/IndexDef'\nimport { IndexStored } from '../types/IndexStored'\nimport { Item } from '../types/Item'\nimport Collection from '../collection'\n\nexport function store_index_def<T extends Item>(\n  collection: Collection<T>,\n  input: IndexDef<T>,\n): IndexStored<T> {\n  const { key, auto, unique, sparse, required, ignoreCase } = input\n  return {\n    key,\n    auto,\n    unique,\n    sparse,\n    required,\n    ignoreCase,\n    process: ignoreCase\n      ? undefined\n      : input.process\n      ? input.process.toString()\n      : undefined,\n    gen: input.gen\n      ? Collection.genCache[input.gen.name]\n        ? input.gen.name\n        : input.gen.toString()\n      : undefined,\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport { build_indexes } from './build_indexes'\nimport { ensure_indexes } from './ensure_indexes'\nimport Collection from '../collection'\n\nexport async function copy_collection<T extends Item>(\n  model: string,\n  source: Collection<T>,\n  dest?: Collection<T>,\n): Promise<Collection<T>> {\n  const collection =\n    dest ??\n    Collection.create<T>({\n      root: source.root,\n      name: model,\n      adapter: source.storage.clone(),\n      list: source.list.construct(),\n      // id: source.id,\n      // ttl: source.ttl,\n    })\n\n  collection.indexDefs = source.indexDefs\n  collection.id = source.id\n  collection.ttl = source.ttl\n\n  collection.inserts = []\n  collection.removes = []\n  collection.updates = []\n  collection.ensures = []\n\n  collection.indexes = {}\n  build_indexes(collection, collection.indexDefs)\n  await ensure_indexes(collection)\n  for await (const item of source.list.forward) {\n    await collection.push(item)\n  }\n  await collection.persist()\n  return collection\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { copy_collection } from './copy_collection'\n\nexport async function do_rotate_log<T extends Item>(\n  source: Collection<T>,\n): Promise<void> {\n  await copy_collection(`${source.name}.${new Date().toJSON()}`, source)\n\n  await source.reset()\n  await source.persist()\n}\n",
    "import { Paths } from '../types/Paths'\nimport { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { return_one_if_valid } from './return_one_if_valid'\nimport { ValueType } from 'b-pl-tree'\n\nexport async function get_first_indexed_value<T extends Item>(\n  collection: Collection<T>,\n  key: Paths<T>,\n  value: ValueType,\n): Promise<T | undefined> {\n  if (collection.indexes[key]) {\n    const id = collection.indexes[key].findFirst(value)\n    const result: T | undefined =\n      id != null ? await collection.list.get(id) : undefined\n    return return_one_if_valid(collection, result)\n  }\n}\n",
    "import { Paths } from '../types/Paths'\nimport { Item } from '../types/Item'\nimport Collection from '../collection'\nimport { return_one_if_valid } from './return_one_if_valid'\nimport { ValueType } from 'b-pl-tree'\n\nexport async function get_last_indexed_value<T extends Item>(\n  collection: Collection<T>,\n  key: Paths<T>,\n  value: ValueType,\n): Promise<T | undefined> {\n  if (collection.indexes[key]) {\n    const id = collection.indexes[key].findLast(value)\n    const result = id != null ? await collection.list.get(id) : undefined\n    return return_one_if_valid(collection, result)\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport Collection from '../collection'\n\nexport async function rebuild_indexes<T extends Item>(\n  collection: Collection<T>,\n) {\n  for (const reduild of collection.rebuilds) {\n    await reduild()\n  }\n}\n",
    "import { ValueType } from 'b-pl-tree'\nimport { get, set, unset, cloneDeep } from 'lodash-es'\nimport { StoredIList } from '../types/StoredIList'\nimport { Item } from '../types/Item'\nimport { IList } from '../IList'\nimport Collection from '../collection'\nimport { entity_create } from '../utils/entity_create'\nimport { entity_update } from '../utils/entity_update'\nimport { entity_delete } from '../utils/entity_delete'\nimport { is_stored_record } from '../utils/is_stored_record'\nimport { IStoredRecord } from '../types/IStoredRecord'\n\nexport class List<T extends Item> implements IList<T> {\n  get name() {\n    return 'List' as const\n  }\n  singlefile: boolean = true\n  hash: { [key: string]: T } = {}\n  _counter: number = 0\n  _count: number = 0\n  collection!: Collection<T>\n  exists: Promise<boolean> = Promise.resolve(true)\n\n  init(collection: Collection<T>): IList<T> {\n    this.collection = collection\n    return this as IList<T>\n  }\n\n  async clone(): Promise<IList<T>> {\n    const list = new List<T>()\n    list.load(this.persist())\n    return list\n  }\n\n  async get(key: ValueType) {\n    const item = get(this.hash, String(key))\n    let result: T\n    if (is_stored_record<T>(item)) {\n      result = cloneDeep<T>(item.data!)\n      if (!this.collection.audit) {\n        set(this.hash, String(key), result)\n      }\n    } else {\n      result = cloneDeep(item)\n    }\n    return result\n  }\n\n  get counter() {\n    return this._counter\n  }\n\n  get length() {\n    return Object.keys(this.hash).length\n  }\n\n  set length(len) {\n    if (len === 0) {\n      this.reset()\n    }\n  }\n\n  async set(key: ValueType, item: T) {\n    let valiadtor = this.collection.validator(item)\n    if (valiadtor.success) {\n      let result: T | IStoredRecord<T>\n      if (this.collection.audit) {\n        result = entity_create(\n          item[this.collection.id],\n          cloneDeep(item),\n          this.collection.validation,\n        )\n      } else {\n        result = cloneDeep(item)\n      }\n\n      const keyStr = String(key)\n      const exists = Object.prototype.hasOwnProperty.call(this.hash, keyStr)\n\n      // Use the provided key instead of _counter\n      set(this.hash, keyStr, result)\n\n      // Only increment counters if this is a new key\n      if (!exists) {\n        this._counter++\n        this._count++\n      }\n\n      return is_stored_record(item) ? item.data : item\n    }\n    throw new Error('Validation error')\n  }\n\n  async update(key: ValueType, item: T) {\n    let valiadtor = this.collection.validator(item)\n    if (valiadtor.success) {\n      let result: T = item\n      const record = get(this.hash, String(key))\n      if (this.collection.audit) {\n        let res: T | IStoredRecord<T>\n        if (!is_stored_record(record)) {\n          res = entity_create(\n            item[this.collection.id],\n            item,\n            this.collection.validation,\n          )\n        } else {\n          res = entity_update(record, cloneDeep(item))\n        }\n        set(this.hash, String(key), res)\n        result = res.data\n      } else {\n        set(this.hash, String(key), cloneDeep(result))\n      }\n      return result\n    }\n    throw new Error('Validation error')\n  }\n\n  async delete(i: ValueType) {\n    const item = get(this.hash, i?.toString() ?? 'undefined')\n    let result: T\n    if (is_stored_record<T>(item)) {\n      entity_delete(item)\n      result = cloneDeep(item.data)\n      this._count--\n    } else {\n      unset(this.hash, i?.toString() ?? 'undefined')\n      this._count--\n      result = cloneDeep(item)\n    }\n    return result\n  }\n\n  async reset() {\n    this._count = 0\n    this._counter = 0\n    this.hash = {}\n  }\n\n  get keys() {\n    return Object.keys(this.hash)\n  }\n\n  load(obj: StoredIList): IList<T> {\n    this.hash = obj.hash\n    this._count = obj._count\n    this._counter = obj._counter\n    return this\n  }\n\n  construct() {\n    return new List<T>()\n  }\n\n  persist(): StoredIList {\n    return {\n      counter: this._counter,\n      tree: {} as any, // List doesn't use tree, but interface requires it\n      _count: this._count,\n      _counter: this._counter,\n      hash: this.hash,\n    }\n  }\n\n  get forward(): AsyncIterable<T> {\n    return {\n      [Symbol.asyncIterator]: () => this.toArray(),\n    }\n  }\n  get backward(): AsyncIterable<T> {\n    return {\n      [Symbol.asyncIterator]: () => this.toArrayReverse(),\n    }\n  }\n\n  async *toArray() {\n    for (const key of this.keys) {\n      yield get(this.hash, key)\n    }\n  }\n  async *toArrayReverse() {\n    for (const key of this.keys.reverse()) {\n      yield get(this.hash, key)\n    }\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport { ValueType } from 'b-pl-tree'\nimport { diff } from 'jsondiffpatch'\nimport { IStoredRecord } from '../types/IStoredRecord'\nimport { version_create } from './version_create'\nimport { ZodType } from 'zod'\n\nexport function entity_create<T extends Item>(\n  id: ValueType,\n  item: T,\n  schema?: ZodType<T>,\n): IStoredRecord<T> {\n  return {\n    id,\n    version: 0,\n    next_version: 1,\n    data: item,\n    created: Date.now(),\n    updated: undefined,\n    deleted: undefined,\n    schema,\n    history: [version_create(0, diff({}, item)!)],\n  }\n}\n",
    "import { Delta } from 'jsondiffpatch'\nimport { IVersion } from '../types/IVersion'\n\nexport function version_create(version: number, delta: Delta): IVersion {\n  return {\n    version,\n    delta,\n    date: Date.now(),\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport { diff } from 'jsondiffpatch'\nimport { IStoredRecord } from '../types/IStoredRecord'\nimport { version_create } from './version_create'\n\nexport function entity_update<T extends Item>(\n  record: IStoredRecord<T>,\n  item: T,\n): IStoredRecord<T> {\n  const delta = diff(record.data, item)\n  const v = version_create(record.next_version, delta!)\n  record.history.push(v)\n  return {\n    ...record,\n    data: item,\n    updated: Date.now(),\n    next_version: record.next_version + 1,\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport { diff } from 'jsondiffpatch'\nimport { IStoredRecord } from '../types/IStoredRecord'\nimport { version_create } from './version_create'\n\nexport function entity_delete<T extends Item>(\n  record: IStoredRecord<T>,\n): IStoredRecord<T> {\n  const delta = diff({}, record.data)\n  const v = version_create(record.next_version, delta!)\n  record.history.push(v)\n  return {\n    ...record,\n    data: {} as T,\n    deleted: Date.now(),\n    next_version: record.next_version + 1,\n  }\n}\n",
    "import { IStoredRecord } from '../types/IStoredRecord'\nimport { Item } from '../types/Item'\n\nexport function is_stored_record<T extends Item>(item: T | IStoredRecord<T>): item is IStoredRecord<T> {\n  if (!item || typeof item !== 'object') return false\n  return (\n    Object.prototype.hasOwnProperty.call(item, 'version') &&\n    typeof (item as any).version === 'number' &&\n    Object.prototype.hasOwnProperty.call(item, 'next_version') &&\n    typeof (item as any).next_version === 'number' &&\n    Object.prototype.hasOwnProperty.call(item, 'created') &&\n    typeof (item as any).created === 'number' &&\n    Object.prototype.hasOwnProperty.call(item, 'history') &&\n    Array.isArray((item as any).history)\n  )\n}\n",
    "import Collection from './collection'\nimport { Item } from './types/Item'\nimport { IStorageAdapter } from './IStorageAdapter'\n\nexport default class AdapterMemory<T extends Item>\n  implements IStorageAdapter<T>\n{\n  get name() {\n    return 'AdapterMemory' as const\n  }\n  collection!: Collection<T>\n  clone(): AdapterMemory<T> {\n    return new AdapterMemory<T>()\n  }\n\n  init(collection: Collection<T>): this {\n    this.collection = collection\n    return this\n  }\n\n  restore(name?: string): Promise<any> {\n    return Promise.resolve({})\n  }\n\n  store(name: string) {\n    return Promise.resolve()\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport { ISerializedCollectionConfig } from '../ICollectionConfig'\nimport Collection, { serializeIndex } from '../collection'\n\nexport function serialize_collection_config<T extends Item>(\n  collection: Collection<T>,\n): ISerializedCollectionConfig {\n  const res: ISerializedCollectionConfig = {} as ISerializedCollectionConfig\n  res.audit = collection.audit ? true : undefined\n  res.root = collection.root\n  res.rotate = collection.rotate ?? undefined\n  res.ttl = collection.ttl ? collection.ttl : undefined\n  res.name = collection.name\n  res.adapter = collection.storage.name\n  res.list = collection.list.name\n  res.id = collection.id || 'id'\n  res.auto = collection.auto ?? undefined\n  // Ð´Ð¾Ð±Ð°Ð²Ð¸ÑÑ ÑÐµÑÐ¸Ð°Ð»Ð¸Ð·Ð°ÑÐ¸Ñ ÑÑÐµÐ¼Ñ\n  // Ð¸Ð»Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ñ ajv??\n  res.indexList = Object.keys(collection.indexDefs).map((name) => {\n    const res = collection.indexDefs[name]\n    return serializeIndex<T>(res)\n  })\n  return res\n}\n",
    "import { ValueType, BPlusTree } from 'b-pl-tree'\nimport { StoredIList } from '../types/StoredIList'\nimport { Item } from '../types/Item'\nimport fs from 'fs-extra'\nimport pathlib from 'path'\nimport { IList } from '../IList'\nimport Collection from '../collection'\nimport { entity_delete } from '../utils/entity_delete'\nimport { entity_update } from '../utils/entity_update'\nimport { IStoredRecord } from '../types/IStoredRecord'\nimport { entity_create } from '../utils/entity_create'\nimport { is_stored_record } from '../utils/is_stored_record'\nimport { cloneDeep } from 'lodash-es'\nimport { fromZodError } from 'zod-validation-error'\nimport { cloneBPlusTree, serializeBPlusTree, deserializeBPlusTree } from '../utils/btree-serialization'\n\nexport class FileStorage<T extends Item>\n  implements IList<T>\n{\n  get name() {\n    return 'FileStorage' as const\n  }\n  singlefile: boolean = false\n\n  //  ÑÑÐ°Ð½Ð¸ÑÑ Ð¿ÑÐ¾Ð¼Ð¸ÑÑ ÑÐ¸Ð¿Ð° ÐºÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ Ð´Ð°Ð½Ð½ÑÑ Ðº ÐºÐ¾ÑÐ¾ÑÑÐ¼ Ð±ÑÐ» Ð´Ð¾ÑÑÑÐ¿, Ð¸ ÐºÐ¾ÑÐ¾ÑÑÐµ Ð½Ðµ Ð¾Ð±Ð½Ð¾Ð²Ð»ÑÐ»Ð¸ÑÑ\n  // Ð° Ð½Ð° Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð²ÑÑÑÐ°Ð²Ð»ÑÑÑ Ð½Ð¾Ð²ÑÐ¹ Ð¿ÑÐ¾Ð¼Ð¸Ñ\n  // ÑÐ°ÐºÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼ Ð´Ð°Ð½Ð½ÑÐµ Ð²ÑÐµÐ³Ð´Ð° Ð±ÑÐ´ÑÑ ÑÐ²ÐµÐ¶Ð¸Ð¼Ð¸... ÐµÑÐ»Ð¸ Ð½ÐµÑ Ð´ÑÑÐ³Ð¾Ð³Ð¾ ÑÐ¸ÑÐ°ÑÐµÐ»Ñ Ð¿Ð¸ÑÐ°ÑÐµÐ»Ñ ÑÐ°Ð¹Ð»Ð¾Ð²\n  // Ð¼Ð¾Ð¶Ð½Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÑ Ð´Ð»Ñ Ð¼Ð¾Ð½Ð¸ÑÑÐ¾Ð¸Ð½Ð³Ð° Ð·Ð° ÑÐ°Ð¹Ð»Ð°Ð¼Ð¸\n  tree: BPlusTree<string, ValueType> = new BPlusTree(32, true)\n  get folder(): string {\n    return pathlib.join(this.collection.root, this.collection.name)\n  }\n  private keyField?: string\n  constructor(keyField?: string) {\n    this.keyField = keyField\n  }\n  exists!: Promise<boolean>\n  collection!: Collection<T>\n  construct() {\n    return new FileStorage<T>()\n  }\n\n  init(collection: Collection<T>): IList<T> {\n    this.collection = collection\n    if (this.keyField && !this.collection.indexDefs[this.keyField].unique) {\n      throw new Error(`key field ${this.keyField} is not unique`)\n    }\n    this.exists = fs\n      .ensureDir(this.folder)\n      .then((_) => true)\n      .catch((_) => false)\n    return this\n  }\n  async clone(): Promise<IList<T>> {\n    if (await this.exists) {\n      const res = new FileStorage<T>()\n      res.tree = cloneBPlusTree(this.tree)\n      return res\n    }\n    throw new Error('folder not found')\n  }\n  persist(): StoredIList {\n    return {\n      keyField: this.keyField,\n      counter: this._counter,\n      tree: serializeBPlusTree(this.tree),\n    }\n  }\n\n  load(obj: StoredIList): IList<T> {\n    this._counter = obj.counter\n    // prefer name that in configuration\n    this.keyField = !obj.keyField\n      ? this.keyField\n      : this.keyField\n      ? this.keyField\n      : obj.keyField\n    this.tree = deserializeBPlusTree(obj.tree)\n    return this\n  }\n\n  get forward() {\n    return {\n      [Symbol.asyncIterator]: () => this.toArray(),\n    }\n  }\n\n  get backward() {\n    return {\n      [Symbol.asyncIterator]: () => this.toArrayReverse(),\n    }\n  }\n\n  async *toArray() {\n    const res = await this.exists\n    if (res) {\n      const it = this.tree.each()(this.tree)\n      let cursor = it.next()\n      while (!cursor.done && cursor.value) {\n        yield await fs.readJSON(this.get_path(cursor.value.value))\n        cursor = it.next()\n      }\n    } else throw new Error('folder not found')\n  }\n\n  async *toArrayReverse() {\n    if (await this.exists) {\n      const it = this.tree.each(false)(this.tree)\n      let cursor = it.next()\n      while (!cursor.done && cursor.value) {\n        yield await fs.readJSON(this.get_path(cursor.value.value))\n        cursor = it.next()\n      }\n    } else throw new Error('folder not found')\n  }\n\n  private key_filename(key: ValueType) {\n    return `${key?.toString() ?? 'undefined'}.json`\n  }\n\n  private set_path(key: ValueType) {\n    return pathlib.join(this.folder, this.key_filename(key))\n  }\n\n  private get_path(value: string) {\n    return pathlib.join(this.folder, value)\n  }\n\n  async reset(): Promise<void> {\n    if (await this.exists) {\n      await fs.remove(this.folder)\n      this.tree.reset()\n      this.exists = fs\n        .ensureDir(this.folder)\n        .then((_) => true)\n        .catch((_) => false)\n    } else throw new Error('folder not found')\n  }\n\n  async get(key: ValueType): Promise<T | undefined> {\n    if (await this.exists) {\n      const value = this.tree.findFirst(key)\n      if (value) {\n        const location = this.get_path(value)\n        const result: T | IStoredRecord<T> = await fs.readJSON(location)\n        if (is_stored_record(result)) {\n          if (!this.collection.audit) {\n            await fs.writeJSON(location, result)\n          }\n          return result.data\n        } else {\n          return result\n        }\n      }\n    }\n    throw new Error('folder not found')\n  }\n\n  async set(key: ValueType, item: T): Promise<T> {\n    if (await this.exists) {\n      let valiadtor = this.collection.validator(item)\n      if (valiadtor.success) {\n        this._counter++\n        // checkif exists\n        // Ð±ÐµÑÐµÐ¼ Ð½Ð¾Ð²ÑÐ¹ ÐºÐ»ÑÑ\n        const uid = this.keyField\n          ? item[this.keyField]\n            ? item[this.keyField]\n            : key\n          : key\n\n        // Ð¿Ð¸ÑÐµÐ¼ Ð² ÑÐ°Ð¹Ð»\n\n        let result: T | IStoredRecord<T>\n        if (this.collection.audit) {\n          result = entity_create(\n            item[this.collection.id],\n            cloneDeep(item),\n            this.collection.validation,\n          )\n        } else {\n          result = cloneDeep(item)\n        }\n\n        await fs.writeJSON(this.set_path(uid), result)\n        // Ð²ÑÑÐ°Ð²Ð»ÑÐµÐ¼ Ð² ÑÑÐ°Ð½Ð¸Ð»Ð¸ÑÐµ\n        this.tree.insert(key, this.key_filename(uid))\n        return this.collection.audit ? (result as IStoredRecord<T>).data : (result as T)\n      } else {\n        console.log(fromZodError((valiadtor as any).errors))\n        throw new Error('Validation error')\n      }\n    }\n    throw new Error('folder not found')\n  }\n\n  async update(key: ValueType, item: T): Promise<T> {\n    // checkif exists\n    if (await this.exists) {\n      let valiadtor = this.collection.validator(item)\n      if (valiadtor.success) {\n        // Ð¸ÑÐµÐ¼ ÑÐµÐºÑÑÐµÐµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ ÑÐ°Ð¹Ð»Ð°\n        const location = this.get_path(this.tree.findFirst(key))\n        let result: T = item\n\n        const record = (await fs.readJSON(location)) as T\n        if (this.collection.audit) {\n          let res: T | IStoredRecord<T>\n          if (!is_stored_record(record)) {\n            res = entity_create(\n              item[this.collection.id],\n              cloneDeep(item),\n              this.collection.validation,\n            )\n          } else {\n            res = entity_update<T>(record, cloneDeep(item))\n          }\n          result = res.data\n          await fs.writeJSON(location, res)\n        } else {\n          // Ð·Ð°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ Ð² ÑÐ°Ð¹Ð»\n          await fs.writeJSON(location, result)\n        }\n        return result\n      } else {\n        console.log(fromZodError((valiadtor as any).errors))\n        throw new Error('Validation error')\n      }\n    }\n    throw new Error('folder not found')\n  }\n\n  async delete(key: ValueType): Promise<T> {\n    if (await this.exists) {\n      const value = this.tree.findFirst(key)\n      if (value) {\n        const location = this.get_path(value)\n        const item = await fs.readJSON(location)\n        let result: T\n        if (is_stored_record<T>(item)) {\n          result = item.data\n          const res = entity_delete(item)\n          await fs.writeJSON(location, res)\n        } else {\n          result = item\n          await fs.unlink(location)\n        }\n        this.tree.remove(key)\n        return result\n      }\n    }\n    throw new Error('folder not found')\n  }\n\n  _counter: number = 0\n  get counter(): number {\n    return this._counter\n  }\n  get length(): number {\n    return this.tree.size\n  }\n}\n",
    "import fs from 'fs'\nimport path from 'path'\nimport fse from 'fs-extra'\nimport { ICollectionConfig, ISerializedCollectionConfig } from './ICollectionConfig'\nimport { IDataCollection } from './IDataCollection'\nimport Collection from './collection'\nimport { Item } from './types/Item'\n\nimport AdapterFile from './AdapterFile'\nimport { deserialize_collection_config } from './collection/deserialize_collection_config'\nimport { serialize_collection_config } from './collection/serialize_collection_config'\nimport { FileStorage } from './storage/FileStorage'\nimport { List } from './storage/List'\nimport { IndexDef } from './types/IndexDef'\n\n// biome-ignore lint/complexity/noBannedTypes: Ð±ÑÐ´ÐµÑ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½\nexport type TransactionOptions = {}\n\nexport interface CSTransaction {\n  startTransaction(options: TransactionOptions): Promise<void>\n  abortTransaction(): Promise<void>\n  commitTransaction(): Promise<void>\n  endSession(): Promise<void>\n}\n\nexport class CSDatabase implements CSTransaction {\n  private root: string\n  private name: string\n  private inTransaction = false\n  private collections: Map<string, Collection<any>>\n\n  constructor(root: string, name?: string) {\n    this.root = root\n    this.name = name || 'default'\n    this.collections = new Map()\n  }\n\n  private async writeSchema() {\n    const result = {} as Record<string, ISerializedCollectionConfig>\n    this.collections.forEach((collection, name) => {\n      result[name] = serialize_collection_config(collection)\n    })\n    await fse.ensureDir(this.root)\n    fs.writeFileSync(path.join(this.root, `${this.name}.json`), JSON.stringify(result, null, 2))\n  }\n\n  async connect() {\n    await this.load()\n  }\n\n  async load() {\n    const exists = fs.existsSync(path.join(this.root, `${this.name}.json`))\n    if (!exists) {\n      fse.ensureDirSync(this.root)\n    } else {\n      const result = fse.readJSONSync(path.join(this.root, `${this.name}.json`)) as Record<\n        string,\n        ISerializedCollectionConfig\n      >\n\n      this.collections.clear()\n      for (const name in result) {\n        const config = result[name]\n        const collection = Collection.create(deserialize_collection_config(config))\n        await collection.load()\n        this.registerCollection(collection)\n      }\n    }\n  }\n\n  async close() {}\n\n  collectionList: Map<string, ICollectionConfig<any>> = new Map()\n\n  private registerCollection(collection: Collection<any>) {\n    if (!this.collections.has(collection.name)) {\n      this.collections.set(collection.name, collection)\n      return\n    }\n    throw new Error(`collection ${collection.name} already exists`)\n  }\n\n  async createCollection<T extends Item>(name: string): Promise<IDataCollection<T>> {\n    const [, collectionType = 'List'] = name.split(':')\n    const collection = Collection.create({\n      name,\n      list: collectionType === 'List' ? new List<T>() : new FileStorage<T>(),\n      adapter: new AdapterFile<T>(),\n      root: path.join(this.root, this.name),\n    })\n\n    this.registerCollection(collection)\n    await this.writeSchema()\n    return collection\n  }\n\n  listCollections(): Array<IDataCollection<any>> {\n    const result: Array<IDataCollection<any>> = []\n    this.collections.forEach((collection) => {\n      result.push(collection)\n    })\n    return result\n  }\n\n  async dropCollection(name: string): Promise<boolean> {\n    let result = false\n    if (this.collections.has(name)) {\n      const collection = this.collections.get(name)!\n      await collection.reset()\n      result = this.collections.delete(name)\n      await this.writeSchema()\n    }\n    return result\n  }\n\n  collection<T extends Item>(name: string): IDataCollection<T> | undefined {\n    if (this.collections.has(name)) {\n      return this.collections.get(name)\n    }\n    throw new Error(`collection ${name} not found`)\n  }\n\n  async createIndex(collection: string, name: string, def: IndexDef<any>) {\n    if (this.collections.has(collection)) {\n      const col = this.collections.get(collection)!\n      if (col.listIndexes(name)) {\n        col.dropIndex(name)\n        await col.createIndex(name, def)\n      }\n      await this.writeSchema()\n      return\n    }\n    throw new Error(`collection ${collection} not found`)\n  }\n\n  async dropIndex(collection: string, name: string) {\n    if (this.collections.has(collection)) {\n      this.collections.get(collection)?.dropIndex(name)\n      await this.writeSchema()\n      return\n    }\n    throw new Error(`collection ${collection} not found`)\n  }\n\n  async persist() {\n    const res: Array<Promise<void>> = []\n    this.collections.forEach((collection) => {\n      res.push(collection.persist())\n    })\n    return Promise.all(res)\n  }\n\n  async startSession(): Promise<CSTransaction> {\n    if (!this.inTransaction) {\n      await this.persist()\n    }\n    return this\n  }\n\n  async endSession(): Promise<void> {\n    this.inTransaction = false\n  }\n  async startTransaction(options: TransactionOptions): Promise<void> {\n    this.inTransaction = true\n  }\n  async abortTransaction(): Promise<void> {\n    this.inTransaction = false\n  }\n  async commitTransaction(): Promise<void> {\n    // Ð¿ÑÐ¾Ð²ÐµÑÑÑÑ ÐºÐ°ÐºÐ¸Ðµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ Ð±ÑÐ»Ð¸ Ð²Ð½ÐµÑÐµÐ½Ñ, ÑÑÐ¾ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ð»Ð¾ÑÑ Ð¸ ÑÐ¾Ð·Ð´Ð°Ð²Ð°ÑÑ ÑÑÐ°Ð½Ð·Ð°ÐºÑÐ¸Ñ Ð´Ð»Ñ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ\n    await this.persist()\n    this.inTransaction = false\n  }\n  // extra operations\n\n  async first(collection: string): Promise<any> {\n    return this.collections.get(collection)!.first()\n  }\n  async last(collection: string): Promise<any> {\n    return this.collections.get(collection)!.last()\n  }\n  async lowest(collection: string, key: string): Promise<any> {\n    return this.collections.get(collection)!.lowest(key)\n  }\n  async greatest(collection: string, key: string): Promise<any> {\n    return this.collections.get(collection)!.greatest(key)\n  }\n  async oldest(collection: string): Promise<any> {\n    return this.collections.get(collection)!.oldest()\n  }\n  async latest(collection: string): Promise<any> {\n    return this.collections.get(collection)!.latest()\n  }\n  async findById(collection: string, id: any) {\n    return this.collections.get(collection)!.findById(id)\n  }\n  async findBy(collection: string, key: string, id: any) {\n    return this.collections.get(collection)!.findBy(key, id)\n  }\n  async findFirstBy(collection: string, key: string, id: any) {\n    return this.collections.get(collection)!.findFirstBy(key, id)\n  }\n  async findLastBy(collection: string, key: string, id: any) {\n    return this.collections.get(collection)!.findLastBy(key, id)\n  }\n}\n",
    "import { Item } from '../types/Item'\nimport {\n  ICollectionConfig,\n  ISerializedCollectionConfig,\n} from '../ICollectionConfig'\nimport { List } from '../storage/List'\nimport AdapterMemory from '../AdapterMemory'\nimport AdapterFile from '../AdapterFile'\nimport { FileStorage } from '../storage/FileStorage'\nimport { deserializeIndex } from '../collection'\n\nexport function deserialize_collection_config<T extends Item>(\n  config: ISerializedCollectionConfig,\n) {\n  const res = {} as ICollectionConfig<T>\n  res.name = config.name\n  res.root = config.root\n  res.rotate = config.rotate\n  res.ttl = config.ttl\n  res.audit = config?.audit ?? false\n  res.id = config.id || 'id'\n  res.auto = config.auto\n  res.indexList = config.indexList.map((index) => deserializeIndex<T>(index))\n  res.adapter =\n    config.adapter === 'AdapterMemory' ? new AdapterMemory() : new AdapterFile()\n  res.list =\n    config.list === 'List' ? new List<T>() : new FileStorage<T>()\n  return res\n}\n"
  ],
  "mappings": "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",
  "debugId": "B09D8D3D9FD5F75664756E2164756E21",
  "names": []
}