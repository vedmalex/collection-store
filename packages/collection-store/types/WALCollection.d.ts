import Collection from './collection';
import { Item } from './types/Item';
import { ICollectionConfig } from './ICollectionConfig';
import { WALTransactionManager, WALTransactionOptions } from './WALTransactionManager';
import { TraverseCondition } from './types/TraverseCondition';
import { ValueType } from 'b-pl-tree';
import { Paths } from './types/Paths';
import { IndexDef } from './types/IndexDef';
export interface WALCollectionConfig<T extends Item> extends ICollectionConfig<T> {
    walOptions?: WALTransactionOptions;
    enableTransactions?: boolean;
}
export declare class WALCollection<T extends Item> {
    private collection;
    private walTransactionManager?;
    private transactionalAdapter?;
    private walOptions;
    private enableTransactions;
    private currentTransactionId?;
    private constructor();
    static create<T extends Item>(config: WALCollectionConfig<T>): WALCollection<T>;
    private initializeWAL;
    private convertToTransactionalAdapter;
    private isTransactionalAdapter;
    persist(name?: string): Promise<void>;
    private persistInTransaction;
    private persistWithImplicitTransaction;
    beginTransaction(options?: WALTransactionOptions): Promise<string>;
    commitTransaction(transactionId: string): Promise<void>;
    rollbackTransaction(transactionId: string): Promise<void>;
    getCurrentTransactionId(): string | undefined;
    create(item: T): Promise<T | undefined>;
    updateWithId(id: ValueType, update: Partial<T>, merge?: boolean): Promise<T | undefined>;
    removeWithId(id: ValueType): Promise<T | undefined>;
    createCheckpoint(): Promise<string>;
    performRecovery(): Promise<void>;
    getWALEntries(fromSequence?: number): Promise<any[]>;
    isTransactionsEnabled(): boolean;
    getTransactionManager(): WALTransactionManager | undefined;
    getCollection(): Collection<T>;
    reset(): Promise<void>;
    get name(): string;
    get id(): string;
    get root(): string;
    get ttl(): number | undefined;
    get config(): import("./ICollectionConfig").ISerializedCollectionConfig;
    findById(id: ValueType): Promise<T | undefined>;
    findBy(key: Paths<T>, id: ValueType): Promise<Array<T>>;
    findFirstBy(key: Paths<T>, id: ValueType): Promise<T | undefined>;
    findLastBy(key: Paths<T>, id: ValueType): Promise<T | undefined>;
    find(condition: TraverseCondition<T>): Promise<Array<T>>;
    findFirst(condition: TraverseCondition<T>): Promise<T | undefined>;
    findLast(condition: TraverseCondition<T>): Promise<T | undefined>;
    first(): Promise<T>;
    last(): Promise<T>;
    oldest(): Promise<T | undefined>;
    latest(): Promise<T | undefined>;
    lowest(key: Paths<T>): Promise<T | undefined>;
    greatest(key: Paths<T>): Promise<T | undefined>;
    push(item: T): Promise<T | undefined>;
    save(item: T): Promise<T | undefined>;
    update(condition: TraverseCondition<T>, update: Partial<T>, merge?: boolean): Promise<Array<T>>;
    updateFirst(condition: TraverseCondition<T>, update: Partial<T>, merge?: boolean): Promise<T | undefined>;
    updateLast(condition: TraverseCondition<T>, update: Partial<T>, merge?: boolean): Promise<T | undefined>;
    remove(condition: TraverseCondition<T>): Promise<Array<T | undefined>>;
    removeFirst(condition: TraverseCondition<T>): Promise<T | undefined>;
    removeLast(condition: TraverseCondition<T>): Promise<T | undefined>;
    listIndexes(name: string): Array<{
        name: string;
        key: {
            [key: string]: any;
        };
    }>;
    dropIndex(name: string): any;
    load(name?: string): Promise<void>;
    createIndex(name: string, config: IndexDef<T>): Promise<void>;
}
