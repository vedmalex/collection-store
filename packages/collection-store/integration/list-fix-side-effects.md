# List.set() Fix Side Effects Analysis

## Проблема
После исправления `List.set()` для использования переданного ключа вместо `_counter`, сломались другие тесты.

## Анализ проблем

### 1. Уникальные индексы не работают
```
error: unique index id already contains value 10
```

**Причина:** Индексы накапливают данные между тестами, потому что элементы теперь сохраняются под строковыми ключами.

### 2. Неправильное количество элементов в индексах
```
Expected: 0
Received: 10
```

**Причина:** `Object.keys(collection.indexes.id).length` считает ключи в B+ дереве, но теперь структура изменилась.

### 3. Проблемы с восстановлением состояния
```
Expected: "_id"
Received: "id"
```

**Причина:** Функция `load()` не восстанавливает правильно поле ID из сохраненных данных.

## Корневые причины

### Проблема 1: Несогласованность между тестами
Тесты используют одни и те же файлы данных, но не очищают состояние между запусками.

### Проблема 2: Изменение семантики List
Переход от числовых ключей к строковым ключам изменил поведение:
- `_counter` больше не соответствует количеству элементов
- Методы подсчета элементов работают неправильно
- Сериализация/десериализация может быть нарушена

## Возможные решения

### Решение 1: Исправить очистку данных между тестами ✅
Добавить `beforeEach` хуки для очистки файлов данных.

### Решение 2: Исправить методы подсчета в List ✅
Обновить `length` и другие методы для работы со строковыми ключами.

### Решение 3: Исправить сериализацию ✅
Убедиться что `persist()` и `load()` работают с новой структурой.

### Решение 4: Альтернативный подход ❌
Вернуться к числовым ключам и исправить проблему по-другому.

## План исправления

1. ✅ Добавить очистку данных между тестами
2. ✅ Исправить методы подсчета в List
3. ✅ Проверить сериализацию/десериализацию
4. ✅ Протестировать все функции