{
  "version": 3,
  "sources": ["../src/Connection.ts", "../src/Driver.ts", "../src/Platform.ts", "../src/SchemaGenerator.ts", "../src/EntityManager.ts", "../src/EntityRepository.ts", "../src/errors.ts", "../src/index.ts", "../src/MikroORM.ts"],
  "sourcesContent": [
    "import {\n  Configuration,\n  Connection,\n  ConnectionOptions,\n  ConnectionType,\n  EntityName,\n  EventType,\n  IsolationLevel,\n  Transaction,\n  TransactionEventBroadcaster,\n  Utils,\n} from '@mikro-orm/core'\n\nimport { CSDatabase, Item } from 'collection-store'\nimport type { CSTransaction } from 'collection-store'\nimport type { SavepointConnection } from './types'\n\nexport class CollectionStoreConnection extends Connection implements SavepointConnection {\n  db!: CSDatabase\n\n  constructor(config: Configuration, options?: ConnectionOptions, type: ConnectionType = 'write') {\n    super(config, options, type)\n    // придумать что тут нужно сделать, а пока для тестов хватит\n  }\n\n  getDb() {\n    return this.db\n  }\n\n  getCollection<T extends Item>(name: EntityName<T>) {\n    return this.db.collection<T>(this.getCollectionName(name))\n  }\n\n  private getCollectionName<T>(_name: EntityName<T>): string {\n    const name = Utils.className(_name)\n    const meta = this.metadata.find(Utils.className(name))\n\n    return meta ? meta.collection : name\n  }\n  override async connect(): Promise<void> {\n    if (!this.db) {\n      this.db = new CSDatabase(this.getClientUrl(), this.options.dbName)\n      await this.db.connect()\n    }\n  }\n\n  override async isConnected(): Promise<boolean> {\n    return !!this.db\n  }\n\n  override checkConnection(): Promise<{ ok: true } | { ok: false; reason: string; error?: Error }> {\n    return Promise.resolve({ ok: true })\n  }\n\n  override getDefaultClientUrl(): string {\n    return './data'\n  }\n\n  override getClientUrl() {\n    const url = this.config.getClientUrl(true)\n    return url\n  }\n\n  async first(entityName: EntityName<any>): Promise<any> {\n    const collection = Utils.className(entityName)\n    return this.db.first(collection)\n  }\n\n  async last(entityName: EntityName<any>): Promise<any> {\n    const collection = Utils.className(entityName)\n    return this.db.last(collection)\n  }\n\n  async lowest(entityName: EntityName<any>, key: string) {\n    const collection = Utils.className(entityName)\n    return this.db.lowest(collection, key)\n  }\n  async greatest(entityName: EntityName<any>, key: string) {\n    const collection = Utils.className(entityName)\n    return this.db.greatest(collection, key)\n  }\n  async oldest(entityName: EntityName<any>) {\n    const collection = Utils.className(entityName)\n    return this.db.oldest(collection)\n  }\n  async latest(entityName: EntityName<any>) {\n    const collection = Utils.className(entityName)\n    return this.db.latest(collection)\n  }\n  async findById(entityName: EntityName<any>, id: any) {\n    const collection = Utils.className(entityName)\n    return this.db.findById(collection, id)\n  }\n  async findBy(entityName: EntityName<any>, key: string, id: any) {\n    const collection = Utils.className(entityName)\n    return this.db.findBy(collection, key, id)\n  }\n  async findFirstBy(entityName: EntityName<any>, key: string, id: any) {\n    const collection = Utils.className(entityName)\n    return this.db.findFirstBy(collection, key, id)\n  }\n  async findLastBy(entityName: EntityName<any>, key: string, id: any) {\n    const collection = Utils.className(entityName)\n    return this.db.findLastBy(collection, key, id)\n  }\n\n  override execute<T>(\n    query: string,\n    params?: any[] | undefined,\n    method?: 'all' | 'get' | 'run' | undefined,\n    ctx?: any,\n  ): Promise<any> {\n    throw new Error(`${this.constructor.name} does not support generic execute method`)\n  }\n\n  override async close(force?: boolean) {\n    await this.db.close()\n  }\n\n  override async ensureConnection() {\n    await this.connect()\n  }\n\n  // transaction support\n  override async transactional<T>(\n    cb: (trx: Transaction<CSTransaction>) => Promise<T>,\n    options: {\n      isolationLevel?: IsolationLevel\n      ctx?: Transaction<CSTransaction>\n      eventBroadcaster?: TransactionEventBroadcaster\n    } = {},\n  ): Promise<T> {\n    await this.ensureConnection()\n\n    // ✅ НОВОЕ: Если есть родительская транзакция, создаем savepoint вместо новой транзакции\n    if (options.ctx) {\n      const savepointName = `nested_tx_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`\n\n      try {\n        // Создаем savepoint в существующей транзакции\n        const savepointId = await this.createSavepoint(options.ctx, savepointName)\n\n        console.log(`[CollectionStoreConnection] Created savepoint '${savepointName}' for nested transaction`)\n\n        try {\n          const ret = await cb(options.ctx)\n\n          // Успешное выполнение - release savepoint\n          await this.releaseSavepoint(options.ctx, savepointId)\n          console.log(`[CollectionStoreConnection] Released savepoint '${savepointName}' after successful nested transaction`)\n\n          return ret\n        } catch (error) {\n          // Ошибка - rollback к savepoint\n          await this.rollbackToSavepoint(options.ctx, savepointId)\n          console.log(`[CollectionStoreConnection] Rolled back to savepoint '${savepointName}' after nested transaction error`)\n          throw error\n        }\n      } catch (savepointError) {\n        console.error(`[CollectionStoreConnection] Failed to manage savepoint for nested transaction:`, savepointError)\n        throw savepointError\n      }\n    } else {\n      // Обычная транзакция (корневая)\n      const session = await this.begin(options)\n\n      try {\n        const ret = await cb(session)\n        await this.commit(session, options?.eventBroadcaster)\n        return ret\n      } catch (error) {\n        await this.rollback(session, options?.eventBroadcaster)\n        throw error\n      } finally {\n        await session.endSession()\n      }\n    }\n  }\n  override async begin(\n    options: {\n      isolationLevel?: IsolationLevel\n      ctx?: Transaction<CSTransaction>\n      eventBroadcaster?: TransactionEventBroadcaster\n    } = {},\n  ): Promise<CSTransaction> {\n    await this.ensureConnection()\n    const { ctx, isolationLevel, eventBroadcaster, ...txOptions } = options\n\n    // ✅ НОВОЕ: Если есть родительская транзакция, возвращаем её (savepoint будет создан в transactional)\n    if (ctx) {\n      console.log(`[CollectionStoreConnection] Using existing transaction context for nested transaction`)\n      return ctx\n    }\n\n    // Создаем новую корневую транзакцию\n    if (!ctx) {\n      await eventBroadcaster?.dispatchEvent(EventType.beforeTransactionStart)\n    }\n\n    const session = await this.db.startSession()\n    session.startTransaction(txOptions)\n    this.logQuery('db.begin();')\n    await eventBroadcaster?.dispatchEvent(EventType.afterTransactionStart, session)\n\n    return session\n  }\n\n  override async commit(ctx: CSTransaction, eventBroadcaster?: TransactionEventBroadcaster): Promise<void> {\n    await this.ensureConnection()\n    await eventBroadcaster?.dispatchEvent(EventType.beforeTransactionCommit, ctx)\n    await ctx.commitTransaction()\n    this.logQuery('db.commit();')\n    await eventBroadcaster?.dispatchEvent(EventType.afterTransactionCommit, ctx)\n  }\n\n  override async rollback(ctx: CSTransaction, eventBroadcaster?: TransactionEventBroadcaster): Promise<void> {\n    await this.ensureConnection()\n\n    await eventBroadcaster?.dispatchEvent(EventType.beforeTransactionRollback, ctx)\n    await ctx.abortTransaction()\n    this.logQuery('db.rollback();')\n    await eventBroadcaster?.dispatchEvent(EventType.afterTransactionRollback, ctx)\n  }\n\n  // ✅ НОВЫЕ МЕТОДЫ: Savepoint support\n  async createSavepoint(ctx: CSTransaction, name: string): Promise<string> {\n    await this.ensureConnection()\n\n    try {\n      const savepointId = await ctx.createSavepoint(name)\n      this.logQuery(`SAVEPOINT ${name}; -- ${savepointId}`)\n      return savepointId\n    } catch (error) {\n      this.logQuery(`SAVEPOINT ${name}; -- FAILED: ${(error as Error).message}`)\n      throw error\n    }\n  }\n\n  async rollbackToSavepoint(ctx: CSTransaction, savepointId: string): Promise<void> {\n    await this.ensureConnection()\n\n    try {\n      await ctx.rollbackToSavepoint(savepointId)\n      this.logQuery(`ROLLBACK TO SAVEPOINT ${savepointId};`)\n    } catch (error) {\n      this.logQuery(`ROLLBACK TO SAVEPOINT ${savepointId}; -- FAILED: ${(error as Error).message}`)\n      throw error\n    }\n  }\n\n  async releaseSavepoint(ctx: CSTransaction, savepointId: string): Promise<void> {\n    await this.ensureConnection()\n\n    try {\n      await ctx.releaseSavepoint(savepointId)\n      this.logQuery(`RELEASE SAVEPOINT ${savepointId};`)\n    } catch (error) {\n      this.logQuery(`RELEASE SAVEPOINT ${savepointId}; -- FAILED: ${(error as Error).message}`)\n      throw error\n    }\n  }\n}\n",
    "import {\n  Configuration,\n  DatabaseDriver,\n  EntityData,\n  EntityDictionary,\n  EntityName,\n  FilterQuery,\n  FindOptions,\n  QueryResult,\n  EntityManagerType,\n  EntityRepository,\n  Constructor,\n} from '@mikro-orm/core'\n//@ts-ignore\nimport { Item } from 'collection-store'\nimport { CollectionStoreConnection } from './Connection'\nimport { CollectionStorePlatform } from './Platform'\nimport { CollectionStoreEntityManager } from './EntityManager'\nimport { CollectionStoreEntityRepository } from './EntityRepository'\n\nexport class CollectionStoreDriver extends DatabaseDriver<CollectionStoreConnection> {\n  override [EntityManagerType]!: CollectionStoreEntityManager<this>\n  protected override readonly platform = new CollectionStorePlatform()\n  protected override readonly connection = new CollectionStoreConnection(this.config)\n\n  constructor(config: Configuration) {\n    super(config, ['collection-store'])\n  }\n\n  getRepositoryClass(): Constructor<EntityRepository<any>> {\n    return CollectionStoreEntityRepository as any\n  }\n\n  override createEntityManager<T extends object = object>(useContext?: boolean): CollectionStoreEntityManager {\n    return new CollectionStoreEntityManager(this.config, this, this.metadata, useContext)\n  }\n\n  override async find<T extends object>(entityName: string, where: FilterQuery<T>): Promise<EntityData<T>[]> {\n    if (this.metadata.find(entityName)?.virtual) {\n      return this.findVirtual(entityName, where, {})\n    }\n\n    const res = await this.connection.db.collection<T>(entityName)?.find(where as any)\n    if (res) {\n      //@ts-ignore\n      return res.reduce((res, cur) => {\n        res.push(cur)\n        return res\n      }, [] as EntityData<T>[])\n    }\n    return []\n  }\n  override async findOne<T extends object>(entityName: string, where: FilterQuery<T>): Promise<EntityData<T> | null> {\n    if (this.metadata.find(entityName)?.virtual) {\n      const [item] = await this.findVirtual(entityName, where, {} as FindOptions<T, any, any, any>)\n      /* istanbul ignore next */\n      return item ?? null\n    }\n    const res = await this.connection.db.collection<T>(entityName)?.findFirst(where as any)\n    if (res) {\n      return res\n    }\n    return null\n  }\n\n  override async connect(): Promise<CollectionStoreConnection> {\n    await this.connection.connect()\n    return this.connection\n  }\n  override async nativeInsert<T extends Item>(entityName: string, data: EntityDictionary<T>): Promise<QueryResult<T>> {\n    const meta = this.metadata.find(entityName)\n    const pk = meta?.getPrimaryProps()[0].fieldNames[0] ?? 'id'\n    const res = await this.connection.db.collection<T>(entityName)?.create(data)\n    return {\n      insertId: res?.[pk],\n      affectedRows: 1,\n      row: res, // Return full record data instead of just ID\n    }\n  }\n\n  override async nativeInsertMany<T extends Item>(\n    entityName: string,\n    data: EntityDictionary<T>[],\n  ): Promise<QueryResult<T>> {\n    const res = data.map((d) => {\n      return this.nativeInsert(entityName, d)\n    })\n    const result = (await Promise.allSettled(res)).reduce(\n      (res, cur) => {\n        if (cur.status === 'fulfilled') {\n          res.affectedRows += 1\n          res.insertedIds?.push(cur.value.insertId)\n          res.rows!.push(cur.value.row!)\n          res.insertId = cur.value.insertId\n        } else {\n        }\n        return res\n      },\n      { insertIds: [], affectedRows: 0, rows: [] } as unknown as QueryResult<T>,\n    )\n\n    console.log(`[nativeInsertMany] final result:`, JSON.stringify(result, null, 2))\n    return result\n  }\n\n  override async nativeUpdate<T extends Item>(\n    entityName: string,\n    where: FilterQuery<T>,\n    data: EntityDictionary<T>,\n  ): Promise<QueryResult<T>> {\n    const meta = this.metadata.find(entityName)\n    const pk = meta?.getPrimaryProps()[0].fieldNames[0] ?? '_id'\n    const res = await this.connection.db.collection<T>(entityName)?.update(where as any, data)!\n    return {\n      insertId: res[0][pk],\n      affectedRows: 1,\n    }\n  }\n\n  override async nativeDelete<T extends Item>(entityName: string, where: FilterQuery<T>): Promise<QueryResult<T>> {\n    const meta = this.metadata.find(entityName)\n    const pk = meta?.getPrimaryProps()[0].fieldNames[0] ?? '_id'\n    const res = await this.connection.db.collection<T>(entityName)?.remove(where as any)!\n    return {\n      insertId: res[0]?.[pk],\n      affectedRows: res.length,\n    }\n  }\n\n  override async count<T extends Item>(entityName: string, where: FilterQuery<T>): Promise<number> {\n    const res = await this.find(entityName, where)\n    return res.length\n  }\n\n  override async findVirtual<T extends object>(\n    entityName: string,\n    where: FilterQuery<T>,\n    options: FindOptions<T, any, any, any>,\n  ): Promise<EntityData<T>[]> {\n    const meta = this.metadata.find(entityName)!\n\n    if (meta.expression instanceof Function) {\n      const em = this.createEntityManager()\n      return meta.expression(em, where, options as any) as any\n    }\n\n    return super.findVirtual(entityName, where, options)\n  }\n  // extra operations\n  async first(entityName: EntityName<any>): Promise<any> {\n    return this.getConnection('read').first(entityName)\n  }\n  async last(entityName: EntityName<any>): Promise<any> {\n    return this.getConnection('read').last(entityName)\n  }\n  async lowest(entityName: EntityName<any>, key: string): Promise<any> {\n    return this.getConnection('read').lowest(entityName, key)\n  }\n  async greatest(entityName: EntityName<any>, key: string): Promise<any> {\n    return this.getConnection('read').greatest(entityName, key)\n  }\n  async oldest(entityName: EntityName<any>): Promise<any> {\n    return this.getConnection('read').oldest(entityName)\n  }\n  async latest(entityName: EntityName<any>): Promise<any> {\n    return this.getConnection('read').latest(entityName)\n  }\n  async findById(entityName: EntityName<any>, id: any) {\n    return this.getConnection('read').findById(entityName, id)\n  }\n  async findBy(entityName: EntityName<any>, key: string, id: any) {\n    return this.getConnection('read').findBy(entityName, key, id)\n  }\n  async findFirstBy(entityName: EntityName<any>, key: string, id: any) {\n    return this.getConnection('read').findFirstBy(entityName, key, id)\n  }\n  async findLastBy(entityName: EntityName<any>, key: string, id: any) {\n    return this.getConnection('read').findLastBy(entityName, key, id)\n  }\n}\n",
    "import {\n  EntityCaseNamingStrategy,\n  EntityManager,\n  IDatabaseDriver,\n  MikroORM,\n  NamingStrategy,\n  Platform,\n  IPrimaryKey,\n} from '@mikro-orm/core'\nimport { CollectionStoreSchemaGenerator } from './SchemaGenerator'\n\nexport class CollectionStorePlatform extends Platform {\n  /* istanbul ignore next: kept for type inference only */\n  override getSchemaGenerator(\n    driver: IDatabaseDriver,\n    em?: EntityManager,\n  ): CollectionStoreSchemaGenerator {\n    return new CollectionStoreSchemaGenerator(em ?? (driver as any))\n  }\n  /** @inheritDoc */\n  override lookupExtensions(orm: MikroORM): void {\n    CollectionStoreSchemaGenerator.register(orm)\n  }\n\n  override supportsTransactions(): boolean {\n    return true\n  }\n\n  supportsSavePoints(): boolean {\n    return true\n  }\n\n  override getNamingStrategy(): { new (): NamingStrategy } {\n    return EntityCaseNamingStrategy\n  }\n\n  getIdentifierQuoteCharacter(): string {\n    return ''\n  }\n\n  getParameterPlaceholder(index?: number): string {\n    return '?'\n  }\n\n  override usesReturningStatement(): boolean {\n    return false\n  }\n\n  override usesPivotTable(): boolean {\n    return false\n  }\n\n  override normalizePrimaryKey<T = number | string>(data: IPrimaryKey): T {\n    return data as T\n  }\n\n  override denormalizePrimaryKey(data: IPrimaryKey): IPrimaryKey {\n    return data\n  }\n\n  override getSerializedPrimaryKeyField(field: string): string {\n    return field\n  }\n}\n",
    "import {\n  AbstractSchemaGenerator,\n  type EntityMetadata,\n  type EntityProperty,\n  type MikroORM,\n  Utils,\n} from '@mikro-orm/core'\nimport type { CollectionStoreDriver } from './Driver'\n\nexport class CollectionStoreSchemaGenerator extends AbstractSchemaGenerator<CollectionStoreDriver> {\n  static register(orm: MikroORM): void {\n    orm.config.registerExtension('@mikro-orm/schema-generator', () => new CollectionStoreSchemaGenerator(orm.em as any))\n  }\n\n  override async createSchema(options: CreateSchemaOptions = {}) {\n    options.ensureIndexes ??= true\n    const db = this.connection.getDb()\n    const collections = db.listCollections()\n    //@ts-ignore\n    const existing = collections.map((c) => c.name)\n    const metadata = this.getOrderedMetadata()\n    metadata.push({\n      collection: this.config.get('migrations').tableName,\n    } as any)\n\n    await Promise.all(\n      metadata\n        .filter((meta) => !existing.includes(meta.collection))\n        .map((meta) => this.connection.db.createCollection(meta.collection)),\n    )\n\n    if (options.ensureIndexes) {\n      await this.ensureIndexes({ ensureCollections: false })\n    }\n  }\n\n  override async dropSchema(options: { dropMigrationsTable?: boolean } = {}) {\n    const db = this.connection.getDb()\n    const collections = db.listCollections()\n    //@ts-ignore\n    const existing = collections.map((c) => c.name)\n    const metadata = this.getOrderedMetadata()\n\n    if (options.dropMigrationsTable) {\n      metadata.push({\n        collection: this.config.get('migrations').tableName,\n      } as any)\n    }\n\n    await Promise.all(\n      metadata\n        .filter((meta) => existing.includes(meta.collection))\n        .map((meta) => this.connection.db.dropCollection(meta.collection)),\n    )\n  }\n\n  override async updateSchema(options: CreateSchemaOptions = {}): Promise<void> {\n    await this.createSchema(options)\n  }\n\n  override async ensureDatabase(): Promise<boolean> {\n    return false\n  }\n\n  override async refreshDatabase(options: CreateSchemaOptions = {}): Promise<void> {\n    await this.ensureDatabase()\n    await this.dropSchema()\n    await this.createSchema(options)\n  }\n\n  override async ensureIndexes(options: EnsureIndexesOptions = {}): Promise<void> {\n    options.ensureCollections ??= true\n\n    if (options.ensureCollections) {\n      await this.createSchema({ ensureIndexes: false })\n    }\n\n    // где-то тут нужно удалить ненужные индексы\n    // где-то тут нужно сказать, что сложные индексы не используем\n    for (const meta of this.getOrderedMetadata()) {\n      await this.createIndexes(meta)\n      this.createUniqueIndexes(meta)\n\n      for (const prop of meta.props) {\n        this.createPropertyIndexes(meta, prop, 'index')\n        this.createPropertyIndexes(meta, prop, 'unique')\n\n        // Create indexes for all properties to support findBy, lowest, greatest methods\n        await this.createAutoIndexes(meta, prop)\n      }\n    }\n  }\n\n  private async createIndexes(meta: EntityMetadata) {\n    for (const index of meta.indexes) {\n      const properties = Utils.flatten(Utils.asArray(index.properties).map((prop) => meta.properties[prop].fieldNames))\n      const db = this.connection.getDb()\n\n      const fieldOrSpec = properties[0]\n\n      await db.createIndex(meta.className, fieldOrSpec, {\n        key: fieldOrSpec,\n        unique: false,\n        ...(index.options || {}),\n      })\n    }\n  }\n\n  private async createUniqueIndexes(meta: EntityMetadata) {\n    for (const index of meta.uniques) {\n      const properties = Utils.flatten(Utils.asArray(index.properties).map((prop) => meta.properties[prop].fieldNames))\n\n      const fieldOrSpec = properties[0]\n\n      const db = this.connection.getDb()\n      await db.createIndex(meta.className, fieldOrSpec, {\n        key: fieldOrSpec,\n        unique: true,\n        ...(index.options || {}),\n      })\n    }\n  }\n\n  private async createPropertyIndexes(meta: EntityMetadata, prop: EntityProperty, type: 'index' | 'unique') {\n    if (!prop[type] || !meta.collection) {\n      return\n    }\n\n    const db = this.connection.getDb()\n    const fieldOrSpec = prop.embeddedPath ? prop.embeddedPath.join('.') : prop.fieldNames[0]\n\n    await db.createIndex(meta.className, fieldOrSpec, {\n      key: fieldOrSpec,\n      unique: type === 'unique',\n      sparse: prop.nullable === true,\n      required: !prop.nullable,\n    })\n  }\n\n  private async createAutoIndexes(meta: EntityMetadata, prop: EntityProperty) {\n    // Skip if already has explicit index or unique constraint\n    if (prop.index || prop.unique || !meta.collection) {\n      return\n    }\n\n    // Skip primary keys as they already have indexes\n    if (prop.primary) {\n      return\n    }\n\n    // Skip relations and embedded properties\n    if (prop.kind && (prop.kind.toString().includes('m:') || prop.kind.toString().includes('1:') || prop.kind.toString().includes('embedded'))) {\n      return\n    }\n\n    const db = this.connection.getDb()\n    const fieldOrSpec = prop.embeddedPath ? prop.embeddedPath.join('.') : prop.fieldNames[0]\n\n    try {\n      await db.createIndex(meta.className, fieldOrSpec, {\n        key: fieldOrSpec,\n        unique: false,\n        sparse: prop.nullable === true,\n        required: !prop.nullable,\n      })\n    } catch (error) {\n      // Ignore errors if index already exists\n      console.warn(`Failed to create auto-index for ${meta.className}.${fieldOrSpec}:`, error.message)\n    }\n  }\n}\n\nexport interface CreateSchemaOptions {\n  /** create indexes? defaults to true */\n  ensureIndexes?: boolean\n  /** not valid for mongo driver */\n  wrap?: boolean\n  /** not valid for mongo driver */\n  schema?: string\n}\n\nexport interface EnsureIndexesOptions {\n  ensureCollections?: boolean\n  retry?: boolean | string[]\n  retryLimit?: number\n}\n",
    "import {\n  EntityManager,\n  type EntityName,\n  type EntityRepository,\n  type GetRepository,\n  ForkOptions,\n} from '@mikro-orm/core'\nimport type { CollectionStoreDriver } from './Driver'\nimport type { CollectionStoreEntityRepository } from './EntityRepository'\n//@ts-ignore\nimport { Item } from 'collection-store'\n\n/**\n * @inheritDoc\n */\nexport class CollectionStoreEntityManager<\n  D extends CollectionStoreDriver = CollectionStoreDriver,\n> extends EntityManager<D> {\n  override fork(\n    options?: ForkOptions | undefined,\n  ): this {\n    return super.fork(options) as this\n  }\n  async first(entityName: EntityName<any>): Promise<any> {\n    return this.getDriver().first(entityName)\n  }\n  async last(entityName: EntityName<any>): Promise<any> {\n    return this.getDriver().last(entityName)\n  }\n  async lowest(entityName: EntityName<any>, key: string): Promise<any> {\n    return this.getDriver().lowest(entityName, key)\n  }\n  async greatest(entityName: EntityName<any>, key: string): Promise<any> {\n    return this.getDriver().greatest(entityName, key)\n  }\n  async oldest(entityName: EntityName<any>): Promise<any> {\n    return this.getDriver().oldest(entityName)\n  }\n  async latest(entityName: EntityName<any>): Promise<any> {\n    return this.getDriver().latest(entityName)\n  }\n  async findById(entityName: EntityName<any>, id: any) {\n    return this.getDriver().findById(entityName, id)\n  }\n  async findBy(entityName: EntityName<any>, key: string, id: any) {\n    return this.getDriver().findBy(entityName, key, id)\n  }\n  async findFirstBy(entityName: EntityName<any>, key: string, id: any) {\n    return this.getDriver().findFirstBy(entityName, key, id)\n  }\n  async findLastBy(entityName: EntityName<any>, key: string, id: any) {\n    return this.getDriver().findLastBy(entityName, key, id)\n  }\n\n  getCollection<T extends Item>(entityName: EntityName<T>) {\n    return this.getConnection().getCollection(entityName)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  override getRepository<\n    T extends object,\n    U extends EntityRepository<T> = CollectionStoreEntityRepository<T>,\n  >(entityName: EntityName<T>): GetRepository<T, U> {\n    return super.getRepository<T, U>(entityName)\n  }\n}\n",
    "import { EntityRepository, EntityName } from '@mikro-orm/core'\nimport type { CollectionStoreEntityManager } from './EntityManager'\n//@ts-ignore\nimport { Item } from 'collection-store'\n\nexport class CollectionStoreEntityRepository<\n  T extends Item,\n> extends EntityRepository<T> {\n  constructor(\n    em: CollectionStoreEntityManager,\n    entityName: EntityName<T>,\n  ) {\n    super(em, entityName)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  override getEntityManager(): CollectionStoreEntityManager {\n    return this.em as CollectionStoreEntityManager\n  }\n\n  // Collection Store custom methods\n  async first(): Promise<T | undefined> {\n    return this.getEntityManager().first(this.entityName)\n  }\n\n  async last(): Promise<T | undefined> {\n    return this.getEntityManager().last(this.entityName)\n  }\n\n  async lowest(key: string): Promise<T | undefined> {\n    return this.getEntityManager().lowest(this.entityName, key)\n  }\n\n  async greatest(key: string): Promise<T | undefined> {\n    return this.getEntityManager().greatest(this.entityName, key)\n  }\n\n  async oldest(): Promise<T | undefined> {\n    return this.getEntityManager().oldest(this.entityName)\n  }\n\n  async latest(): Promise<T | undefined> {\n    return this.getEntityManager().latest(this.entityName)\n  }\n\n  async findById(id: any): Promise<T | undefined> {\n    return this.getEntityManager().findById(this.entityName, id)\n  }\n\n  async findBy(key: string, id: any): Promise<T[]> {\n    return this.getEntityManager().findBy(this.entityName, key, id)\n  }\n\n  async findFirstBy(key: string, id: any): Promise<T | undefined> {\n    return this.getEntityManager().findFirstBy(this.entityName, key, id)\n  }\n\n  async findLastBy(key: string, id: any): Promise<T | undefined> {\n    return this.getEntityManager().findLastBy(this.entityName, key, id)\n  }\n\n  getCollection() {\n    return this.getEntityManager().getCollection(this.entityName)\n  }\n}\n",
    "/**\n * Collection Store specific error types for MikroORM compatibility\n */\n\nexport class CollectionStoreError extends Error {\n  public readonly code?: string\n\n  constructor(message: string, code?: string) {\n    super(message)\n    this.name = 'CollectionStoreError'\n    this.code = code\n  }\n}\n\nexport class CollectionStoreValidationError extends CollectionStoreError {\n  public readonly violations: any[]\n\n  constructor(message: string, violations: any[]) {\n    super(message, 'VALIDATION_ERROR')\n    this.name = 'CollectionStoreValidationError'\n    this.violations = violations\n  }\n}\n\nexport class CollectionStoreNotFoundError extends CollectionStoreError {\n  constructor(entityName: string, where: any) {\n    super(`${entityName} not found for criteria ${JSON.stringify(where)}`, 'NOT_FOUND')\n    this.name = 'CollectionStoreNotFoundError'\n  }\n}\n\nexport class CollectionStoreConnectionError extends CollectionStoreError {\n  constructor(message: string) {\n    super(message, 'CONNECTION_ERROR')\n    this.name = 'CollectionStoreConnectionError'\n  }\n}\n\nexport class CollectionStoreTransactionError extends CollectionStoreError {\n  constructor(message: string) {\n    super(message, 'TRANSACTION_ERROR')\n    this.name = 'CollectionStoreTransactionError'\n  }\n}\n\nexport class CollectionStoreSavepointError extends CollectionStoreError {\n  public readonly savepointId?: string\n\n  constructor(message: string, savepointId?: string) {\n    super(message, 'SAVEPOINT_ERROR')\n    this.name = 'CollectionStoreSavepointError'\n    this.savepointId = savepointId\n  }\n}",
    "/* istanbul ignore file */\n\n// Collection Store specific exports\nexport * from './Connection'\nexport * from './Driver'\nexport * from './Platform'\nexport { CollectionStoreSchemaGenerator } from './SchemaGenerator'\nexport * from './types'\nexport * from './errors'\n\n// Core MikroORM exports - ALL decorators, types, and utilities\nexport * from '@mikro-orm/core'\n\n// Collection Store specific classes with aliases for compatibility\nexport { CollectionStoreEntityManager as EntityManager } from './EntityManager'\nexport { CollectionStoreEntityRepository as EntityRepository } from './EntityRepository'\nexport {\n  CollectionStoreMikroORM as MikroORM,\n  type CollectionStoreOptions as Options,\n  defineCollectionStoreConfig as defineConfig,\n} from './MikroORM'\n\n// Additional exports for full compatibility\nexport { CollectionStoreEntityManager } from './EntityManager'\nexport { CollectionStoreEntityRepository } from './EntityRepository'\nexport { CollectionStoreMikroORM, type CollectionStoreOptions } from './MikroORM'\nexport { CollectionStoreConnection } from './Connection'\nexport { CollectionStoreDriver } from './Driver'\nexport { CollectionStorePlatform } from './Platform'\n",
    "import {\n  defineConfig,\n  MikroORM,\n  type Options,\n  type IDatabaseDriver,\n  EntityManagerType,\n  EntityManager,\n} from '@mikro-orm/core'\nimport { CollectionStoreDriver } from './Driver'\nimport { CollectionStoreEntityManager } from './EntityManager'\n\n/**\n * @inheritDoc\n */\nexport class CollectionStoreMikroORM<\n  EM extends EntityManager = CollectionStoreEntityManager,\n> extends MikroORM<CollectionStoreDriver, EM> {\n  // @ts-ignore\n  private static DRIVER = CollectionStoreDriver\n\n  /**\n   * @inheritDoc\n   */\n  static override async init<\n    D extends IDatabaseDriver = CollectionStoreDriver,\n    EM extends EntityManager = D[typeof EntityManagerType] & EntityManager,\n  >(options?: Options<D, EM>): Promise<MikroORM<D, EM>> {\n    return super.init(options)\n  }\n\n  /**\n   * @inheritDoc\n   */\n  static override initSync<\n    D extends IDatabaseDriver = CollectionStoreDriver,\n    EM extends EntityManager = D[typeof EntityManagerType] & EntityManager,\n  >(options: Options<D, EM>): MikroORM<D, EM> {\n    return super.initSync(options)\n  }\n}\n\nexport type CollectionStoreOptions = Options<CollectionStoreDriver>\n\n/**\n * Helper function to define Collection Store MikroORM configuration with smart defaults\n * @param options - Configuration options\n * @returns Complete MikroORM configuration\n */\nexport function defineCollectionStoreConfig(options: Partial<CollectionStoreOptions> = {}) {\n  const config = {\n    // Collection Store driver\n    driver: CollectionStoreDriver,\n\n    // Smart defaults for Collection Store\n    dbName: options.dbName || ':memory:',\n    debug: options.debug ?? true,\n\n    // Entity discovery\n    entities: options.entities || [],\n    entitiesTs: options.entitiesTs || ['src/**/*.entity.ts'],\n\n    // Optimized settings for in-memory database\n    cache: {\n      enabled: true,\n      adapter: 'memory' as const,\n      ...(options as any).cache,\n    },\n\n    // Performance optimizations\n    forceEntityConstructor: true,\n    forceUndefined: false,\n\n    // Development helpers\n    validate: options.validate ?? true,\n    strict: options.strict ?? true,\n\n    // Override with user options\n    ...options,\n  }\n\n  return defineConfig(config as Options<CollectionStoreDriver>)\n}\n"
  ],
  "mappings": "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",
  "debugId": "FDC1770042258ACC64756E2164756E21",
  "names": []
}